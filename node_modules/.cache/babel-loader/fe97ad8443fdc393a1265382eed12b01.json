{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _ParseFileEncode = require(\"./ParseFileEncode\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst ParseError = require('./ParseError').default;\n/*:: type Base64 = { base64: string };*/\n\n/*:: type Uri = { uri: string };*/\n\n/*:: type FileData = Array<number> | Base64 | Blob | Uri;*/\n\n/*:: export type FileSource =\n  | {\n      format: 'file',\n      file: Blob,\n      type: string,\n    }\n  | {\n      format: 'base64',\n      base64: string,\n      type: string,\n    }\n  | {\n      format: 'uri',\n      uri: string,\n      type: string,\n    };*/\n\n\nconst dataUriRegexp = /^data:([a-zA-Z]+\\/[-a-zA-Z0-9+.]+)(;charset=[a-zA-Z0-9\\-/]*)?;base64,/;\n/**\n * A Parse.File is a local representation of a file that is saved to the Parse\n * cloud.\n *\n * @alias Parse.File\n */\n\nclass ParseFile {\n  /**\n   * @param name {String} The file's name. This will be prefixed by a unique\n   *     value once the file has finished saving. The file name must begin with\n   *     an alphanumeric character, and consist of alphanumeric characters,\n   *     periods, spaces, underscores, or dashes.\n   * @param data {Array} The data for the file, as either:\n   *     1. an Array of byte value Numbers, or\n   *     2. an Object like { base64: \"...\" } with a base64-encoded String.\n   *     3. an Object like { uri: \"...\" } with a uri String.\n   *     4. a File object selected with a file upload control. (3) only works\n   *        in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.\n   *        For example:\n   * <pre>\n   * var fileUploadControl = $(\"#profilePhotoFileUpload\")[0];\n   * if (fileUploadControl.files.length > 0) {\n   *   var file = fileUploadControl.files[0];\n   *   var name = \"photo.jpg\";\n   *   var parseFile = new Parse.File(name, file);\n   *   parseFile.save().then(function() {\n   *     // The file has been saved to Parse.\n   *   }, function(error) {\n   *     // The file either could not be read, or could not be saved to Parse.\n   *   });\n   * }</pre>\n   * @param type {String} Optional Content-Type header to use for the file. If\n   *     this is omitted, the content type will be inferred from the name's\n   *     extension.\n   * @param metadata {Object} Optional key value pairs to be stored with file object\n   * @param tags {Object} Optional key value pairs to be stored with file object\n   */\n  constructor(name\n  /*: string*/\n  , data\n  /*:: ?: FileData*/\n  , type\n  /*:: ?: string*/\n  , metadata\n  /*:: ?: Object*/\n  , tags\n  /*:: ?: Object*/\n  ) {\n    _defineProperty(this, \"_name\", void 0);\n\n    _defineProperty(this, \"_url\", void 0);\n\n    _defineProperty(this, \"_hash\", void 0);\n\n    _defineProperty(this, \"_ipfs\", void 0);\n\n    _defineProperty(this, \"_source\", void 0);\n\n    _defineProperty(this, \"_previousSave\", void 0);\n\n    _defineProperty(this, \"_data\", void 0);\n\n    _defineProperty(this, \"_requestTask\", void 0);\n\n    _defineProperty(this, \"_metadata\", void 0);\n\n    _defineProperty(this, \"_tags\", void 0);\n\n    const specifiedType = type || '';\n    this._name = name;\n    this._metadata = metadata || {};\n    this._tags = tags || {};\n\n    if (data !== undefined) {\n      if (Array.isArray(data)) {\n        this._data = ParseFile.encodeBase64(data);\n        this._source = {\n          format: 'base64',\n          base64: this._data,\n          type: specifiedType\n        };\n      } else if (typeof Blob !== 'undefined' && data instanceof Blob) {\n        this._source = {\n          format: 'file',\n          file: data,\n          type: specifiedType\n        };\n      } else if (data && typeof data.uri === 'string' && data.uri !== undefined) {\n        this._source = {\n          format: 'uri',\n          uri: data.uri,\n          type: specifiedType\n        };\n      } else if (data && typeof data.base64 === 'string') {\n        const {\n          base64\n        } = data;\n        const commaIndex = base64.indexOf(',');\n\n        if (commaIndex !== -1) {\n          const matches = dataUriRegexp.exec(base64.slice(0, commaIndex + 1)); // if data URI with type and charset, there will be 4 matches.\n\n          this._data = base64.slice(commaIndex + 1);\n          this._source = {\n            format: 'base64',\n            base64: this._data,\n            type: matches[1]\n          };\n        } else {\n          this._data = base64;\n          this._source = {\n            format: 'base64',\n            base64: base64,\n            type: specifiedType\n          };\n        }\n      } else {\n        throw new TypeError('Cannot create a Parse.File with that data.');\n      }\n    }\n  }\n  /**\n   * Return the data for the file, downloading it if not already present.\n   * Data is present if initialized with Byte Array, Base64 or Saved with Uri.\n   * Data is cleared if saved with File object selected with a file upload control\n   *\n   * @returns {Promise} Promise that is resolve with base64 data\n   */\n\n\n  async getData()\n  /*: Promise<String>*/\n  {\n    if (this._data) {\n      return this._data;\n    }\n\n    if (!this._url) {\n      throw new Error('Cannot retrieve data for unsaved ParseFile.');\n    }\n\n    const controller = _CoreManager.default.getFileController();\n\n    const result = await controller.download(this._url, {\n      requestTask: task => this._requestTask = task\n    });\n    this._data = result.base64;\n    return this._data;\n  }\n  /**\n   * Gets the name of the file. Before save is called, this is the filename\n   * given by the user. After save is called, that name gets prefixed with a\n   * unique identifier.\n   *\n   * @returns {string}\n   */\n\n\n  name()\n  /*: string*/\n  {\n    return this._name;\n  }\n  /**\n   * Gets the url of the file. It is only available after you save the file or\n   * after you get the file from a Parse.Object.\n   *\n   * @param {object} options An object to specify url options\n   * @returns {string}\n   */\n\n\n  url(options\n  /*:: ?: { forceSecure?: boolean }*/\n  )\n  /*: ?string*/\n  {\n    options = options || {};\n\n    if (!this._url) {\n      return;\n    }\n\n    if (options.forceSecure) {\n      return this._url.replace(/^http:\\/\\//i, 'https://');\n    }\n\n    return this._url;\n  }\n\n  ipfs() {\n    return this._ipfs;\n  }\n\n  hash() {\n    return this._hash;\n  }\n  /**\n   * Gets the metadata of the file.\n   *\n   * @returns {object}\n   */\n\n\n  metadata()\n  /*: Object*/\n  {\n    return this._metadata;\n  }\n  /**\n   * Gets the tags of the file.\n   *\n   * @returns {object}\n   */\n\n\n  tags()\n  /*: Object*/\n  {\n    return this._tags;\n  }\n  /**\n   * Saves the file to the Parse cloud.\n   *\n   * @param {object} options\n   *  * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *     behalf of a specific user.\n   *   <li>progress: In Browser only, callback for upload progress. For example:\n   * <pre>\n   * let parseFile = new Parse.File(name, file);\n   * parseFile.save({\n   *   progress: (progressValue, loaded, total, { type }) => {\n   *     if (type === \"upload\" && progressValue !== null) {\n   *       // Update the UI using progressValue\n   *     }\n   *   }\n   * });\n   * </pre>\n   * </ul>\n   * @returns {Promise} Promise that is resolved when the save finishes.\n   */\n\n\n  save(options\n  /*:: ?: FullOptions*/\n  ) {\n    options = options || {};\n\n    options.requestTask = task => this._requestTask = task;\n\n    options.metadata = this._metadata;\n    options.tags = this._tags;\n\n    const controller = _CoreManager.default.getFileController();\n\n    if (!this._previousSave) {\n      if (this._source.format === 'file') {\n        this._previousSave = controller.saveFile(this._name, this._source, options).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._hash = res.hash;\n          this._ipfs = res.ipfs;\n          this._data = null;\n          this._requestTask = null;\n          return this;\n        });\n      } else if (this._source.format === 'uri') {\n        this._previousSave = controller.download(this._source.uri, options).then(result => {\n          if (!(result && result.base64)) {\n            return {};\n          }\n\n          const newSource = {\n            format: 'base64',\n            base64: result.base64,\n            type: result.contentType\n          };\n          this._data = result.base64;\n          this._requestTask = null;\n          return controller.saveBase64(this._name, newSource, options);\n        }).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._hash = res.hash;\n          this._ipfs = res.ipfs;\n          this._requestTask = null;\n          return this;\n        });\n      } else {\n        this._previousSave = controller.saveBase64(this._name, this._source, options).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._hash = res.hash;\n          this._ipfs = res.ipfs;\n          this._requestTask = null;\n          return this;\n        });\n      }\n    }\n\n    if (this._previousSave) {\n      return this._previousSave;\n    }\n  }\n\n  saveIPFS(options\n  /*:: ?: FullOptions*/\n  ) {\n    return this.save(_objectSpread(_objectSpread({}, options), {}, {\n      ipfs: true\n    }));\n  }\n  /**\n   * Aborts the request if it has already been sent.\n   */\n\n\n  cancel() {\n    if (this._requestTask && typeof this._requestTask.abort === 'function') {\n      this._requestTask.abort();\n    }\n\n    this._requestTask = null;\n  }\n  /**\n   * Deletes the file from the Parse cloud.\n   * In Cloud Code and Node only with Master Key.\n   *\n   * @param {object} options\n   *  * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   * <pre>\n   * @returns {Promise} Promise that is resolved when the delete finishes.\n   */\n\n\n  destroy() {\n    let options\n    /*:: ?: FullOptions*/\n    = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this._name) {\n      throw new ParseError(ParseError.FILE_DELETE_UNNAMED_ERROR, 'Cannot delete an unnamed file.');\n    }\n\n    const destroyOptions = {\n      useMasterKey: true\n    };\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      destroyOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getFileController();\n\n    return controller.deleteFile(this._name, destroyOptions).then(() => {\n      this._data = null;\n      this._requestTask = null;\n      return this;\n    });\n  }\n\n  toJSON()\n  /*: { name: ?string, url: ?string }*/\n  {\n    return {\n      __type: 'File',\n      name: this._name,\n      url: this._url,\n      ipfs: this._ipfs,\n      hash: this._hash\n    };\n  }\n\n  equals(other\n  /*: mixed*/\n  )\n  /*: boolean*/\n  {\n    if (this === other) {\n      return true;\n    } // Unsaved Files are never equal, since they will be saved to different URLs\n\n\n    return other instanceof ParseFile && this.name() === other.name() && this.url() === other.url() && typeof this.url() !== 'undefined';\n  }\n  /**\n   * Sets metadata to be saved with file object. Overwrites existing metadata\n   *\n   * @param {object} metadata Key value pairs to be stored with file object\n   */\n\n\n  setMetadata(metadata\n  /*: any*/\n  ) {\n    if (metadata && typeof metadata === 'object') {\n      Object.keys(metadata).forEach(key => {\n        this.addMetadata(key, metadata[key]);\n      });\n    }\n  }\n  /**\n   * Sets metadata to be saved with file object. Adds to existing metadata.\n   *\n   * @param {string} key key to store the metadata\n   * @param {*} value metadata\n   */\n\n\n  addMetadata(key\n  /*: string*/\n  , value\n  /*: any*/\n  ) {\n    if (typeof key === 'string') {\n      this._metadata[key] = value;\n    }\n  }\n  /**\n   * Sets tags to be saved with file object. Overwrites existing tags\n   *\n   * @param {object} tags Key value pairs to be stored with file object\n   */\n\n\n  setTags(tags\n  /*: any*/\n  ) {\n    if (tags && typeof tags === 'object') {\n      Object.keys(tags).forEach(key => {\n        this.addTag(key, tags[key]);\n      });\n    }\n  }\n  /**\n   * Sets tags to be saved with file object. Adds to existing tags.\n   *\n   * @param {string} key key to store tags\n   * @param {*} value tag\n   */\n\n\n  addTag(key\n  /*: string*/\n  , value\n  /*: string*/\n  ) {\n    if (typeof key === 'string') {\n      this._tags[key] = value;\n    }\n  }\n\n  static fromJSON(obj)\n  /*: ParseFile*/\n  {\n    if (obj.__type !== 'File') {\n      throw new TypeError('JSON object does not represent a ParseFile');\n    }\n\n    const file = new ParseFile(obj.name);\n    file._url = obj.url;\n    file._hash = obj.hash;\n    file._ipfs = obj.ipfs;\n    return file;\n  }\n\n  static encodeBase64(bytes\n  /*: Array<number>*/\n  )\n  /*: string*/\n  {\n    return (0, _ParseFileEncode.encodeBase64)(bytes);\n  }\n\n}\n\n_CoreManager.default.setFileController(require('./ParseFileController.default'));\n\nvar _default = ParseFile;\nexports.default = _default;\nexports.b64Digit = _ParseFileEncode.b64Digit;","map":{"version":3,"sources":["S:/final hackathon/nfi3/node_modules/moralis/lib/node/ParseFile.js"],"names":["Object","defineProperty","exports","value","default","_CoreManager","_interopRequireDefault","require","_ParseFileEncode","obj","__esModule","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","ParseError","dataUriRegexp","ParseFile","constructor","name","data","type","metadata","tags","specifiedType","_name","_metadata","_tags","undefined","Array","isArray","_data","encodeBase64","_source","format","base64","Blob","file","uri","commaIndex","indexOf","matches","exec","slice","TypeError","getData","_url","Error","controller","getFileController","result","download","requestTask","task","_requestTask","url","options","forceSecure","replace","ipfs","_ipfs","hash","_hash","save","_previousSave","saveFile","then","res","newSource","contentType","saveBase64","saveIPFS","cancel","abort","destroy","FILE_DELETE_UNNAMED_ERROR","destroyOptions","useMasterKey","hasOwnProperty","deleteFile","toJSON","__type","equals","other","setMetadata","addMetadata","setTags","addTag","fromJSON","bytes","setFileController","_default","b64Digit"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _ParseFileEncode = require(\"./ParseFileEncode\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst ParseError = require('./ParseError').default;\n/*:: type Base64 = { base64: string };*/\n\n/*:: type Uri = { uri: string };*/\n\n/*:: type FileData = Array<number> | Base64 | Blob | Uri;*/\n\n/*:: export type FileSource =\n  | {\n      format: 'file',\n      file: Blob,\n      type: string,\n    }\n  | {\n      format: 'base64',\n      base64: string,\n      type: string,\n    }\n  | {\n      format: 'uri',\n      uri: string,\n      type: string,\n    };*/\n\n\nconst dataUriRegexp = /^data:([a-zA-Z]+\\/[-a-zA-Z0-9+.]+)(;charset=[a-zA-Z0-9\\-/]*)?;base64,/;\n/**\n * A Parse.File is a local representation of a file that is saved to the Parse\n * cloud.\n *\n * @alias Parse.File\n */\n\nclass ParseFile {\n  /**\n   * @param name {String} The file's name. This will be prefixed by a unique\n   *     value once the file has finished saving. The file name must begin with\n   *     an alphanumeric character, and consist of alphanumeric characters,\n   *     periods, spaces, underscores, or dashes.\n   * @param data {Array} The data for the file, as either:\n   *     1. an Array of byte value Numbers, or\n   *     2. an Object like { base64: \"...\" } with a base64-encoded String.\n   *     3. an Object like { uri: \"...\" } with a uri String.\n   *     4. a File object selected with a file upload control. (3) only works\n   *        in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.\n   *        For example:\n   * <pre>\n   * var fileUploadControl = $(\"#profilePhotoFileUpload\")[0];\n   * if (fileUploadControl.files.length > 0) {\n   *   var file = fileUploadControl.files[0];\n   *   var name = \"photo.jpg\";\n   *   var parseFile = new Parse.File(name, file);\n   *   parseFile.save().then(function() {\n   *     // The file has been saved to Parse.\n   *   }, function(error) {\n   *     // The file either could not be read, or could not be saved to Parse.\n   *   });\n   * }</pre>\n   * @param type {String} Optional Content-Type header to use for the file. If\n   *     this is omitted, the content type will be inferred from the name's\n   *     extension.\n   * @param metadata {Object} Optional key value pairs to be stored with file object\n   * @param tags {Object} Optional key value pairs to be stored with file object\n   */\n  constructor(name\n  /*: string*/\n  , data\n  /*:: ?: FileData*/\n  , type\n  /*:: ?: string*/\n  , metadata\n  /*:: ?: Object*/\n  , tags\n  /*:: ?: Object*/\n  ) {\n    _defineProperty(this, \"_name\", void 0);\n\n    _defineProperty(this, \"_url\", void 0);\n\n    _defineProperty(this, \"_hash\", void 0);\n\n    _defineProperty(this, \"_ipfs\", void 0);\n\n    _defineProperty(this, \"_source\", void 0);\n\n    _defineProperty(this, \"_previousSave\", void 0);\n\n    _defineProperty(this, \"_data\", void 0);\n\n    _defineProperty(this, \"_requestTask\", void 0);\n\n    _defineProperty(this, \"_metadata\", void 0);\n\n    _defineProperty(this, \"_tags\", void 0);\n\n    const specifiedType = type || '';\n    this._name = name;\n    this._metadata = metadata || {};\n    this._tags = tags || {};\n\n    if (data !== undefined) {\n      if (Array.isArray(data)) {\n        this._data = ParseFile.encodeBase64(data);\n        this._source = {\n          format: 'base64',\n          base64: this._data,\n          type: specifiedType\n        };\n      } else if (typeof Blob !== 'undefined' && data instanceof Blob) {\n        this._source = {\n          format: 'file',\n          file: data,\n          type: specifiedType\n        };\n      } else if (data && typeof data.uri === 'string' && data.uri !== undefined) {\n        this._source = {\n          format: 'uri',\n          uri: data.uri,\n          type: specifiedType\n        };\n      } else if (data && typeof data.base64 === 'string') {\n        const {\n          base64\n        } = data;\n        const commaIndex = base64.indexOf(',');\n\n        if (commaIndex !== -1) {\n          const matches = dataUriRegexp.exec(base64.slice(0, commaIndex + 1)); // if data URI with type and charset, there will be 4 matches.\n\n          this._data = base64.slice(commaIndex + 1);\n          this._source = {\n            format: 'base64',\n            base64: this._data,\n            type: matches[1]\n          };\n        } else {\n          this._data = base64;\n          this._source = {\n            format: 'base64',\n            base64: base64,\n            type: specifiedType\n          };\n        }\n      } else {\n        throw new TypeError('Cannot create a Parse.File with that data.');\n      }\n    }\n  }\n  /**\n   * Return the data for the file, downloading it if not already present.\n   * Data is present if initialized with Byte Array, Base64 or Saved with Uri.\n   * Data is cleared if saved with File object selected with a file upload control\n   *\n   * @returns {Promise} Promise that is resolve with base64 data\n   */\n\n\n  async getData()\n  /*: Promise<String>*/\n  {\n    if (this._data) {\n      return this._data;\n    }\n\n    if (!this._url) {\n      throw new Error('Cannot retrieve data for unsaved ParseFile.');\n    }\n\n    const controller = _CoreManager.default.getFileController();\n\n    const result = await controller.download(this._url, {\n      requestTask: task => this._requestTask = task\n    });\n    this._data = result.base64;\n    return this._data;\n  }\n  /**\n   * Gets the name of the file. Before save is called, this is the filename\n   * given by the user. After save is called, that name gets prefixed with a\n   * unique identifier.\n   *\n   * @returns {string}\n   */\n\n\n  name()\n  /*: string*/\n  {\n    return this._name;\n  }\n  /**\n   * Gets the url of the file. It is only available after you save the file or\n   * after you get the file from a Parse.Object.\n   *\n   * @param {object} options An object to specify url options\n   * @returns {string}\n   */\n\n\n  url(options\n  /*:: ?: { forceSecure?: boolean }*/\n  )\n  /*: ?string*/\n  {\n    options = options || {};\n\n    if (!this._url) {\n      return;\n    }\n\n    if (options.forceSecure) {\n      return this._url.replace(/^http:\\/\\//i, 'https://');\n    }\n\n    return this._url;\n  }\n\n  ipfs() {\n    return this._ipfs;\n  }\n\n  hash() {\n    return this._hash;\n  }\n  /**\n   * Gets the metadata of the file.\n   *\n   * @returns {object}\n   */\n\n\n  metadata()\n  /*: Object*/\n  {\n    return this._metadata;\n  }\n  /**\n   * Gets the tags of the file.\n   *\n   * @returns {object}\n   */\n\n\n  tags()\n  /*: Object*/\n  {\n    return this._tags;\n  }\n  /**\n   * Saves the file to the Parse cloud.\n   *\n   * @param {object} options\n   *  * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *     behalf of a specific user.\n   *   <li>progress: In Browser only, callback for upload progress. For example:\n   * <pre>\n   * let parseFile = new Parse.File(name, file);\n   * parseFile.save({\n   *   progress: (progressValue, loaded, total, { type }) => {\n   *     if (type === \"upload\" && progressValue !== null) {\n   *       // Update the UI using progressValue\n   *     }\n   *   }\n   * });\n   * </pre>\n   * </ul>\n   * @returns {Promise} Promise that is resolved when the save finishes.\n   */\n\n\n  save(options\n  /*:: ?: FullOptions*/\n  ) {\n    options = options || {};\n\n    options.requestTask = task => this._requestTask = task;\n\n    options.metadata = this._metadata;\n    options.tags = this._tags;\n\n    const controller = _CoreManager.default.getFileController();\n\n    if (!this._previousSave) {\n      if (this._source.format === 'file') {\n        this._previousSave = controller.saveFile(this._name, this._source, options).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._hash = res.hash;\n          this._ipfs = res.ipfs;\n          this._data = null;\n          this._requestTask = null;\n          return this;\n        });\n      } else if (this._source.format === 'uri') {\n        this._previousSave = controller.download(this._source.uri, options).then(result => {\n          if (!(result && result.base64)) {\n            return {};\n          }\n\n          const newSource = {\n            format: 'base64',\n            base64: result.base64,\n            type: result.contentType\n          };\n          this._data = result.base64;\n          this._requestTask = null;\n          return controller.saveBase64(this._name, newSource, options);\n        }).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._hash = res.hash;\n          this._ipfs = res.ipfs;\n          this._requestTask = null;\n          return this;\n        });\n      } else {\n        this._previousSave = controller.saveBase64(this._name, this._source, options).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._hash = res.hash;\n          this._ipfs = res.ipfs;\n          this._requestTask = null;\n          return this;\n        });\n      }\n    }\n\n    if (this._previousSave) {\n      return this._previousSave;\n    }\n  }\n\n  saveIPFS(options\n  /*:: ?: FullOptions*/\n  ) {\n    return this.save(_objectSpread(_objectSpread({}, options), {}, {\n      ipfs: true\n    }));\n  }\n  /**\n   * Aborts the request if it has already been sent.\n   */\n\n\n  cancel() {\n    if (this._requestTask && typeof this._requestTask.abort === 'function') {\n      this._requestTask.abort();\n    }\n\n    this._requestTask = null;\n  }\n  /**\n   * Deletes the file from the Parse cloud.\n   * In Cloud Code and Node only with Master Key.\n   *\n   * @param {object} options\n   *  * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   * <pre>\n   * @returns {Promise} Promise that is resolved when the delete finishes.\n   */\n\n\n  destroy(options\n  /*:: ?: FullOptions*/\n  = {}) {\n    if (!this._name) {\n      throw new ParseError(ParseError.FILE_DELETE_UNNAMED_ERROR, 'Cannot delete an unnamed file.');\n    }\n\n    const destroyOptions = {\n      useMasterKey: true\n    };\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      destroyOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getFileController();\n\n    return controller.deleteFile(this._name, destroyOptions).then(() => {\n      this._data = null;\n      this._requestTask = null;\n      return this;\n    });\n  }\n\n  toJSON()\n  /*: { name: ?string, url: ?string }*/\n  {\n    return {\n      __type: 'File',\n      name: this._name,\n      url: this._url,\n      ipfs: this._ipfs,\n      hash: this._hash\n    };\n  }\n\n  equals(other\n  /*: mixed*/\n  )\n  /*: boolean*/\n  {\n    if (this === other) {\n      return true;\n    } // Unsaved Files are never equal, since they will be saved to different URLs\n\n\n    return other instanceof ParseFile && this.name() === other.name() && this.url() === other.url() && typeof this.url() !== 'undefined';\n  }\n  /**\n   * Sets metadata to be saved with file object. Overwrites existing metadata\n   *\n   * @param {object} metadata Key value pairs to be stored with file object\n   */\n\n\n  setMetadata(metadata\n  /*: any*/\n  ) {\n    if (metadata && typeof metadata === 'object') {\n      Object.keys(metadata).forEach(key => {\n        this.addMetadata(key, metadata[key]);\n      });\n    }\n  }\n  /**\n   * Sets metadata to be saved with file object. Adds to existing metadata.\n   *\n   * @param {string} key key to store the metadata\n   * @param {*} value metadata\n   */\n\n\n  addMetadata(key\n  /*: string*/\n  , value\n  /*: any*/\n  ) {\n    if (typeof key === 'string') {\n      this._metadata[key] = value;\n    }\n  }\n  /**\n   * Sets tags to be saved with file object. Overwrites existing tags\n   *\n   * @param {object} tags Key value pairs to be stored with file object\n   */\n\n\n  setTags(tags\n  /*: any*/\n  ) {\n    if (tags && typeof tags === 'object') {\n      Object.keys(tags).forEach(key => {\n        this.addTag(key, tags[key]);\n      });\n    }\n  }\n  /**\n   * Sets tags to be saved with file object. Adds to existing tags.\n   *\n   * @param {string} key key to store tags\n   * @param {*} value tag\n   */\n\n\n  addTag(key\n  /*: string*/\n  , value\n  /*: string*/\n  ) {\n    if (typeof key === 'string') {\n      this._tags[key] = value;\n    }\n  }\n\n  static fromJSON(obj)\n  /*: ParseFile*/\n  {\n    if (obj.__type !== 'File') {\n      throw new TypeError('JSON object does not represent a ParseFile');\n    }\n\n    const file = new ParseFile(obj.name);\n    file._url = obj.url;\n    file._hash = obj.hash;\n    file._ipfs = obj.ipfs;\n    return file;\n  }\n\n  static encodeBase64(bytes\n  /*: Array<number>*/\n  )\n  /*: string*/\n  {\n    return (0, _ParseFileEncode.encodeBase64)(bytes);\n  }\n\n}\n\n_CoreManager.default.setFileController(require('./ParseFileController.default'));\n\nvar _default = ParseFile;\nexports.default = _default;\nexports.b64Digit = _ParseFileEncode.b64Digit;"]},"metadata":{},"sourceType":"script"}