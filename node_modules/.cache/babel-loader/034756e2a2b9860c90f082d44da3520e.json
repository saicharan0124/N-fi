{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _AnonymousUtils = _interopRequireDefault(require(\"./AnonymousUtils\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _isRevocableSession = _interopRequireDefault(require(\"./isRevocableSession\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseSession = _interopRequireDefault(require(\"./ParseSession\"));\n\nvar _MoralisWeb = _interopRequireDefault(require(\"./MoralisWeb3\"));\n\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nconst CURRENT_USER_KEY = 'currentUser';\nlet canUseCurrentUser = !_CoreManager.default.get('IS_NODE');\nlet currentUserCacheMatchesDisk = false;\nlet currentUserCache = null;\nconst authProviders = {};\n/**\n * <p>A Parse.User object is a local representation of a user persisted to the\n * Parse cloud. This class is a subclass of a Parse.Object, and retains the\n * same functionality of a Parse.Object, but also extends it with various\n * user specific methods, like authentication, signing up, and validation of\n * uniqueness.</p>\n *\n * @alias Parse.User\n * @augments Parse.Object\n */\n\nclass ParseUser extends _ParseObject.default {\n  /**\n   * @param {object} attributes The initial set of data to store in the user.\n   */\n  constructor(attributes\n  /*: ?AttributeMap*/\n  ) {\n    super('_User');\n\n    if (attributes && typeof attributes === 'object') {\n      if (!this.set(attributes || {})) {\n        throw new Error(\"Can't create an invalid Parse User\");\n      }\n    }\n  }\n  /**\n   * Request a revocable session token to replace the older style of token.\n   *\n   * @param {object} options\n   * @returns {Promise} A promise that is resolved when the replacement\n   *   token has been fetched.\n   */\n\n\n  _upgradeToRevocableSession(options\n  /*: RequestOptions*/\n  )\n  /*: Promise<void>*/\n  {\n    options = options || {};\n    const upgradeOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      upgradeOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.upgradeToRevocableSession(this, upgradeOptions);\n  }\n  /**\n   * Parse allows you to link your users with {@link https://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication 3rd party authentication}, enabling\n   * your users to sign up or log into your application using their existing identities.\n   * Since 2.9.0\n   *\n   * @see {@link https://docs.parseplatform.org/js/guide/#linking-users Linking Users}\n   * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @param {object} options\n   * <ul>\n   *   <li>If provider is string, options is {@link http://docs.parseplatform.org/parse-server/guide/#supported-3rd-party-authentications authData}\n   *   <li>If provider is AuthProvider, options is saveOpts\n   * </ul>\n   * @param {object} saveOpts useMasterKey / sessionToken\n   * @returns {Promise} A promise that is fulfilled with the user is linked\n   */\n\n\n  linkWith(provider\n  /*: any*/\n  , options\n  /*: { authData?: AuthData }*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    let saveOpts\n    /*:: ?: FullOptions*/\n    = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    saveOpts.sessionToken = saveOpts.sessionToken || this.getSessionToken() || '';\n    let authType;\n\n    if (typeof provider === 'string') {\n      authType = provider;\n\n      if (authProviders[provider]) {\n        provider = authProviders[provider];\n      } else {\n        const authProvider = {\n          restoreAuthentication() {\n            return true;\n          },\n\n          getAuthType() {\n            return authType;\n          }\n\n        };\n        authProviders[authProvider.getAuthType()] = authProvider;\n        provider = authProvider;\n      }\n    } else {\n      authType = provider.getAuthType();\n    }\n\n    if (options && options.hasOwnProperty('authData')) {\n      const authData = this.get('authData') || {};\n\n      if (typeof authData !== 'object') {\n        throw new Error('Invalid type: authData field should be an object');\n      }\n\n      authData[authType] = options.authData;\n\n      const controller = _CoreManager.default.getUserController();\n\n      return controller.linkWith(this, authData, saveOpts);\n    }\n\n    return new Promise((resolve, reject) => {\n      provider.authenticate({\n        success: (provider, result) => {\n          const opts = {};\n          opts.authData = result;\n          this.linkWith(provider, opts, saveOpts).then(() => {\n            resolve(this);\n          }, error => {\n            reject(error);\n          });\n        },\n        error: (provider, error) => {\n          reject(error);\n        }\n      });\n    });\n  }\n  /**\n   * @param provider\n   * @param options\n   * @param saveOpts\n   * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}\n   * @returns {Promise}\n   */\n\n\n  _linkWith(provider\n  /*: any*/\n  , options\n  /*: { authData?: AuthData }*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    let saveOpts\n    /*:: ?: FullOptions*/\n    = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.linkWith(provider, options, saveOpts);\n  }\n  /**\n   * Synchronizes auth data for a provider (e.g. puts the access token in the\n   * right place to be used by the Facebook SDK).\n   *\n   * @param provider\n   */\n\n\n  _synchronizeAuthData(provider\n  /*: string*/\n  ) {\n    if (!this.isCurrent() || !provider) {\n      return;\n    }\n\n    let authType;\n\n    if (typeof provider === 'string') {\n      authType = provider;\n      provider = authProviders[authType];\n    } else {\n      authType = provider.getAuthType();\n    }\n\n    const authData = this.get('authData');\n\n    if (!provider || !authData || typeof authData !== 'object') {\n      return;\n    }\n\n    const success = provider.restoreAuthentication(authData[authType]);\n\n    if (!success) {\n      this._unlinkFrom(provider);\n    }\n  }\n  /**\n   * Synchronizes authData for all providers.\n   */\n\n\n  _synchronizeAllAuthData() {\n    const authData = this.get('authData');\n\n    if (typeof authData !== 'object') {\n      return;\n    }\n\n    for (const key in authData) {\n      this._synchronizeAuthData(key);\n    }\n  }\n  /**\n   * Removes null values from authData (which exist temporarily for unlinking)\n   */\n\n\n  _cleanupAuthData() {\n    if (!this.isCurrent()) {\n      return;\n    }\n\n    const authData = this.get('authData');\n\n    if (typeof authData !== 'object') {\n      return;\n    }\n\n    for (const key in authData) {\n      if (!authData[key]) {\n        delete authData[key];\n      }\n    }\n  }\n  /**\n   * Unlinks a user from a service.\n   *\n   * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @param {object} options MasterKey / SessionToken\n   * @returns {Promise} A promise that is fulfilled when the unlinking\n   *     finishes.\n   */\n\n\n  _unlinkFrom(provider\n  /*: any*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    return this.linkWith(provider, {\n      authData: null\n    }, options).then(() => {\n      this._synchronizeAuthData(provider);\n\n      return Promise.resolve(this);\n    });\n  }\n  /**\n   * Checks whether a user is linked to a service.\n   *\n   * @param {object} provider service to link to\n   * @returns {boolean} true if link was successful\n   */\n\n\n  _isLinked(provider\n  /*: any*/\n  )\n  /*: boolean*/\n  {\n    let authType;\n\n    if (typeof provider === 'string') {\n      authType = provider;\n    } else {\n      authType = provider.getAuthType();\n    }\n\n    const authData = this.get('authData') || {};\n\n    if (typeof authData !== 'object') {\n      return false;\n    }\n\n    return !!authData[authType];\n  }\n  /**\n   * Deauthenticates all providers.\n   */\n\n\n  _logOutWithAll() {\n    const authData = this.get('authData');\n\n    if (typeof authData !== 'object') {\n      return;\n    }\n\n    for (const key in authData) {\n      this._logOutWith(key);\n    }\n  }\n  /**\n   * Deauthenticates a single provider (e.g. removing access tokens from the\n   * Facebook SDK).\n   *\n   * @param {object} provider service to logout of\n   */\n\n\n  _logOutWith(provider\n  /*: any*/\n  ) {\n    if (!this.isCurrent()) {\n      return;\n    }\n\n    if (typeof provider === 'string') {\n      provider = authProviders[provider];\n    }\n\n    if (provider && provider.deauthenticate) {\n      provider.deauthenticate();\n    }\n  }\n  /**\n   * Class instance method used to maintain specific keys when a fetch occurs.\n   * Used to ensure that the session token is not lost.\n   *\n   * @returns {object} sessionToken\n   */\n\n\n  _preserveFieldsOnFetch()\n  /*: AttributeMap*/\n  {\n    return {\n      sessionToken: this.get('sessionToken')\n    };\n  }\n  /**\n   * Returns true if <code>current</code> would return this user.\n   *\n   * @returns {boolean} true if user is cached on disk\n   */\n\n\n  isCurrent()\n  /*: boolean*/\n  {\n    const current = ParseUser.current();\n    return !!current && current.id === this.id;\n  }\n  /**\n   * Returns get(\"username\").\n   *\n   * @returns {string}\n   */\n\n\n  getUsername()\n  /*: ?string*/\n  {\n    const username = this.get('username');\n\n    if (username == null || typeof username === 'string') {\n      return username;\n    }\n\n    return '';\n  }\n  /**\n   * Calls set(\"username\", username, options) and returns the result.\n   *\n   * @param {string} username\n   */\n\n\n  setUsername(username\n  /*: string*/\n  ) {\n    // Strip anonymity, even we do not support anonymous user in js SDK, we may\n    // encounter anonymous user created by android/iOS in cloud code.\n    const authData = this.get('authData');\n\n    if (authData && typeof authData === 'object' && authData.hasOwnProperty('anonymous')) {\n      // We need to set anonymous to null instead of deleting it in order to remove it from Parse.\n      authData.anonymous = null;\n    }\n\n    this.set('username', username);\n  }\n  /**\n   * Calls set(\"password\", password, options) and returns the result.\n   *\n   * @param {string} password User's Password\n   */\n\n\n  setPassword(password\n  /*: string*/\n  ) {\n    this.set('password', password);\n  }\n  /**\n   * Returns get(\"email\").\n   *\n   * @returns {string} User's Email\n   */\n\n\n  getEmail()\n  /*: ?string*/\n  {\n    const email = this.get('email');\n\n    if (email == null || typeof email === 'string') {\n      return email;\n    }\n\n    return '';\n  }\n  /**\n   * Calls set(\"email\", email) and returns the result.\n   *\n   * @param {string} email\n   * @returns {boolean}\n   */\n\n\n  setEmail(email\n  /*: string*/\n  ) {\n    return this.set('email', email);\n  }\n  /**\n   * Returns the session token for this user, if the user has been logged in,\n   * or if it is the result of a query with the master key. Otherwise, returns\n   * undefined.\n   *\n   * @returns {string} the session token, or undefined\n   */\n\n\n  getSessionToken()\n  /*: ?string*/\n  {\n    const token = this.get('sessionToken');\n\n    if (token == null || typeof token === 'string') {\n      return token;\n    }\n\n    return '';\n  }\n  /**\n   * Checks whether this user is the current user and has been authenticated.\n   *\n   * @returns {boolean} whether this user is the current user and is logged in.\n   */\n\n\n  authenticated()\n  /*: boolean*/\n  {\n    const current = ParseUser.current();\n    return !!this.get('sessionToken') && !!current && current.id === this.id;\n  }\n  /**\n   * Signs up a new user. You should call this instead of save for\n   * new Parse.Users. This will create a new Parse.User on the server, and\n   * also persist the session on disk so that you can access the user using\n   * <code>current</code>.\n   *\n   * <p>A username and password must be set before calling signUp.</p>\n   *\n   * @param {object} attrs Extra fields to set on the new user, or null.\n   * @param {object} options\n   * @returns {Promise} A promise that is fulfilled when the signup\n   *     finishes.\n   */\n\n\n  signUp(attrs\n  /*: AttributeMap*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    options = options || {};\n    const signupOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      signupOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('installationId')) {\n      signupOptions.installationId = options.installationId;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.signUp(this, attrs, signupOptions);\n  }\n  /**\n   * Logs in a Parse.User. On success, this saves the session to disk,\n   * so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * <p>A username and password must be set before calling logIn.</p>\n   *\n   * @param {object} options\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login is complete.\n   */\n\n\n  logIn(options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    options = options || {};\n    const loginOptions = {\n      usePost: true\n    };\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      loginOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('installationId')) {\n      loginOptions.installationId = options.installationId;\n    }\n\n    if (options.hasOwnProperty('usePost')) {\n      loginOptions.usePost = options.usePost;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.logIn(this, loginOptions);\n  }\n  /**\n   * Wrap the default save behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Promise}\n   */\n\n\n  save()\n  /*: Promise<ParseUser>*/\n  {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return super.save.apply(this, args).then(() => {\n      if (this.isCurrent()) {\n        return _CoreManager.default.getUserController().updateUserOnDisk(this);\n      }\n\n      return this;\n    });\n  }\n  /**\n   * Wrap the default destroy behavior with functionality that logs out\n   * the current user when it is destroyed\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n\n\n  destroy()\n  /*: Promise<ParseUser>*/\n  {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return super.destroy.apply(this, args).then(() => {\n      if (this.isCurrent()) {\n        return _CoreManager.default.getUserController().removeUserFromDisk();\n      }\n\n      return this;\n    });\n  }\n  /**\n   * Wrap the default fetch behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n\n\n  fetch()\n  /*: Promise<ParseUser>*/\n  {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return super.fetch.apply(this, args).then(() => {\n      if (this.isCurrent()) {\n        return _CoreManager.default.getUserController().updateUserOnDisk(this);\n      }\n\n      return this;\n    });\n  }\n  /**\n   * Wrap the default fetchWithInclude behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n\n\n  fetchWithInclude()\n  /*: Promise<ParseUser>*/\n  {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    return super.fetchWithInclude.apply(this, args).then(() => {\n      if (this.isCurrent()) {\n        return _CoreManager.default.getUserController().updateUserOnDisk(this);\n      }\n\n      return this;\n    });\n  }\n  /**\n   * Verify whether a given password is the password of the current user.\n   *\n   * @param {string} password A password to be verified\n   * @param {object} options\n   * @returns {Promise} A promise that is fulfilled with a user\n   *  when the password is correct.\n   */\n\n\n  verifyPassword(password\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const username = this.getUsername() || '';\n    return ParseUser.verifyPassword(username, password, options);\n  }\n\n  static readOnlyAttributes() {\n    return ['sessionToken'];\n  }\n  /**\n   * Adds functionality to the existing Parse.User class.\n   *\n   * @param {object} protoProps A set of properties to add to the prototype\n   * @param {object} classProps A set of static properties to add to the class\n   * @static\n   * @returns {Parse.User} The newly extended Parse.User class\n   */\n\n\n  static extend(protoProps\n  /*: { [prop: string]: any }*/\n  , classProps\n  /*: { [prop: string]: any }*/\n  ) {\n    if (protoProps) {\n      for (const prop in protoProps) {\n        if (prop !== 'className') {\n          Object.defineProperty(ParseUser.prototype, prop, {\n            value: protoProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    if (classProps) {\n      for (const prop in classProps) {\n        if (prop !== 'className') {\n          Object.defineProperty(ParseUser, prop, {\n            value: classProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    return ParseUser;\n  }\n  /**\n   * Retrieves the currently logged in ParseUser with a valid session,\n   * either from memory or localStorage, if necessary.\n   *\n   * @static\n   * @returns {Parse.Object} The currently logged in Parse.User.\n   */\n\n\n  static current()\n  /*: ?ParseUser*/\n  {\n    if (!canUseCurrentUser) {\n      return null;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.currentUser();\n  }\n  /**\n   * Retrieves the currently logged in ParseUser from asynchronous Storage.\n   *\n   * @static\n   * @returns {Promise} A Promise that is resolved with the currently\n   *   logged in Parse User\n   */\n\n\n  static currentAsync()\n  /*: Promise<?ParseUser>*/\n  {\n    if (!canUseCurrentUser) {\n      return Promise.resolve(null);\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.currentUserAsync();\n  }\n  /**\n   * Signs up a new user with a username (or email) and password.\n   * This will create a new Parse.User on the server, and also persist the\n   * session in localStorage so that you can access the user using\n   * {@link #current}.\n   *\n   * @param {string} username The username (or email) to sign up with.\n   * @param {string} password The password to sign up with.\n   * @param {object} attrs Extra fields to set on the new user.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the signup completes.\n   */\n\n\n  static signUp(username\n  /*: string*/\n  , password\n  /*: string*/\n  , attrs\n  /*: AttributeMap*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    attrs = attrs || {};\n    attrs.username = username;\n    attrs.password = password;\n    const user = new this(attrs);\n    return user.signUp({}, options);\n  }\n  /**\n   * Logs in a user with a username (or email) and password. On success, this\n   * saves the session to disk, so you can retrieve the currently logged in\n   * user using <code>current</code>.\n   *\n   * @param {string} username The username (or email) to log in with.\n   * @param {string} password The password to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n\n\n  static logIn(username\n  /*: string*/\n  , password\n  /*: string*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    if (typeof username !== 'string') {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    }\n\n    if (typeof password !== 'string') {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n\n    const user = new this();\n\n    user._finishFetch({\n      username: username,\n      password: password\n    });\n\n    return user.logIn(options);\n  }\n\n  static loginOrSignup(username\n  /*: string*/\n  , password\n  /*: string*/\n  ) {\n    return this.logIn(username, password).catch(err => {\n      if (err.code === 101) {\n        const newUser = new this();\n        newUser.set('username', username);\n        newUser.set('password', password);\n        return newUser.signUp();\n      }\n\n      throw err;\n    });\n  }\n  /**\n   * Logs in a user with a session token. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * @param {string} sessionToken The sessionToken to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n\n\n  static become(sessionToken\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    if (!canUseCurrentUser) {\n      throw new Error('It is not memory-safe to become a user in a server environment');\n    }\n\n    options = options || {};\n    const becomeOptions\n    /*: RequestOptions*/\n    = {\n      sessionToken: sessionToken\n    };\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      becomeOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    const user = new this();\n    return controller.become(user, becomeOptions);\n  }\n  /**\n   * Retrieves a user with a session token.\n   *\n   * @param {string} sessionToken The sessionToken to get user with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user is fetched.\n   */\n\n\n  static me(sessionToken\n  /*: string*/\n  ) {\n    let options\n    /*:: ?: RequestOptions*/\n    = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const controller = _CoreManager.default.getUserController();\n\n    const meOptions\n    /*: RequestOptions*/\n    = {\n      sessionToken: sessionToken\n    };\n\n    if (options.useMasterKey) {\n      meOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const user = new this();\n    return controller.me(user, meOptions);\n  }\n  /**\n   * Logs in a user with a session token. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>. If there is no session token the user will not logged in.\n   *\n   * @param {object} userJSON The JSON map of the User's data\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n\n\n  static hydrate(userJSON\n  /*: AttributeMap*/\n  ) {\n    const controller = _CoreManager.default.getUserController();\n\n    const user = new this();\n    return controller.hydrate(user, userJSON);\n  }\n  /**\n   * Static version of {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}\n   *\n   * @param provider\n   * @param options\n   * @param saveOpts\n   * @static\n   * @returns {Promise}\n   */\n\n\n  static logInWith(provider\n  /*: any*/\n  , options\n  /*: { authData?: AuthData }*/\n  , saveOpts\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const user = new this();\n    return user.linkWith(provider, options, saveOpts);\n  }\n  /**\n   * Logs out the currently logged in user session. This will remove the\n   * session from disk, log out of linked services, and future calls to\n   * <code>current</code> will return <code>null</code>.\n   *\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is resolved when the session is\n   *   destroyed on the server.\n   */\n\n\n  static logOut() {\n    let options\n    /*: RequestOptions*/\n    = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.logOut(options);\n  }\n  /**\n   * Requests a password reset email to be sent to the specified email address\n   * associated with the user account. This email allows the user to securely\n   * reset their password on the Parse site.\n   *\n   * @param {string} email The email address associated with the user that\n   *     forgot their password.\n   * @param {object} options\n   * @static\n   * @returns {Promise}\n   */\n\n\n  static requestPasswordReset(email\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    options = options || {};\n    const requestOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      requestOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.requestPasswordReset(email, requestOptions);\n  }\n  /**\n   * Request an email verification.\n   *\n   * @param {string} email The email address associated with the user that\n   *     forgot their password.\n   * @param {object} options\n   * @static\n   * @returns {Promise}\n   */\n\n\n  static requestEmailVerification(email\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    options = options || {};\n    const requestOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      requestOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.requestEmailVerification(email, requestOptions);\n  }\n  /**\n   * Verify whether a given password is the password of the current user.\n   *\n   * @param {string} username  A username to be used for identificaiton\n   * @param {string} password A password to be verified\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with a user\n   *  when the password is correct.\n   */\n\n\n  static verifyPassword(username\n  /*: string*/\n  , password\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    if (typeof username !== 'string') {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    }\n\n    if (typeof password !== 'string') {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n\n    options = options || {};\n    const verificationOption = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      verificationOption.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.verifyPassword(username, password, verificationOption);\n  }\n  /**\n   * Allow someone to define a custom User class without className\n   * being rewritten to _User. The default behavior is to rewrite\n   * User to _User for legacy reasons. This allows developers to\n   * override that behavior.\n   *\n   * @param {boolean} isAllowed Whether or not to allow custom User class\n   * @static\n   */\n\n\n  static allowCustomUserClass(isAllowed\n  /*: boolean*/\n  ) {\n    _CoreManager.default.set('PERFORM_USER_REWRITE', !isAllowed);\n  }\n  /**\n   * Allows a legacy application to start using revocable sessions. If the\n   * current session token is not revocable, a request will be made for a new,\n   * revocable session.\n   * It is not necessary to call this method from cloud code unless you are\n   * handling user signup or login from the server side. In a cloud code call,\n   * this function will not attempt to upgrade the current token.\n   *\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is resolved when the process has\n   *   completed. If a replacement session token is requested, the promise\n   *   will be resolved after a new token has been fetched.\n   */\n\n\n  static enableRevocableSession(options\n  /*:: ?: RequestOptions*/\n  ) {\n    options = options || {};\n\n    _CoreManager.default.set('FORCE_REVOCABLE_SESSION', true);\n\n    if (canUseCurrentUser) {\n      const current = ParseUser.current();\n\n      if (current) {\n        return current._upgradeToRevocableSession(options);\n      }\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * Enables the use of become or the current user in a server\n   * environment. These features are disabled by default, since they depend on\n   * global objects that are not memory-safe for most servers.\n   *\n   * @static\n   */\n\n\n  static enableUnsafeCurrentUser() {\n    canUseCurrentUser = true;\n  }\n  /**\n   * Disables the use of become or the current user in any environment.\n   * These features are disabled on servers by default, since they depend on\n   * global objects that are not memory-safe for most servers.\n   *\n   * @static\n   */\n\n\n  static disableUnsafeCurrentUser() {\n    canUseCurrentUser = false;\n  }\n  /**\n   * When registering users with {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith} a basic auth provider\n   * is automatically created for you.\n   *\n   * For advanced authentication, you can register an Auth provider to\n   * implement custom authentication, deauthentication.\n   *\n   * @param provider\n   * @see {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @see {@link https://docs.parseplatform.org/js/guide/#custom-authentication-module Custom Authentication Module}\n   * @static\n   */\n\n\n  static _registerAuthenticationProvider(provider\n  /*: any*/\n  ) {\n    authProviders[provider.getAuthType()] = provider; // Synchronize the current user with the auth provider.\n\n    ParseUser.currentAsync().then(current => {\n      if (current) {\n        current._synchronizeAuthData(provider.getAuthType());\n      }\n    });\n  }\n  /**\n   * @param provider\n   * @param options\n   * @param saveOpts\n   * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#logInWith logInWith}\n   * @static\n   * @returns {Promise}\n   */\n\n\n  static _logInWith(provider\n  /*: any*/\n  , options\n  /*: { authData?: AuthData }*/\n  , saveOpts\n  /*:: ?: FullOptions*/\n  ) {\n    const user = new this();\n    return user.linkWith(provider, options, saveOpts);\n  }\n\n  static _clearCache() {\n    currentUserCache = null;\n    currentUserCacheMatchesDisk = false;\n  }\n\n  static _setCurrentUserCache(user\n  /*: ParseUser*/\n  ) {\n    currentUserCache = user;\n  }\n\n}\n\n_ParseObject.default.registerSubclass('_User', ParseUser);\n\nconst DefaultController = {\n  updateUserOnDisk(user) {\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    const json = user.toJSON();\n    delete json.password;\n    json.className = '_User';\n    let userData = JSON.stringify(json);\n\n    if (_CoreManager.default.get('ENCRYPTED_USER')) {\n      const crypto = _CoreManager.default.getCryptoController();\n\n      userData = crypto.encrypt(json, _CoreManager.default.get('ENCRYPTED_KEY'));\n    }\n\n    return _Storage.default.setItemAsync(path, userData).then(() => {\n      return user;\n    });\n  },\n\n  removeUserFromDisk() {\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    currentUserCacheMatchesDisk = true;\n    currentUserCache = null;\n    return _Storage.default.removeItemAsync(path);\n  },\n\n  async setCurrentUser(user) {\n    const currentUser = await this.currentUserAsync();\n\n    if (currentUser && !user.equals(currentUser) && _AnonymousUtils.default.isLinked(currentUser)) {\n      await currentUser.destroy({\n        sessionToken: currentUser.getSessionToken()\n      });\n    }\n\n    currentUserCache = user;\n\n    user._cleanupAuthData();\n\n    user._synchronizeAllAuthData();\n\n    return DefaultController.updateUserOnDisk(user);\n  },\n\n  currentUser()\n  /*: ?ParseUser*/\n  {\n    if (currentUserCache) {\n      return currentUserCache;\n    }\n\n    if (currentUserCacheMatchesDisk) {\n      return null;\n    }\n\n    if (_Storage.default.async()) {\n      throw new Error('Cannot call currentUser() when using a platform with an async ' + 'storage system. Call currentUserAsync() instead.');\n    }\n\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    let userData = _Storage.default.getItem(path);\n\n    currentUserCacheMatchesDisk = true;\n\n    if (!userData) {\n      currentUserCache = null;\n      return null;\n    }\n\n    if (_CoreManager.default.get('ENCRYPTED_USER')) {\n      const crypto = _CoreManager.default.getCryptoController();\n\n      userData = crypto.decrypt(userData, _CoreManager.default.get('ENCRYPTED_KEY'));\n    }\n\n    userData = JSON.parse(userData);\n\n    if (!userData.className) {\n      userData.className = '_User';\n    }\n\n    if (userData._id) {\n      if (userData.objectId !== userData._id) {\n        userData.objectId = userData._id;\n      }\n\n      delete userData._id;\n    }\n\n    if (userData._sessionToken) {\n      userData.sessionToken = userData._sessionToken;\n      delete userData._sessionToken;\n    }\n\n    const current = _ParseObject.default.fromJSON(userData);\n\n    currentUserCache = current;\n\n    current._synchronizeAllAuthData();\n\n    return current;\n  },\n\n  currentUserAsync()\n  /*: Promise<?ParseUser>*/\n  {\n    if (currentUserCache) {\n      return Promise.resolve(currentUserCache);\n    }\n\n    if (currentUserCacheMatchesDisk) {\n      return Promise.resolve(null);\n    }\n\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    return _Storage.default.getItemAsync(path).then(userData => {\n      currentUserCacheMatchesDisk = true;\n\n      if (!userData) {\n        currentUserCache = null;\n        return Promise.resolve(null);\n      }\n\n      if (_CoreManager.default.get('ENCRYPTED_USER')) {\n        const crypto = _CoreManager.default.getCryptoController();\n\n        userData = crypto.decrypt(userData.toString(), _CoreManager.default.get('ENCRYPTED_KEY'));\n      }\n\n      userData = JSON.parse(userData);\n\n      if (!userData.className) {\n        userData.className = '_User';\n      }\n\n      if (userData._id) {\n        if (userData.objectId !== userData._id) {\n          userData.objectId = userData._id;\n        }\n\n        delete userData._id;\n      }\n\n      if (userData._sessionToken) {\n        userData.sessionToken = userData._sessionToken;\n        delete userData._sessionToken;\n      }\n\n      const current = _ParseObject.default.fromJSON(userData);\n\n      currentUserCache = current;\n\n      current._synchronizeAllAuthData();\n\n      return Promise.resolve(current);\n    });\n  },\n\n  signUp(user\n  /*: ParseUser*/\n  , attrs\n  /*: AttributeMap*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const username = attrs && attrs.username || user.get('username');\n    const password = attrs && attrs.password || user.get('password');\n\n    if (!username || !username.length) {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty username.'));\n    }\n\n    if (!password || !password.length) {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty password.'));\n    }\n\n    return user.save(attrs, options).then(() => {\n      // Clear the password field\n      user._finishFetch({\n        password: undefined\n      });\n\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n\n      return user;\n    });\n  },\n\n  logIn(user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    const auth = {\n      username: user.get('username'),\n      password: user.get('password')\n    };\n    return RESTController.request(options.usePost ? 'POST' : 'GET', 'login', auth, options).then(response => {\n      user._migrateId(response.objectId);\n\n      user._setExisted(true);\n\n      stateController.setPendingOp(user._getStateIdentifier(), 'username', undefined);\n      stateController.setPendingOp(user._getStateIdentifier(), 'password', undefined);\n      response.password = undefined;\n\n      user._finishFetch(response);\n\n      if (!canUseCurrentUser) {\n        // We can't set the current user, so just return the one we logged in\n        return Promise.resolve(user);\n      }\n\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n\n  become(user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'users/me', {}, options).then(response => {\n      user._finishFetch(response);\n\n      user._setExisted(true);\n\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n\n  hydrate(user\n  /*: ParseUser*/\n  , userJSON\n  /*: AttributeMap*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    user._finishFetch(userJSON);\n\n    user._setExisted(true);\n\n    if (userJSON.sessionToken && canUseCurrentUser) {\n      return DefaultController.setCurrentUser(user);\n    }\n\n    return Promise.resolve(user);\n  },\n\n  me(user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'users/me', {}, options).then(response => {\n      user._finishFetch(response);\n\n      user._setExisted(true);\n\n      return user;\n    });\n  },\n\n  logOut(options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const Moralis = require('./Parse');\n\n    Moralis.cleanup();\n\n    const RESTController = _CoreManager.default.getRESTController();\n\n    if (options.sessionToken) {\n      return RESTController.request('POST', 'logout', {}, options);\n    }\n\n    return DefaultController.currentUserAsync().then(currentUser => {\n      const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n      let promise = _Storage.default.removeItemAsync(path);\n\n      if (currentUser !== null) {\n        const isAnonymous = _AnonymousUtils.default.isLinked(currentUser);\n\n        const currentSession = currentUser.getSessionToken();\n\n        if (currentSession && (0, _isRevocableSession.default)(currentSession)) {\n          promise = promise.then(() => {\n            if (isAnonymous) {\n              return currentUser.destroy({\n                sessionToken: currentSession\n              });\n            }\n          }).then(() => {\n            return RESTController.request('POST', 'logout', {}, {\n              sessionToken: currentSession\n            });\n          });\n        }\n\n        currentUser._logOutWithAll();\n\n        currentUser._finishFetch({\n          sessionToken: undefined\n        });\n\n        currentUser._clearServerData();\n      }\n\n      currentUserCacheMatchesDisk = true;\n      currentUserCache = null;\n      return promise;\n    });\n  },\n\n  requestPasswordReset(email\n  /*: string*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('POST', 'requestPasswordReset', {\n      email: email\n    }, options);\n  },\n\n  upgradeToRevocableSession(user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const token = user.getSessionToken();\n\n    if (!token) {\n      return Promise.reject(new _ParseError.default(_ParseError.default.SESSION_MISSING, 'Cannot upgrade a user with no session token'));\n    }\n\n    options.sessionToken = token;\n\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('POST', 'upgradeToRevocableSession', {}, options).then(result => {\n      const session = new _ParseSession.default();\n\n      session._finishFetch(result);\n\n      user._finishFetch({\n        sessionToken: session.getSessionToken()\n      });\n\n      if (user.isCurrent()) {\n        return DefaultController.setCurrentUser(user);\n      }\n\n      return Promise.resolve(user);\n    });\n  },\n\n  linkWith(user\n  /*: ParseUser*/\n  , authData\n  /*: AuthData*/\n  , options\n  /*: FullOptions*/\n  ) {\n    return user.save({\n      authData\n    }, options).then(() => {\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n\n      return user;\n    });\n  },\n\n  verifyPassword(username\n  /*: string*/\n  , password\n  /*: string*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'verifyPassword', {\n      username,\n      password\n    }, options);\n  },\n\n  requestEmailVerification(email\n  /*: string*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('POST', 'verificationEmailRequest', {\n      email: email\n    }, options);\n  }\n\n};\n\n_CoreManager.default.setUserController(DefaultController);\n\nvar _default = ParseUser;\nexports.default = _default;","map":{"version":3,"sources":["S:/final hackathon/nfi3/node_modules/moralis/lib/node/ParseUser.js"],"names":["Object","defineProperty","exports","value","default","_AnonymousUtils","_interopRequireDefault","require","_CoreManager","_isRevocableSession","_ParseError","_ParseObject","_ParseSession","_MoralisWeb","_Storage","obj","__esModule","CURRENT_USER_KEY","canUseCurrentUser","get","currentUserCacheMatchesDisk","currentUserCache","authProviders","ParseUser","constructor","attributes","set","Error","_upgradeToRevocableSession","options","upgradeOptions","hasOwnProperty","useMasterKey","controller","getUserController","upgradeToRevocableSession","linkWith","provider","saveOpts","sessionToken","getSessionToken","authType","authProvider","restoreAuthentication","getAuthType","authData","Promise","resolve","reject","authenticate","success","result","opts","then","error","_linkWith","_synchronizeAuthData","isCurrent","_unlinkFrom","_synchronizeAllAuthData","key","_cleanupAuthData","_isLinked","_logOutWithAll","_logOutWith","deauthenticate","_preserveFieldsOnFetch","current","id","getUsername","username","setUsername","anonymous","setPassword","password","getEmail","email","setEmail","token","authenticated","signUp","attrs","signupOptions","installationId","logIn","loginOptions","usePost","save","args","apply","updateUserOnDisk","destroy","removeUserFromDisk","fetch","fetchWithInclude","verifyPassword","readOnlyAttributes","extend","protoProps","classProps","prop","prototype","enumerable","writable","configurable","currentUser","currentAsync","currentUserAsync","user","OTHER_CAUSE","_finishFetch","loginOrSignup","catch","err","code","newUser","become","becomeOptions","me","meOptions","hydrate","userJSON","logInWith","logOut","requestPasswordReset","requestOptions","requestEmailVerification","verificationOption","allowCustomUserClass","isAllowed","enableRevocableSession","enableUnsafeCurrentUser","disableUnsafeCurrentUser","_registerAuthenticationProvider","_logInWith","_clearCache","_setCurrentUserCache","registerSubclass","DefaultController","path","generatePath","json","toJSON","className","userData","JSON","stringify","crypto","getCryptoController","encrypt","setItemAsync","removeItemAsync","setCurrentUser","equals","isLinked","async","getItem","decrypt","parse","_id","objectId","_sessionToken","fromJSON","getItemAsync","toString","length","undefined","RESTController","getRESTController","stateController","getObjectStateController","auth","request","response","_migrateId","_setExisted","setPendingOp","_getStateIdentifier","Moralis","cleanup","promise","isAnonymous","currentSession","_clearServerData","SESSION_MISSING","session","setUserController","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _AnonymousUtils = _interopRequireDefault(require(\"./AnonymousUtils\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _isRevocableSession = _interopRequireDefault(require(\"./isRevocableSession\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseSession = _interopRequireDefault(require(\"./ParseSession\"));\n\nvar _MoralisWeb = _interopRequireDefault(require(\"./MoralisWeb3\"));\n\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nconst CURRENT_USER_KEY = 'currentUser';\nlet canUseCurrentUser = !_CoreManager.default.get('IS_NODE');\nlet currentUserCacheMatchesDisk = false;\nlet currentUserCache = null;\nconst authProviders = {};\n/**\n * <p>A Parse.User object is a local representation of a user persisted to the\n * Parse cloud. This class is a subclass of a Parse.Object, and retains the\n * same functionality of a Parse.Object, but also extends it with various\n * user specific methods, like authentication, signing up, and validation of\n * uniqueness.</p>\n *\n * @alias Parse.User\n * @augments Parse.Object\n */\n\nclass ParseUser extends _ParseObject.default {\n  /**\n   * @param {object} attributes The initial set of data to store in the user.\n   */\n  constructor(attributes\n  /*: ?AttributeMap*/\n  ) {\n    super('_User');\n\n    if (attributes && typeof attributes === 'object') {\n      if (!this.set(attributes || {})) {\n        throw new Error(\"Can't create an invalid Parse User\");\n      }\n    }\n  }\n  /**\n   * Request a revocable session token to replace the older style of token.\n   *\n   * @param {object} options\n   * @returns {Promise} A promise that is resolved when the replacement\n   *   token has been fetched.\n   */\n\n\n  _upgradeToRevocableSession(options\n  /*: RequestOptions*/\n  )\n  /*: Promise<void>*/\n  {\n    options = options || {};\n    const upgradeOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      upgradeOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.upgradeToRevocableSession(this, upgradeOptions);\n  }\n  /**\n   * Parse allows you to link your users with {@link https://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication 3rd party authentication}, enabling\n   * your users to sign up or log into your application using their existing identities.\n   * Since 2.9.0\n   *\n   * @see {@link https://docs.parseplatform.org/js/guide/#linking-users Linking Users}\n   * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @param {object} options\n   * <ul>\n   *   <li>If provider is string, options is {@link http://docs.parseplatform.org/parse-server/guide/#supported-3rd-party-authentications authData}\n   *   <li>If provider is AuthProvider, options is saveOpts\n   * </ul>\n   * @param {object} saveOpts useMasterKey / sessionToken\n   * @returns {Promise} A promise that is fulfilled with the user is linked\n   */\n\n\n  linkWith(provider\n  /*: any*/\n  , options\n  /*: { authData?: AuthData }*/\n  , saveOpts\n  /*:: ?: FullOptions*/\n  = {})\n  /*: Promise<ParseUser>*/\n  {\n    saveOpts.sessionToken = saveOpts.sessionToken || this.getSessionToken() || '';\n    let authType;\n\n    if (typeof provider === 'string') {\n      authType = provider;\n\n      if (authProviders[provider]) {\n        provider = authProviders[provider];\n      } else {\n        const authProvider = {\n          restoreAuthentication() {\n            return true;\n          },\n\n          getAuthType() {\n            return authType;\n          }\n\n        };\n        authProviders[authProvider.getAuthType()] = authProvider;\n        provider = authProvider;\n      }\n    } else {\n      authType = provider.getAuthType();\n    }\n\n    if (options && options.hasOwnProperty('authData')) {\n      const authData = this.get('authData') || {};\n\n      if (typeof authData !== 'object') {\n        throw new Error('Invalid type: authData field should be an object');\n      }\n\n      authData[authType] = options.authData;\n\n      const controller = _CoreManager.default.getUserController();\n\n      return controller.linkWith(this, authData, saveOpts);\n    }\n\n    return new Promise((resolve, reject) => {\n      provider.authenticate({\n        success: (provider, result) => {\n          const opts = {};\n          opts.authData = result;\n          this.linkWith(provider, opts, saveOpts).then(() => {\n            resolve(this);\n          }, error => {\n            reject(error);\n          });\n        },\n        error: (provider, error) => {\n          reject(error);\n        }\n      });\n    });\n  }\n  /**\n   * @param provider\n   * @param options\n   * @param saveOpts\n   * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}\n   * @returns {Promise}\n   */\n\n\n  _linkWith(provider\n  /*: any*/\n  , options\n  /*: { authData?: AuthData }*/\n  , saveOpts\n  /*:: ?: FullOptions*/\n  = {})\n  /*: Promise<ParseUser>*/\n  {\n    return this.linkWith(provider, options, saveOpts);\n  }\n  /**\n   * Synchronizes auth data for a provider (e.g. puts the access token in the\n   * right place to be used by the Facebook SDK).\n   *\n   * @param provider\n   */\n\n\n  _synchronizeAuthData(provider\n  /*: string*/\n  ) {\n    if (!this.isCurrent() || !provider) {\n      return;\n    }\n\n    let authType;\n\n    if (typeof provider === 'string') {\n      authType = provider;\n      provider = authProviders[authType];\n    } else {\n      authType = provider.getAuthType();\n    }\n\n    const authData = this.get('authData');\n\n    if (!provider || !authData || typeof authData !== 'object') {\n      return;\n    }\n\n    const success = provider.restoreAuthentication(authData[authType]);\n\n    if (!success) {\n      this._unlinkFrom(provider);\n    }\n  }\n  /**\n   * Synchronizes authData for all providers.\n   */\n\n\n  _synchronizeAllAuthData() {\n    const authData = this.get('authData');\n\n    if (typeof authData !== 'object') {\n      return;\n    }\n\n    for (const key in authData) {\n      this._synchronizeAuthData(key);\n    }\n  }\n  /**\n   * Removes null values from authData (which exist temporarily for unlinking)\n   */\n\n\n  _cleanupAuthData() {\n    if (!this.isCurrent()) {\n      return;\n    }\n\n    const authData = this.get('authData');\n\n    if (typeof authData !== 'object') {\n      return;\n    }\n\n    for (const key in authData) {\n      if (!authData[key]) {\n        delete authData[key];\n      }\n    }\n  }\n  /**\n   * Unlinks a user from a service.\n   *\n   * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @param {object} options MasterKey / SessionToken\n   * @returns {Promise} A promise that is fulfilled when the unlinking\n   *     finishes.\n   */\n\n\n  _unlinkFrom(provider\n  /*: any*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    return this.linkWith(provider, {\n      authData: null\n    }, options).then(() => {\n      this._synchronizeAuthData(provider);\n\n      return Promise.resolve(this);\n    });\n  }\n  /**\n   * Checks whether a user is linked to a service.\n   *\n   * @param {object} provider service to link to\n   * @returns {boolean} true if link was successful\n   */\n\n\n  _isLinked(provider\n  /*: any*/\n  )\n  /*: boolean*/\n  {\n    let authType;\n\n    if (typeof provider === 'string') {\n      authType = provider;\n    } else {\n      authType = provider.getAuthType();\n    }\n\n    const authData = this.get('authData') || {};\n\n    if (typeof authData !== 'object') {\n      return false;\n    }\n\n    return !!authData[authType];\n  }\n  /**\n   * Deauthenticates all providers.\n   */\n\n\n  _logOutWithAll() {\n    const authData = this.get('authData');\n\n    if (typeof authData !== 'object') {\n      return;\n    }\n\n    for (const key in authData) {\n      this._logOutWith(key);\n    }\n  }\n  /**\n   * Deauthenticates a single provider (e.g. removing access tokens from the\n   * Facebook SDK).\n   *\n   * @param {object} provider service to logout of\n   */\n\n\n  _logOutWith(provider\n  /*: any*/\n  ) {\n    if (!this.isCurrent()) {\n      return;\n    }\n\n    if (typeof provider === 'string') {\n      provider = authProviders[provider];\n    }\n\n    if (provider && provider.deauthenticate) {\n      provider.deauthenticate();\n    }\n  }\n  /**\n   * Class instance method used to maintain specific keys when a fetch occurs.\n   * Used to ensure that the session token is not lost.\n   *\n   * @returns {object} sessionToken\n   */\n\n\n  _preserveFieldsOnFetch()\n  /*: AttributeMap*/\n  {\n    return {\n      sessionToken: this.get('sessionToken')\n    };\n  }\n  /**\n   * Returns true if <code>current</code> would return this user.\n   *\n   * @returns {boolean} true if user is cached on disk\n   */\n\n\n  isCurrent()\n  /*: boolean*/\n  {\n    const current = ParseUser.current();\n    return !!current && current.id === this.id;\n  }\n  /**\n   * Returns get(\"username\").\n   *\n   * @returns {string}\n   */\n\n\n  getUsername()\n  /*: ?string*/\n  {\n    const username = this.get('username');\n\n    if (username == null || typeof username === 'string') {\n      return username;\n    }\n\n    return '';\n  }\n  /**\n   * Calls set(\"username\", username, options) and returns the result.\n   *\n   * @param {string} username\n   */\n\n\n  setUsername(username\n  /*: string*/\n  ) {\n    // Strip anonymity, even we do not support anonymous user in js SDK, we may\n    // encounter anonymous user created by android/iOS in cloud code.\n    const authData = this.get('authData');\n\n    if (authData && typeof authData === 'object' && authData.hasOwnProperty('anonymous')) {\n      // We need to set anonymous to null instead of deleting it in order to remove it from Parse.\n      authData.anonymous = null;\n    }\n\n    this.set('username', username);\n  }\n  /**\n   * Calls set(\"password\", password, options) and returns the result.\n   *\n   * @param {string} password User's Password\n   */\n\n\n  setPassword(password\n  /*: string*/\n  ) {\n    this.set('password', password);\n  }\n  /**\n   * Returns get(\"email\").\n   *\n   * @returns {string} User's Email\n   */\n\n\n  getEmail()\n  /*: ?string*/\n  {\n    const email = this.get('email');\n\n    if (email == null || typeof email === 'string') {\n      return email;\n    }\n\n    return '';\n  }\n  /**\n   * Calls set(\"email\", email) and returns the result.\n   *\n   * @param {string} email\n   * @returns {boolean}\n   */\n\n\n  setEmail(email\n  /*: string*/\n  ) {\n    return this.set('email', email);\n  }\n  /**\n   * Returns the session token for this user, if the user has been logged in,\n   * or if it is the result of a query with the master key. Otherwise, returns\n   * undefined.\n   *\n   * @returns {string} the session token, or undefined\n   */\n\n\n  getSessionToken()\n  /*: ?string*/\n  {\n    const token = this.get('sessionToken');\n\n    if (token == null || typeof token === 'string') {\n      return token;\n    }\n\n    return '';\n  }\n  /**\n   * Checks whether this user is the current user and has been authenticated.\n   *\n   * @returns {boolean} whether this user is the current user and is logged in.\n   */\n\n\n  authenticated()\n  /*: boolean*/\n  {\n    const current = ParseUser.current();\n    return !!this.get('sessionToken') && !!current && current.id === this.id;\n  }\n  /**\n   * Signs up a new user. You should call this instead of save for\n   * new Parse.Users. This will create a new Parse.User on the server, and\n   * also persist the session on disk so that you can access the user using\n   * <code>current</code>.\n   *\n   * <p>A username and password must be set before calling signUp.</p>\n   *\n   * @param {object} attrs Extra fields to set on the new user, or null.\n   * @param {object} options\n   * @returns {Promise} A promise that is fulfilled when the signup\n   *     finishes.\n   */\n\n\n  signUp(attrs\n  /*: AttributeMap*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    options = options || {};\n    const signupOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      signupOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('installationId')) {\n      signupOptions.installationId = options.installationId;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.signUp(this, attrs, signupOptions);\n  }\n  /**\n   * Logs in a Parse.User. On success, this saves the session to disk,\n   * so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * <p>A username and password must be set before calling logIn.</p>\n   *\n   * @param {object} options\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login is complete.\n   */\n\n\n  logIn(options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    options = options || {};\n    const loginOptions = {\n      usePost: true\n    };\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      loginOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('installationId')) {\n      loginOptions.installationId = options.installationId;\n    }\n\n    if (options.hasOwnProperty('usePost')) {\n      loginOptions.usePost = options.usePost;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.logIn(this, loginOptions);\n  }\n  /**\n   * Wrap the default save behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Promise}\n   */\n\n\n  save(...args)\n  /*: Promise<ParseUser>*/\n  {\n    return super.save.apply(this, args).then(() => {\n      if (this.isCurrent()) {\n        return _CoreManager.default.getUserController().updateUserOnDisk(this);\n      }\n\n      return this;\n    });\n  }\n  /**\n   * Wrap the default destroy behavior with functionality that logs out\n   * the current user when it is destroyed\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n\n\n  destroy(...args)\n  /*: Promise<ParseUser>*/\n  {\n    return super.destroy.apply(this, args).then(() => {\n      if (this.isCurrent()) {\n        return _CoreManager.default.getUserController().removeUserFromDisk();\n      }\n\n      return this;\n    });\n  }\n  /**\n   * Wrap the default fetch behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n\n\n  fetch(...args)\n  /*: Promise<ParseUser>*/\n  {\n    return super.fetch.apply(this, args).then(() => {\n      if (this.isCurrent()) {\n        return _CoreManager.default.getUserController().updateUserOnDisk(this);\n      }\n\n      return this;\n    });\n  }\n  /**\n   * Wrap the default fetchWithInclude behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n\n\n  fetchWithInclude(...args)\n  /*: Promise<ParseUser>*/\n  {\n    return super.fetchWithInclude.apply(this, args).then(() => {\n      if (this.isCurrent()) {\n        return _CoreManager.default.getUserController().updateUserOnDisk(this);\n      }\n\n      return this;\n    });\n  }\n  /**\n   * Verify whether a given password is the password of the current user.\n   *\n   * @param {string} password A password to be verified\n   * @param {object} options\n   * @returns {Promise} A promise that is fulfilled with a user\n   *  when the password is correct.\n   */\n\n\n  verifyPassword(password\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const username = this.getUsername() || '';\n    return ParseUser.verifyPassword(username, password, options);\n  }\n\n  static readOnlyAttributes() {\n    return ['sessionToken'];\n  }\n  /**\n   * Adds functionality to the existing Parse.User class.\n   *\n   * @param {object} protoProps A set of properties to add to the prototype\n   * @param {object} classProps A set of static properties to add to the class\n   * @static\n   * @returns {Parse.User} The newly extended Parse.User class\n   */\n\n\n  static extend(protoProps\n  /*: { [prop: string]: any }*/\n  , classProps\n  /*: { [prop: string]: any }*/\n  ) {\n    if (protoProps) {\n      for (const prop in protoProps) {\n        if (prop !== 'className') {\n          Object.defineProperty(ParseUser.prototype, prop, {\n            value: protoProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    if (classProps) {\n      for (const prop in classProps) {\n        if (prop !== 'className') {\n          Object.defineProperty(ParseUser, prop, {\n            value: classProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    return ParseUser;\n  }\n  /**\n   * Retrieves the currently logged in ParseUser with a valid session,\n   * either from memory or localStorage, if necessary.\n   *\n   * @static\n   * @returns {Parse.Object} The currently logged in Parse.User.\n   */\n\n\n  static current()\n  /*: ?ParseUser*/\n  {\n    if (!canUseCurrentUser) {\n      return null;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.currentUser();\n  }\n  /**\n   * Retrieves the currently logged in ParseUser from asynchronous Storage.\n   *\n   * @static\n   * @returns {Promise} A Promise that is resolved with the currently\n   *   logged in Parse User\n   */\n\n\n  static currentAsync()\n  /*: Promise<?ParseUser>*/\n  {\n    if (!canUseCurrentUser) {\n      return Promise.resolve(null);\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.currentUserAsync();\n  }\n  /**\n   * Signs up a new user with a username (or email) and password.\n   * This will create a new Parse.User on the server, and also persist the\n   * session in localStorage so that you can access the user using\n   * {@link #current}.\n   *\n   * @param {string} username The username (or email) to sign up with.\n   * @param {string} password The password to sign up with.\n   * @param {object} attrs Extra fields to set on the new user.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the signup completes.\n   */\n\n\n  static signUp(username\n  /*: string*/\n  , password\n  /*: string*/\n  , attrs\n  /*: AttributeMap*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    attrs = attrs || {};\n    attrs.username = username;\n    attrs.password = password;\n    const user = new this(attrs);\n    return user.signUp({}, options);\n  }\n  /**\n   * Logs in a user with a username (or email) and password. On success, this\n   * saves the session to disk, so you can retrieve the currently logged in\n   * user using <code>current</code>.\n   *\n   * @param {string} username The username (or email) to log in with.\n   * @param {string} password The password to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n\n\n  static logIn(username\n  /*: string*/\n  , password\n  /*: string*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    if (typeof username !== 'string') {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    }\n\n    if (typeof password !== 'string') {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n\n    const user = new this();\n\n    user._finishFetch({\n      username: username,\n      password: password\n    });\n\n    return user.logIn(options);\n  }\n\n  static loginOrSignup(username\n  /*: string*/\n  , password\n  /*: string*/\n  ) {\n    return this.logIn(username, password).catch(err => {\n      if (err.code === 101) {\n        const newUser = new this();\n        newUser.set('username', username);\n        newUser.set('password', password);\n        return newUser.signUp();\n      }\n\n      throw err;\n    });\n  }\n  /**\n   * Logs in a user with a session token. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * @param {string} sessionToken The sessionToken to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n\n\n  static become(sessionToken\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    if (!canUseCurrentUser) {\n      throw new Error('It is not memory-safe to become a user in a server environment');\n    }\n\n    options = options || {};\n    const becomeOptions\n    /*: RequestOptions*/\n    = {\n      sessionToken: sessionToken\n    };\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      becomeOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    const user = new this();\n    return controller.become(user, becomeOptions);\n  }\n  /**\n   * Retrieves a user with a session token.\n   *\n   * @param {string} sessionToken The sessionToken to get user with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user is fetched.\n   */\n\n\n  static me(sessionToken\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  = {}) {\n    const controller = _CoreManager.default.getUserController();\n\n    const meOptions\n    /*: RequestOptions*/\n    = {\n      sessionToken: sessionToken\n    };\n\n    if (options.useMasterKey) {\n      meOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const user = new this();\n    return controller.me(user, meOptions);\n  }\n  /**\n   * Logs in a user with a session token. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>. If there is no session token the user will not logged in.\n   *\n   * @param {object} userJSON The JSON map of the User's data\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n\n\n  static hydrate(userJSON\n  /*: AttributeMap*/\n  ) {\n    const controller = _CoreManager.default.getUserController();\n\n    const user = new this();\n    return controller.hydrate(user, userJSON);\n  }\n  /**\n   * Static version of {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}\n   *\n   * @param provider\n   * @param options\n   * @param saveOpts\n   * @static\n   * @returns {Promise}\n   */\n\n\n  static logInWith(provider\n  /*: any*/\n  , options\n  /*: { authData?: AuthData }*/\n  , saveOpts\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const user = new this();\n    return user.linkWith(provider, options, saveOpts);\n  }\n  /**\n   * Logs out the currently logged in user session. This will remove the\n   * session from disk, log out of linked services, and future calls to\n   * <code>current</code> will return <code>null</code>.\n   *\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is resolved when the session is\n   *   destroyed on the server.\n   */\n\n\n  static logOut(options\n  /*: RequestOptions*/\n  = {}) {\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.logOut(options);\n  }\n  /**\n   * Requests a password reset email to be sent to the specified email address\n   * associated with the user account. This email allows the user to securely\n   * reset their password on the Parse site.\n   *\n   * @param {string} email The email address associated with the user that\n   *     forgot their password.\n   * @param {object} options\n   * @static\n   * @returns {Promise}\n   */\n\n\n  static requestPasswordReset(email\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    options = options || {};\n    const requestOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      requestOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.requestPasswordReset(email, requestOptions);\n  }\n  /**\n   * Request an email verification.\n   *\n   * @param {string} email The email address associated with the user that\n   *     forgot their password.\n   * @param {object} options\n   * @static\n   * @returns {Promise}\n   */\n\n\n  static requestEmailVerification(email\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    options = options || {};\n    const requestOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      requestOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.requestEmailVerification(email, requestOptions);\n  }\n  /**\n   * Verify whether a given password is the password of the current user.\n   *\n   * @param {string} username  A username to be used for identificaiton\n   * @param {string} password A password to be verified\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with a user\n   *  when the password is correct.\n   */\n\n\n  static verifyPassword(username\n  /*: string*/\n  , password\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    if (typeof username !== 'string') {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    }\n\n    if (typeof password !== 'string') {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n\n    options = options || {};\n    const verificationOption = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      verificationOption.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.verifyPassword(username, password, verificationOption);\n  }\n  /**\n   * Allow someone to define a custom User class without className\n   * being rewritten to _User. The default behavior is to rewrite\n   * User to _User for legacy reasons. This allows developers to\n   * override that behavior.\n   *\n   * @param {boolean} isAllowed Whether or not to allow custom User class\n   * @static\n   */\n\n\n  static allowCustomUserClass(isAllowed\n  /*: boolean*/\n  ) {\n    _CoreManager.default.set('PERFORM_USER_REWRITE', !isAllowed);\n  }\n  /**\n   * Allows a legacy application to start using revocable sessions. If the\n   * current session token is not revocable, a request will be made for a new,\n   * revocable session.\n   * It is not necessary to call this method from cloud code unless you are\n   * handling user signup or login from the server side. In a cloud code call,\n   * this function will not attempt to upgrade the current token.\n   *\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is resolved when the process has\n   *   completed. If a replacement session token is requested, the promise\n   *   will be resolved after a new token has been fetched.\n   */\n\n\n  static enableRevocableSession(options\n  /*:: ?: RequestOptions*/\n  ) {\n    options = options || {};\n\n    _CoreManager.default.set('FORCE_REVOCABLE_SESSION', true);\n\n    if (canUseCurrentUser) {\n      const current = ParseUser.current();\n\n      if (current) {\n        return current._upgradeToRevocableSession(options);\n      }\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * Enables the use of become or the current user in a server\n   * environment. These features are disabled by default, since they depend on\n   * global objects that are not memory-safe for most servers.\n   *\n   * @static\n   */\n\n\n  static enableUnsafeCurrentUser() {\n    canUseCurrentUser = true;\n  }\n  /**\n   * Disables the use of become or the current user in any environment.\n   * These features are disabled on servers by default, since they depend on\n   * global objects that are not memory-safe for most servers.\n   *\n   * @static\n   */\n\n\n  static disableUnsafeCurrentUser() {\n    canUseCurrentUser = false;\n  }\n  /**\n   * When registering users with {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith} a basic auth provider\n   * is automatically created for you.\n   *\n   * For advanced authentication, you can register an Auth provider to\n   * implement custom authentication, deauthentication.\n   *\n   * @param provider\n   * @see {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @see {@link https://docs.parseplatform.org/js/guide/#custom-authentication-module Custom Authentication Module}\n   * @static\n   */\n\n\n  static _registerAuthenticationProvider(provider\n  /*: any*/\n  ) {\n    authProviders[provider.getAuthType()] = provider; // Synchronize the current user with the auth provider.\n\n    ParseUser.currentAsync().then(current => {\n      if (current) {\n        current._synchronizeAuthData(provider.getAuthType());\n      }\n    });\n  }\n  /**\n   * @param provider\n   * @param options\n   * @param saveOpts\n   * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#logInWith logInWith}\n   * @static\n   * @returns {Promise}\n   */\n\n\n  static _logInWith(provider\n  /*: any*/\n  , options\n  /*: { authData?: AuthData }*/\n  , saveOpts\n  /*:: ?: FullOptions*/\n  ) {\n    const user = new this();\n    return user.linkWith(provider, options, saveOpts);\n  }\n\n  static _clearCache() {\n    currentUserCache = null;\n    currentUserCacheMatchesDisk = false;\n  }\n\n  static _setCurrentUserCache(user\n  /*: ParseUser*/\n  ) {\n    currentUserCache = user;\n  }\n\n}\n\n_ParseObject.default.registerSubclass('_User', ParseUser);\n\nconst DefaultController = {\n  updateUserOnDisk(user) {\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    const json = user.toJSON();\n    delete json.password;\n    json.className = '_User';\n    let userData = JSON.stringify(json);\n\n    if (_CoreManager.default.get('ENCRYPTED_USER')) {\n      const crypto = _CoreManager.default.getCryptoController();\n\n      userData = crypto.encrypt(json, _CoreManager.default.get('ENCRYPTED_KEY'));\n    }\n\n    return _Storage.default.setItemAsync(path, userData).then(() => {\n      return user;\n    });\n  },\n\n  removeUserFromDisk() {\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    currentUserCacheMatchesDisk = true;\n    currentUserCache = null;\n    return _Storage.default.removeItemAsync(path);\n  },\n\n  async setCurrentUser(user) {\n    const currentUser = await this.currentUserAsync();\n\n    if (currentUser && !user.equals(currentUser) && _AnonymousUtils.default.isLinked(currentUser)) {\n      await currentUser.destroy({\n        sessionToken: currentUser.getSessionToken()\n      });\n    }\n\n    currentUserCache = user;\n\n    user._cleanupAuthData();\n\n    user._synchronizeAllAuthData();\n\n    return DefaultController.updateUserOnDisk(user);\n  },\n\n  currentUser()\n  /*: ?ParseUser*/\n  {\n    if (currentUserCache) {\n      return currentUserCache;\n    }\n\n    if (currentUserCacheMatchesDisk) {\n      return null;\n    }\n\n    if (_Storage.default.async()) {\n      throw new Error('Cannot call currentUser() when using a platform with an async ' + 'storage system. Call currentUserAsync() instead.');\n    }\n\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    let userData = _Storage.default.getItem(path);\n\n    currentUserCacheMatchesDisk = true;\n\n    if (!userData) {\n      currentUserCache = null;\n      return null;\n    }\n\n    if (_CoreManager.default.get('ENCRYPTED_USER')) {\n      const crypto = _CoreManager.default.getCryptoController();\n\n      userData = crypto.decrypt(userData, _CoreManager.default.get('ENCRYPTED_KEY'));\n    }\n\n    userData = JSON.parse(userData);\n\n    if (!userData.className) {\n      userData.className = '_User';\n    }\n\n    if (userData._id) {\n      if (userData.objectId !== userData._id) {\n        userData.objectId = userData._id;\n      }\n\n      delete userData._id;\n    }\n\n    if (userData._sessionToken) {\n      userData.sessionToken = userData._sessionToken;\n      delete userData._sessionToken;\n    }\n\n    const current = _ParseObject.default.fromJSON(userData);\n\n    currentUserCache = current;\n\n    current._synchronizeAllAuthData();\n\n    return current;\n  },\n\n  currentUserAsync()\n  /*: Promise<?ParseUser>*/\n  {\n    if (currentUserCache) {\n      return Promise.resolve(currentUserCache);\n    }\n\n    if (currentUserCacheMatchesDisk) {\n      return Promise.resolve(null);\n    }\n\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    return _Storage.default.getItemAsync(path).then(userData => {\n      currentUserCacheMatchesDisk = true;\n\n      if (!userData) {\n        currentUserCache = null;\n        return Promise.resolve(null);\n      }\n\n      if (_CoreManager.default.get('ENCRYPTED_USER')) {\n        const crypto = _CoreManager.default.getCryptoController();\n\n        userData = crypto.decrypt(userData.toString(), _CoreManager.default.get('ENCRYPTED_KEY'));\n      }\n\n      userData = JSON.parse(userData);\n\n      if (!userData.className) {\n        userData.className = '_User';\n      }\n\n      if (userData._id) {\n        if (userData.objectId !== userData._id) {\n          userData.objectId = userData._id;\n        }\n\n        delete userData._id;\n      }\n\n      if (userData._sessionToken) {\n        userData.sessionToken = userData._sessionToken;\n        delete userData._sessionToken;\n      }\n\n      const current = _ParseObject.default.fromJSON(userData);\n\n      currentUserCache = current;\n\n      current._synchronizeAllAuthData();\n\n      return Promise.resolve(current);\n    });\n  },\n\n  signUp(user\n  /*: ParseUser*/\n  , attrs\n  /*: AttributeMap*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const username = attrs && attrs.username || user.get('username');\n    const password = attrs && attrs.password || user.get('password');\n\n    if (!username || !username.length) {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty username.'));\n    }\n\n    if (!password || !password.length) {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty password.'));\n    }\n\n    return user.save(attrs, options).then(() => {\n      // Clear the password field\n      user._finishFetch({\n        password: undefined\n      });\n\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n\n      return user;\n    });\n  },\n\n  logIn(user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    const auth = {\n      username: user.get('username'),\n      password: user.get('password')\n    };\n    return RESTController.request(options.usePost ? 'POST' : 'GET', 'login', auth, options).then(response => {\n      user._migrateId(response.objectId);\n\n      user._setExisted(true);\n\n      stateController.setPendingOp(user._getStateIdentifier(), 'username', undefined);\n      stateController.setPendingOp(user._getStateIdentifier(), 'password', undefined);\n      response.password = undefined;\n\n      user._finishFetch(response);\n\n      if (!canUseCurrentUser) {\n        // We can't set the current user, so just return the one we logged in\n        return Promise.resolve(user);\n      }\n\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n\n  become(user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'users/me', {}, options).then(response => {\n      user._finishFetch(response);\n\n      user._setExisted(true);\n\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n\n  hydrate(user\n  /*: ParseUser*/\n  , userJSON\n  /*: AttributeMap*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    user._finishFetch(userJSON);\n\n    user._setExisted(true);\n\n    if (userJSON.sessionToken && canUseCurrentUser) {\n      return DefaultController.setCurrentUser(user);\n    }\n\n    return Promise.resolve(user);\n  },\n\n  me(user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'users/me', {}, options).then(response => {\n      user._finishFetch(response);\n\n      user._setExisted(true);\n\n      return user;\n    });\n  },\n\n  logOut(options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const Moralis = require('./Parse');\n\n    Moralis.cleanup();\n\n    const RESTController = _CoreManager.default.getRESTController();\n\n    if (options.sessionToken) {\n      return RESTController.request('POST', 'logout', {}, options);\n    }\n\n    return DefaultController.currentUserAsync().then(currentUser => {\n      const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n      let promise = _Storage.default.removeItemAsync(path);\n\n      if (currentUser !== null) {\n        const isAnonymous = _AnonymousUtils.default.isLinked(currentUser);\n\n        const currentSession = currentUser.getSessionToken();\n\n        if (currentSession && (0, _isRevocableSession.default)(currentSession)) {\n          promise = promise.then(() => {\n            if (isAnonymous) {\n              return currentUser.destroy({\n                sessionToken: currentSession\n              });\n            }\n          }).then(() => {\n            return RESTController.request('POST', 'logout', {}, {\n              sessionToken: currentSession\n            });\n          });\n        }\n\n        currentUser._logOutWithAll();\n\n        currentUser._finishFetch({\n          sessionToken: undefined\n        });\n\n        currentUser._clearServerData();\n      }\n\n      currentUserCacheMatchesDisk = true;\n      currentUserCache = null;\n      return promise;\n    });\n  },\n\n  requestPasswordReset(email\n  /*: string*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('POST', 'requestPasswordReset', {\n      email: email\n    }, options);\n  },\n\n  upgradeToRevocableSession(user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const token = user.getSessionToken();\n\n    if (!token) {\n      return Promise.reject(new _ParseError.default(_ParseError.default.SESSION_MISSING, 'Cannot upgrade a user with no session token'));\n    }\n\n    options.sessionToken = token;\n\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('POST', 'upgradeToRevocableSession', {}, options).then(result => {\n      const session = new _ParseSession.default();\n\n      session._finishFetch(result);\n\n      user._finishFetch({\n        sessionToken: session.getSessionToken()\n      });\n\n      if (user.isCurrent()) {\n        return DefaultController.setCurrentUser(user);\n      }\n\n      return Promise.resolve(user);\n    });\n  },\n\n  linkWith(user\n  /*: ParseUser*/\n  , authData\n  /*: AuthData*/\n  , options\n  /*: FullOptions*/\n  ) {\n    return user.save({\n      authData\n    }, options).then(() => {\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n\n      return user;\n    });\n  },\n\n  verifyPassword(username\n  /*: string*/\n  , password\n  /*: string*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'verifyPassword', {\n      username,\n      password\n    }, options);\n  },\n\n  requestEmailVerification(email\n  /*: string*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('POST', 'verificationEmailRequest', {\n      email: email\n    }, options);\n  }\n\n};\n\n_CoreManager.default.setUserController(DefaultController);\n\nvar _default = ParseUser;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}