{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _promiseUtils = require(\"./promiseUtils\");\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _OfflineQuery = _interopRequireDefault(require(\"./OfflineQuery\"));\n\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Converts a string into a regex that matches it.\n * Surrounding with \\Q .. \\E does this, we just need to escape any \\E's in\n * the text separately.\n *\n * @param s\n * @private\n * @returns {string}\n */\n\n\nfunction quote(s\n/*: string*/\n)\n/*: string*/\n{\n  return `\\\\Q${s.replace('\\\\E', '\\\\E\\\\\\\\E\\\\Q')}\\\\E`;\n}\n/**\n * Extracts the class name from queries. If not all queries have the same\n * class name an error will be thrown.\n *\n * @param queries\n * @private\n * @returns {string}\n */\n\n\nfunction _getClassNameFromQueries(queries\n/*: Array<ParseQuery>*/\n)\n/*: ?string*/\n{\n  let className = null;\n  queries.forEach(q => {\n    if (!className) {\n      // eslint-disable-next-line prefer-destructuring\n      className = q.className;\n    }\n\n    if (className !== q.className) {\n      throw new Error('All queries must be for the same class.');\n    }\n  });\n  return className;\n}\n/*\n * Handles pre-populating the result data of a query with select fields,\n * making sure that the data object contains keys for all objects that have\n * been requested with a select, so that our cached state updates correctly.\n */\n\n\nfunction handleSelectResult(data\n/*: any*/\n, select\n/*: Array<string>*/\n) {\n  const serverDataMask = {};\n  select.forEach(field => {\n    const hasSubObjectSelect = field.indexOf('.') !== -1;\n\n    if (!hasSubObjectSelect && !data.hasOwnProperty(field)) {\n      // this field was selected, but is missing from the retrieved data\n      data[field] = undefined;\n    } else if (hasSubObjectSelect) {\n      // this field references a sub-object,\n      // so we need to walk down the path components\n      const pathComponents = field.split('.');\n      let obj = data;\n      let serverMask = serverDataMask;\n      pathComponents.forEach((component, index, arr) => {\n        // add keys if the expected data is missing\n        if (obj && !obj.hasOwnProperty(component)) {\n          obj[component] = undefined;\n        }\n\n        if (obj && typeof obj === 'object') {\n          obj = obj[component];\n        } // add this path component to the server mask so we can fill it in later if needed\n\n\n        if (index < arr.length - 1) {\n          if (!serverMask[component]) {\n            serverMask[component] = {};\n          }\n\n          serverMask = serverMask[component];\n        }\n      });\n    }\n  });\n\n  if (Object.keys(serverDataMask).length > 0) {\n    // When selecting from sub-objects, we don't want to blow away the missing\n    // information that we may have retrieved before. We've already added any\n    // missing selected keys to sub-objects, but we still need to add in the\n    // data for any previously retrieved sub-objects that were not selected.\n    const serverData = _CoreManager.default.getObjectStateController().getServerData({\n      id: data.objectId,\n      className: data.className\n    });\n\n    copyMissingDataWithMask(serverData, data, serverDataMask, false);\n  }\n}\n\nfunction copyMissingDataWithMask(src, dest, mask, copyThisLevel) {\n  // copy missing elements at this level\n  if (copyThisLevel) {\n    for (const key in src) {\n      if (src.hasOwnProperty(key) && !dest.hasOwnProperty(key)) {\n        dest[key] = src[key];\n      }\n    }\n  }\n\n  for (const key in mask) {\n    if (dest[key] !== undefined && dest[key] !== null && src !== undefined && src !== null) {\n      // traverse into objects as needed\n      copyMissingDataWithMask(src[key], dest[key], mask[key], true);\n    }\n  }\n}\n\nfunction handleOfflineSort(a, b, sorts) {\n  let order = sorts[0];\n  const operator = order.slice(0, 1);\n  const isDescending = operator === '-';\n\n  if (isDescending) {\n    order = order.substring(1);\n  }\n\n  if (order === '_created_at') {\n    order = 'createdAt';\n  }\n\n  if (order === '_updated_at') {\n    order = 'updatedAt';\n  }\n\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(order) || order === 'password') {\n    throw new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, `Invalid Key: ${order}`);\n  }\n\n  const field1 = a.get(order);\n  const field2 = b.get(order);\n\n  if (field1 < field2) {\n    return isDescending ? 1 : -1;\n  }\n\n  if (field1 > field2) {\n    return isDescending ? -1 : 1;\n  }\n\n  if (sorts.length > 1) {\n    const remainingSorts = sorts.slice(1);\n    return handleOfflineSort(a, b, remainingSorts);\n  }\n\n  return 0;\n}\n/**\n * Creates a new parse Parse.Query for the given Parse.Object subclass.\n *\n * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\n * most common use case is finding all objects that match a query through the\n * <code>find</code> method. for example, this sample code fetches all objects\n * of class <code>myclass</code>. it calls a different function depending on\n * whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.find().then((results) => {\n *   // results is an array of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to retrieve a single object whose id is\n * known, through the get method. for example, this sample code fetches an\n * object of class <code>myclass</code> and id <code>myid</code>. it calls a\n * different function depending on whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.get(myid).then((object) => {\n *     // object is an instance of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to count the number of objects that match\n * the query without retrieving all of those objects. for example, this\n * sample code counts the number of objects of the class <code>myclass</code>\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.count().then((number) => {\n *     // there are number instances of myclass.\n * }).catch((error) => {\n *     // error is an instance of Parse.Error.\n * });</pre></p>\n *\n * @alias Parse.Query\n */\n\n\nclass ParseQuery {\n  /**\n   * @property {string} className\n   */\n\n  /**\n   * @param {(string | Parse.Object)} objectClass An instance of a subclass of Parse.Object, or a Parse className string.\n   */\n  constructor(objectClass\n  /*: string | ParseObject*/\n  ) {\n    _defineProperty(this, \"className\", void 0);\n\n    _defineProperty(this, \"_where\", void 0);\n\n    _defineProperty(this, \"_include\", void 0);\n\n    _defineProperty(this, \"_exclude\", void 0);\n\n    _defineProperty(this, \"_select\", void 0);\n\n    _defineProperty(this, \"_limit\", void 0);\n\n    _defineProperty(this, \"_skip\", void 0);\n\n    _defineProperty(this, \"_count\", void 0);\n\n    _defineProperty(this, \"_order\", void 0);\n\n    _defineProperty(this, \"_readPreference\", void 0);\n\n    _defineProperty(this, \"_includeReadPreference\", void 0);\n\n    _defineProperty(this, \"_subqueryReadPreference\", void 0);\n\n    _defineProperty(this, \"_queriesLocalDatastore\", void 0);\n\n    _defineProperty(this, \"_localDatastorePinName\", void 0);\n\n    _defineProperty(this, \"_extraOptions\", void 0);\n\n    _defineProperty(this, \"_hint\", void 0);\n\n    _defineProperty(this, \"_explain\", void 0);\n\n    _defineProperty(this, \"_xhrRequest\", void 0);\n\n    if (typeof objectClass === 'string') {\n      if (objectClass === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = objectClass;\n      }\n    } else if (objectClass instanceof _ParseObject.default) {\n      this.className = objectClass.className;\n    } else if (typeof objectClass === 'function') {\n      if (typeof objectClass.className === 'string') {\n        this.className = objectClass.className;\n      } else {\n        const obj = new objectClass();\n        this.className = obj.className;\n      }\n    } else {\n      throw new TypeError('A ParseQuery must be constructed with a ParseObject or class name.');\n    }\n\n    this._where = {};\n    this._include = [];\n    this._exclude = [];\n    this._count = false; // negative limit is not sent in the server request\n\n    this._limit = -1;\n    this._skip = 0;\n    this._readPreference = null;\n    this._includeReadPreference = null;\n    this._subqueryReadPreference = null;\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    this._extraOptions = {};\n    this._xhrRequest = {\n      task: null,\n      onchange: () => {}\n    };\n  }\n  /**\n   * Adds constraint that at least one of the passed in queries matches.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  _orQuery(queries\n  /*: Array<ParseQuery>*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = queries.map(q => {\n      return q.toJSON().where;\n    });\n    this._where.$or = queryJSON;\n    return this;\n  }\n  /**\n   * Adds constraint that all of the passed in queries match.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  _andQuery(queries\n  /*: Array<ParseQuery>*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = queries.map(q => {\n      return q.toJSON().where;\n    });\n    this._where.$and = queryJSON;\n    return this;\n  }\n  /**\n   * Adds constraint that none of the passed in queries match.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  _norQuery(queries\n  /*: Array<ParseQuery>*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = queries.map(q => {\n      return q.toJSON().where;\n    });\n    this._where.$nor = queryJSON;\n    return this;\n  }\n  /**\n   * Helper for condition queries\n   *\n   * @param key\n   * @param condition\n   * @param value\n   * @returns {Parse.Query}\n   */\n\n\n  _addCondition(key\n  /*: string*/\n  , condition\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    if (!this._where[key] || typeof this._where[key] === 'string') {\n      this._where[key] = {};\n    }\n\n    this._where[key][condition] = (0, _encode.default)(value, false, true);\n    return this;\n  }\n  /**\n   * Converts string for regular expression at the beginning\n   *\n   * @param string\n   * @returns {string}\n   */\n\n\n  _regexStartWith(string\n  /*: string*/\n  )\n  /*: string*/\n  {\n    return `^${quote(string)}`;\n  }\n\n  async _handleOfflineQuery(params\n  /*: any*/\n  ) {\n    _OfflineQuery.default.validateQuery(this);\n\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    const objects = await localDatastore._serializeObjectsFromPinName(this._localDatastorePinName);\n    let results = objects.map((json, index, arr) => {\n      const object = _ParseObject.default.fromJSON(json, false);\n\n      if (json._localId && !json.objectId) {\n        object._localId = json._localId;\n      }\n\n      if (!_OfflineQuery.default.matchesQuery(this.className, object, arr, this)) {\n        return null;\n      }\n\n      return object;\n    }).filter(object => object !== null);\n\n    if (params.keys) {\n      let keys = params.keys.split(',');\n      keys = keys.concat(['className', 'objectId', 'createdAt', 'updatedAt', 'ACL']);\n      results = results.map(object => {\n        const json = object._toFullJSON();\n\n        Object.keys(json).forEach(key => {\n          if (!keys.includes(key)) {\n            delete json[key];\n          }\n        });\n        return _ParseObject.default.fromJSON(json, false);\n      });\n    }\n\n    if (params.order) {\n      const sorts = params.order.split(',');\n      results.sort((a, b) => {\n        return handleOfflineSort(a, b, sorts);\n      });\n    } // count total before applying limit/skip\n\n\n    let count;\n\n    if (params.count) {\n      // total count from response\n      count = results.length;\n    }\n\n    if (params.skip) {\n      if (params.skip >= results.length) {\n        results = [];\n      } else {\n        results = results.splice(params.skip, results.length);\n      }\n    }\n\n    let limit = results.length;\n\n    if (params.limit !== 0 && params.limit < results.length) {\n      // eslint-disable-next-line prefer-destructuring\n      limit = params.limit;\n    }\n\n    results = results.splice(0, limit);\n\n    if (typeof count === 'number') {\n      return {\n        results,\n        count\n      };\n    }\n\n    return results;\n  }\n  /**\n   * Returns a JSON representation of this query.\n   *\n   * @returns {object} The JSON representation of the query.\n   */\n\n\n  toJSON()\n  /*: QueryJSON*/\n  {\n    const params\n    /*: QueryJSON*/\n    = {\n      where: this._where\n    };\n\n    if (this._include.length) {\n      params.include = this._include.join(',');\n    }\n\n    if (this._exclude.length) {\n      params.excludeKeys = this._exclude.join(',');\n    }\n\n    if (this._select) {\n      params.keys = this._select.join(',');\n    }\n\n    if (this._count) {\n      params.count = 1;\n    }\n\n    if (this._limit >= 0) {\n      params.limit = this._limit;\n    }\n\n    if (this._skip > 0) {\n      params.skip = this._skip;\n    }\n\n    if (this._order) {\n      params.order = this._order.join(',');\n    }\n\n    if (this._readPreference) {\n      params.readPreference = this._readPreference;\n    }\n\n    if (this._includeReadPreference) {\n      params.includeReadPreference = this._includeReadPreference;\n    }\n\n    if (this._subqueryReadPreference) {\n      params.subqueryReadPreference = this._subqueryReadPreference;\n    }\n\n    if (this._hint) {\n      params.hint = this._hint;\n    }\n\n    if (this._explain) {\n      params.explain = true;\n    }\n\n    for (const key in this._extraOptions) {\n      params[key] = this._extraOptions[key];\n    }\n\n    return params;\n  }\n  /**\n   * Return a query with conditions from json, can be useful to send query from server side to client\n   * Not static, all query conditions was set before calling this method will be deleted.\n   * For example on the server side we have\n   * var query = new Parse.Query(\"className\");\n   * query.equalTo(key: value);\n   * query.limit(100);\n   * ... (others queries)\n   * Create JSON representation of Query Object\n   * var jsonFromServer = query.fromJSON();\n   *\n   * On client side getting query:\n   * var query = new Parse.Query(\"className\");\n   * query.fromJSON(jsonFromServer);\n   *\n   * and continue to query...\n   * query.skip(100).find().then(...);\n   *\n   * @param {QueryJSON} json from Parse.Query.toJSON() method\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withJSON(json\n  /*: QueryJSON*/\n  )\n  /*: ParseQuery*/\n  {\n    if (json.where) {\n      this._where = json.where;\n    }\n\n    if (json.include) {\n      this._include = json.include.split(',');\n    }\n\n    if (json.keys) {\n      this._select = json.keys.split(',');\n    }\n\n    if (json.excludeKeys) {\n      this._exclude = json.excludeKeys.split(',');\n    }\n\n    if (json.count) {\n      this._count = json.count === 1;\n    }\n\n    if (json.limit) {\n      this._limit = json.limit;\n    }\n\n    if (json.skip) {\n      this._skip = json.skip;\n    }\n\n    if (json.order) {\n      this._order = json.order.split(',');\n    }\n\n    if (json.readPreference) {\n      this._readPreference = json.readPreference;\n    }\n\n    if (json.includeReadPreference) {\n      this._includeReadPreference = json.includeReadPreference;\n    }\n\n    if (json.subqueryReadPreference) {\n      this._subqueryReadPreference = json.subqueryReadPreference;\n    }\n\n    if (json.hint) {\n      this._hint = json.hint;\n    }\n\n    if (json.explain) {\n      this._explain = !!json.explain;\n    }\n\n    for (const key in json) {\n      if (json.hasOwnProperty(key)) {\n        if (['where', 'include', 'keys', 'count', 'limit', 'skip', 'order', 'readPreference', 'includeReadPreference', 'subqueryReadPreference', 'hint', 'explain'].indexOf(key) === -1) {\n          this._extraOptions[key] = json[key];\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Static method to restore Parse.Query by json representation\n   * Internally calling Parse.Query.withJSON\n   *\n   * @param {string} className\n   * @param {QueryJSON} json from Parse.Query.toJSON() method\n   * @returns {Parse.Query} new created query\n   */\n\n\n  static fromJSON(className\n  /*: string*/\n  , json\n  /*: QueryJSON*/\n  )\n  /*: ParseQuery*/\n  {\n    const query = new ParseQuery(className);\n    return query.withJSON(json);\n  }\n  /**\n   * Constructs a Parse.Object whose id is already known by fetching data from\n   * the server. Unlike the <code>first</code> method, it never returns undefined.\n   *\n   * @param {string} objectId The id of the object to be fetched.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  get(objectId\n  /*: string*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseObject>*/\n  {\n    this.equalTo('objectId', objectId);\n    const firstOptions = {};\n\n    if (options && options.hasOwnProperty('useMasterKey')) {\n      firstOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options && options.hasOwnProperty('sessionToken')) {\n      firstOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options && options.hasOwnProperty('context') && typeof options.context === 'object') {\n      firstOptions.context = options.context;\n    }\n\n    return this.first(firstOptions).then(response => {\n      if (response) {\n        return response;\n      }\n\n      const errorObject = new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'Object not found.');\n      return Promise.reject(errorObject);\n    });\n  }\n  /**\n   * Retrieves a list of ParseObjects that satisfy this query.\n   *\n   * @param {object} options Valid options\n   * are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the results when\n   * the query completes.\n   */\n\n\n  find(options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    options = options || {};\n    const findOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n\n    this._setRequestTask(findOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    const select = this._select;\n\n    if (this._queriesLocalDatastore) {\n      return this._handleOfflineQuery(this.toJSON());\n    }\n\n    return controller.find(this.className, this.toJSON(), findOptions).then(response => {\n      // Return generic object when explain is used\n      if (this._explain) {\n        return response.results;\n      }\n\n      const results = response.results.map(data => {\n        // In cases of relations, the server may send back a className\n        // on the top level of the payload\n        const override = response.className || this.className;\n\n        if (!data.className) {\n          data.className = override;\n        } // Make sure the data object contains keys for all objects that\n        // have been requested with a select, so that our cached state\n        // updates correctly.\n\n\n        if (select) {\n          handleSelectResult(data, select);\n        }\n\n        return _ParseObject.default.fromJSON(data, !select);\n      });\n      const {\n        count\n      } = response;\n\n      if (typeof count === 'number') {\n        return {\n          results,\n          count\n        };\n      }\n\n      return results;\n    });\n  }\n  /**\n   * Retrieves a complete list of ParseObjects that satisfy this query.\n   * Using `eachBatch` under the hood to fetch all the valid objects.\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>batchSize: How many objects to yield in each batch (default: 100)\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the results when\n   * the query completes.\n   */\n\n\n  async findAll(options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    let result\n    /*: ParseObject[]*/\n    = [];\n    await this.eachBatch((objects\n    /*: ParseObject[]*/\n    ) => {\n      result = [...result, ...objects];\n    }, options);\n    return result;\n  }\n  /**\n   * Counts the number of objects that match this query.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the count when\n   * the query completes.\n   */\n\n\n  count(options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<number>*/\n  {\n    options = options || {};\n    const findOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n\n    this._setRequestTask(findOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    const params = this.toJSON();\n    params.limit = 0;\n    params.count = 1;\n    return controller.find(this.className, params, findOptions).then(result => {\n      return result.count;\n    });\n  }\n  /**\n   * Executes a distinct query and returns unique values\n   *\n   * @param {string} key A field to find distinct values\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the query completes.\n   */\n\n\n  distinct(key\n  /*: string*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<Array<mixed>>*/\n  {\n    options = options || {};\n    const distinctOptions = {};\n    distinctOptions.useMasterKey = true;\n\n    if (options.hasOwnProperty('sessionToken')) {\n      distinctOptions.sessionToken = options.sessionToken;\n    }\n\n    this._setRequestTask(distinctOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    const params = {\n      distinct: key,\n      where: this._where,\n      hint: this._hint\n    };\n    return controller.aggregate(this.className, params, distinctOptions).then(results => {\n      return results.results;\n    });\n  }\n  /**\n   * Executes an aggregate query and returns aggregate results\n   *\n   * @param {(Array|object)} pipeline Array or Object of stages to process query\n   * @param {object} options Valid options are:<ul>\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the query completes.\n   */\n\n\n  aggregate(pipeline\n  /*: mixed*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<Array<mixed>>*/\n  {\n    options = options || {};\n    const aggregateOptions = {};\n    aggregateOptions.useMasterKey = true;\n\n    if (options.hasOwnProperty('sessionToken')) {\n      aggregateOptions.sessionToken = options.sessionToken;\n    }\n\n    this._setRequestTask(aggregateOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    if (!Array.isArray(pipeline) && typeof pipeline !== 'object') {\n      throw new Error('Invalid pipeline must be Array or Object');\n    }\n\n    if (Object.keys(this._where || {}).length) {\n      if (!Array.isArray(pipeline)) {\n        pipeline = [pipeline];\n      }\n\n      pipeline.unshift({\n        match: this._where\n      });\n    }\n\n    const params = {\n      pipeline,\n      hint: this._hint,\n      explain: this._explain,\n      readPreference: this._readPreference\n    };\n    return controller.aggregate(this.className, params, aggregateOptions).then(results => {\n      return results.results;\n    });\n  }\n  /**\n   * Retrieves at most one Parse.Object that satisfies this query.\n   *\n   * Returns the object if there is one, otherwise undefined.\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the object when\n   * the query completes.\n   */\n\n\n  first(options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseObject | void>*/\n  {\n    options = options || {};\n    const findOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n\n    this._setRequestTask(findOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    const params = this.toJSON();\n    params.limit = 1;\n    const select = this._select;\n\n    if (this._queriesLocalDatastore) {\n      return this._handleOfflineQuery(params).then(objects => {\n        if (!objects[0]) {\n          return undefined;\n        }\n\n        return objects[0];\n      });\n    }\n\n    return controller.find(this.className, params, findOptions).then(response => {\n      const objects = response.results;\n\n      if (!objects[0]) {\n        return undefined;\n      }\n\n      if (!objects[0].className) {\n        objects[0].className = this.className;\n      } // Make sure the data object contains keys for all objects that\n      // have been requested with a select, so that our cached state\n      // updates correctly.\n\n\n      if (select) {\n        handleSelectResult(objects[0], select);\n      }\n\n      return _ParseObject.default.fromJSON(objects[0], !select);\n    });\n  }\n  /**\n   * Iterates over objects matching a query, calling a callback for each batch.\n   * If the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are processed\n   * in an unspecified order. The query may not have any sort order, and may\n   * not use limit or skip.\n   *\n   * @param {Function} callback Callback that will be called with each result\n   *     of the query.\n   * @param {object} options Valid options are:<ul>\n   *   <li>batchSize: How many objects to yield in each batch (default: 100)\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  eachBatch(callback\n  /*: (objs: Array<ParseObject>) => Promise<*>*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<void>*/\n  {\n    options = options || {};\n\n    if (this._order || this._skip || this._limit >= 0) {\n      return Promise.reject('Cannot iterate on a query with sort, skip, or limit.');\n    }\n\n    const query = new ParseQuery(this.className);\n    query._limit = options.batchSize || 100;\n    query._include = this._include.map(i => {\n      return i;\n    });\n\n    if (this._select) {\n      query._select = this._select.map(s => {\n        return s;\n      });\n    }\n\n    query._hint = this._hint;\n    query._where = {};\n\n    for (const attr in this._where) {\n      const val = this._where[attr];\n\n      if (Array.isArray(val)) {\n        query._where[attr] = val.map(v => {\n          return v;\n        });\n      } else if (val && typeof val === 'object') {\n        const conditionMap = {};\n        query._where[attr] = conditionMap;\n\n        for (const cond in val) {\n          conditionMap[cond] = val[cond];\n        }\n      } else {\n        query._where[attr] = val;\n      }\n    }\n\n    query.ascending('objectId');\n    const findOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n\n    let finished = false;\n    let previousResults = [];\n    return (0, _promiseUtils.continueWhile)(() => {\n      return !finished;\n    }, async () => {\n      const [results] = await Promise.all([query.find(findOptions), Promise.resolve(previousResults.length > 0 && callback(previousResults))]);\n\n      if (results.length >= query._limit) {\n        query.greaterThan('objectId', results[results.length - 1].id);\n        previousResults = results;\n      } else if (results.length > 0) {\n        await Promise.resolve(callback(results));\n        finished = true;\n      } else {\n        finished = true;\n      }\n    });\n  }\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback that will be called with each result\n   *     of the query.\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  each(callback\n  /*: (obj: ParseObject) => any*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<void>*/\n  {\n    return this.eachBatch(results => {\n      let callbacksDone = Promise.resolve();\n      results.forEach(result => {\n        callbacksDone = callbacksDone.then(() => {\n          return callback(result);\n        });\n      });\n      return callbacksDone;\n    }, options);\n  }\n  /**\n   * Adds a hint to force index selection. (https://docs.mongodb.com/manual/reference/operator/meta/hint/)\n   *\n   * @param {(string|object)} value String or Object of index that should be used when executing query\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  hint(value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof value === 'undefined') {\n      delete this._hint;\n    }\n\n    this._hint = value;\n    return this;\n  }\n  /**\n   * Investigates the query execution plan. Useful for optimizing queries. (https://docs.mongodb.com/manual/reference/operator/meta/explain/)\n   *\n   * @param {boolean} explain Used to toggle the information on the query plan.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  explain()\n  /*: ParseQuery*/\n  {\n    let explain\n    /*: boolean*/\n    = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    if (typeof explain !== 'boolean') {\n      throw new Error('You can only set explain to a boolean value');\n    }\n\n    this._explain = explain;\n    return this;\n  }\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   *   <li>query: The query map was called upon.</li>\n   * </ul>\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  async map(callback\n  /*: (currentObject: ParseObject, index: number, query: ParseQuery) => any*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<Array<any>>*/\n  {\n    const array = [];\n    let index = 0;\n    await this.each(object => {\n      return Promise.resolve(callback(object, index, this)).then(result => {\n        array.push(result);\n        index += 1;\n      });\n    }, options);\n    return array;\n  }\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>accumulator: The accumulator accumulates the callback's return values. It is the accumulated value previously returned in the last invocation of the callback.</li>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   * </ul>\n   * @param {*} initialValue A value to use as the first argument to the first call of the callback. If no initialValue is supplied, the first object in the query will be used and skipped.\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  async reduce(callback\n  /*: (accumulator: any, currentObject: ParseObject, index: number) => any*/\n  , initialValue\n  /*: any*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<Array<any>>*/\n  {\n    let accumulator = initialValue;\n    let index = 0;\n    await this.each(object => {\n      // If no initial value was given, we take the first object from the query\n      // as the initial value and don't call the callback with it.\n      if (index === 0 && initialValue === undefined) {\n        accumulator = object;\n        index += 1;\n        return;\n      }\n\n      return Promise.resolve(callback(accumulator, object, index)).then(result => {\n        accumulator = result;\n        index += 1;\n      });\n    }, options);\n\n    if (index === 0 && initialValue === undefined) {\n      // Match Array.reduce behavior: \"Calling reduce() on an empty array\n      // without an initialValue will throw a TypeError\".\n      throw new TypeError('Reducing empty query result set with no initial value');\n    }\n\n    return accumulator;\n  }\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   *   <li>query: The query filter was called upon.</li>\n   * </ul>\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  async filter(callback\n  /*: (currentObject: ParseObject, index: number, query: ParseQuery) => boolean*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    const array = [];\n    let index = 0;\n    await this.each(object => {\n      return Promise.resolve(callback(object, index, this)).then(flag => {\n        if (flag) {\n          array.push(object);\n        }\n\n        index += 1;\n      });\n    }, options);\n    return array;\n  }\n  /** Query Conditions * */\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that the Parse.Object must contain.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  equalTo(key\n  /*: string | { [key: string]: any }*/\n  , value\n  /*: ?mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    if (key && typeof key === 'object') {\n      Object.entries(key).forEach(_ref => {\n        let [k, val] = _ref;\n        return this.equalTo(k, val);\n      });\n      return this;\n    }\n\n    if (typeof value === 'undefined') {\n      return this.doesNotExist(key);\n    }\n\n    this._where[key] = (0, _encode.default)(value, false, true);\n    return this;\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be not equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that must not be equalled.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  notEqualTo(key\n  /*: string | { [key: string]: any }*/\n  , value\n  /*: ?mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    if (key && typeof key === 'object') {\n      Object.entries(key).forEach(_ref2 => {\n        let [k, val] = _ref2;\n        return this.notEqualTo(k, val);\n      });\n      return this;\n    }\n\n    return this._addCondition(key, '$ne', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be less than the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an upper bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  lessThan(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$lt', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be greater than the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an lower bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  greaterThan(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$gt', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be less than or equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an upper bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  lessThanOrEqualTo(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$lte', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be greater than or equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param {*} value The value that provides an lower bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  greaterThanOrEqualTo(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$gte', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be contained in the provided list of values.\n   *\n   * @param {string} key The key to check.\n   * @param {*} value The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  containedIn(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$in', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * not be contained in the provided list of values.\n   *\n   * @param {string} key The key to check.\n   * @param {*} value The values that will not match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  notContainedIn(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$nin', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be contained by the provided list of values. Get objects where all array elements match.\n   *\n   * @param {string} key The key to check.\n   * @param {Array} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  containedBy(key\n  /*: string*/\n  , values\n  /*: Array<mixed>*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$containedBy', values);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * contain each one of the provided list of values.\n   *\n   * @param {string} key The key to check.  This key's value must be an array.\n   * @param {Array} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  containsAll(key\n  /*: string*/\n  , values\n  /*: Array<mixed>*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$all', values);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * contain each one of the provided list of values starting with given strings.\n   *\n   * @param {string} key The key to check.  This key's value must be an array.\n   * @param {Array<string>} values The string values that will match as starting string.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  containsAllStartingWith(key\n  /*: string*/\n  , values\n  /*: Array<string>*/\n  )\n  /*: ParseQuery*/\n  {\n    const _this = this;\n\n    if (!Array.isArray(values)) {\n      values = [values];\n    }\n\n    const regexObject = values.map(value => {\n      return {\n        $regex: _this._regexStartWith(value)\n      };\n    });\n    return this.containsAll(key, regexObject);\n  }\n  /**\n   * Adds a constraint for finding objects that contain the given key.\n   *\n   * @param {string} key The key that should exist.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  exists(key\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$exists', true);\n  }\n  /**\n   * Adds a constraint for finding objects that do not contain a given key.\n   *\n   * @param {string} key The key that should not exist\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  doesNotExist(key\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$exists', false);\n  }\n  /**\n   * Adds a regular expression constraint for finding string values that match\n   * the provided regular expression.\n   * This may be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {RegExp} regex The regular expression pattern to match.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  matches(key\n  /*: string*/\n  , regex\n  /*: RegExp*/\n  , modifiers\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    this._addCondition(key, '$regex', regex);\n\n    if (!modifiers) {\n      modifiers = '';\n    }\n\n    if (regex.ignoreCase) {\n      modifiers += 'i';\n    }\n\n    if (regex.multiline) {\n      modifiers += 'm';\n    }\n\n    if (modifiers.length) {\n      this._addCondition(key, '$options', modifiers);\n    }\n\n    return this;\n  }\n  /**\n   * Adds a constraint that requires that a key's value matches a Parse.Query\n   * constraint.\n   *\n   * @param {string} key The key that the contains the object to match the\n   *                     query.\n   * @param {Parse.Query} query The query that should match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  matchesQuery(key\n  /*: string*/\n  , query\n  /*: ParseQuery*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$inQuery', queryJSON);\n  }\n  /**\n   * Adds a constraint that requires that a key's value not matches a\n   * Parse.Query constraint.\n   *\n   * @param {string} key The key that the contains the object to match the\n   *                     query.\n   * @param {Parse.Query} query The query that should not match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  doesNotMatchQuery(key\n  /*: string*/\n  , query\n  /*: ParseQuery*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$notInQuery', queryJSON);\n  }\n  /**\n   * Adds a constraint that requires that a key's value matches a value in\n   * an object returned by a different Parse.Query.\n   *\n   * @param {string} key The key that contains the value that is being\n   *                     matched.\n   * @param {string} queryKey The key in the objects returned by the query to\n   *                          match against.\n   * @param {Parse.Query} query The query to run.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  matchesKeyInQuery(key\n  /*: string*/\n  , queryKey\n  /*: string*/\n  , query\n  /*: ParseQuery*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$select', {\n      key: queryKey,\n      query: queryJSON\n    });\n  }\n  /**\n   * Adds a constraint that requires that a key's value not match a value in\n   * an object returned by a different Parse.Query.\n   *\n   * @param {string} key The key that contains the value that is being\n   *                     excluded.\n   * @param {string} queryKey The key in the objects returned by the query to\n   *                          match against.\n   * @param {Parse.Query} query The query to run.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  doesNotMatchKeyInQuery(key\n  /*: string*/\n  , queryKey\n  /*: string*/\n  , query\n  /*: ParseQuery*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$dontSelect', {\n      key: queryKey,\n      query: queryJSON\n    });\n  }\n  /**\n   * Adds a constraint for finding string values that contain a provided\n   * string.  This may be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} substring The substring that the value must contain.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  contains(key\n  /*: string*/\n  , substring\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof substring !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n\n    return this._addCondition(key, '$regex', quote(substring));\n  }\n  /**\n   * Adds a constraint for finding string values that contain a provided\n   * string. This may be slow for large datasets. Requires Parse-Server > 2.5.0\n   *\n   * In order to sort you must use select and ascending ($score is required)\n   *  <pre>\n   *   query.fullText('field', 'term');\n   *   query.ascending('$score');\n   *   query.select('$score');\n   *  </pre>\n   *\n   * To retrieve the weight / rank\n   *  <pre>\n   *   object->get('score');\n   *  </pre>\n   *\n   * You can define optionals by providing an object as a third parameter\n   *  <pre>\n   *   query.fullText('field', 'term', { language: 'es', diacriticSensitive: true });\n   *  </pre>\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} value The string to search\n   * @param {object} options (Optional)\n   * @param {string} options.language The language that determines the list of stop words for the search and the rules for the stemmer and tokenizer.\n   * @param {boolean} options.caseSensitive A boolean flag to enable or disable case sensitive search.\n   * @param {boolean} options.diacriticSensitive A boolean flag to enable or disable diacritic sensitive search.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fullText(key\n  /*: string*/\n  , value\n  /*: string*/\n  , options\n  /*: ?Object*/\n  )\n  /*: ParseQuery*/\n  {\n    options = options || {};\n\n    if (!key) {\n      throw new Error('A key is required.');\n    }\n\n    if (!value) {\n      throw new Error('A search term is required');\n    }\n\n    if (typeof value !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n\n    const fullOptions = {};\n    fullOptions.$term = value;\n\n    for (const option in options) {\n      switch (option) {\n        case 'language':\n          fullOptions.$language = options[option];\n          break;\n\n        case 'caseSensitive':\n          fullOptions.$caseSensitive = options[option];\n          break;\n\n        case 'diacriticSensitive':\n          fullOptions.$diacriticSensitive = options[option];\n          break;\n\n        default:\n          throw new Error(`Unknown option: ${option}`);\n      }\n    }\n\n    return this._addCondition(key, '$text', {\n      $search: fullOptions\n    });\n  }\n  /**\n   * Method to sort the full text search by text score\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  sortByTextScore() {\n    this.ascending('$score');\n    this.select(['$score']);\n    return this;\n  }\n  /**\n   * Adds a constraint for finding string values that start with a provided\n   * string.  This query will use the backend index, so it will be fast even\n   * for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} prefix The substring that the value must start with.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  startsWith(key\n  /*: string*/\n  , prefix\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof prefix !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n\n    return this._addCondition(key, '$regex', this._regexStartWith(prefix));\n  }\n  /**\n   * Adds a constraint for finding string values that end with a provided\n   * string.  This will be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} suffix The substring that the value must end with.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  endsWith(key\n  /*: string*/\n  , suffix\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof suffix !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n\n    return this._addCondition(key, '$regex', `${quote(suffix)}$`);\n  }\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  near(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  )\n  /*: ParseQuery*/\n  {\n    if (!(point instanceof _ParseGeoPoint.default)) {\n      // Try to cast it as a GeoPoint\n      point = new _ParseGeoPoint.default(point);\n    }\n\n    return this._addCondition(key, '$nearSphere', point);\n  }\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in radians) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinRadians(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  , maxDistance\n  /*: number*/\n  , sorted\n  /*: boolean*/\n  )\n  /*: ParseQuery*/\n  {\n    if (sorted || sorted === undefined) {\n      this.near(key, point);\n      return this._addCondition(key, '$maxDistance', maxDistance);\n    }\n\n    return this._addCondition(key, '$geoWithin', {\n      $centerSphere: [[point.longitude, point.latitude], maxDistance]\n    });\n  }\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   * Radius of earth used is 3958.8 miles.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in miles) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinMiles(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  , maxDistance\n  /*: number*/\n  , sorted\n  /*: boolean*/\n  )\n  /*: ParseQuery*/\n  {\n    return this.withinRadians(key, point, maxDistance / 3958.8, sorted);\n  }\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   * Radius of earth used is 6371.0 kilometers.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in kilometers) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinKilometers(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  , maxDistance\n  /*: number*/\n  , sorted\n  /*: boolean*/\n  )\n  /*: ParseQuery*/\n  {\n    return this.withinRadians(key, point, maxDistance / 6371.0, sorted);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's\n   * coordinates be contained within a given rectangular geographic bounding\n   * box.\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Parse.GeoPoint} southwest\n   *     The lower-left inclusive corner of the box.\n   * @param {Parse.GeoPoint} northeast\n   *     The upper-right inclusive corner of the box.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinGeoBox(key\n  /*: string*/\n  , southwest\n  /*: ParseGeoPoint*/\n  , northeast\n  /*: ParseGeoPoint*/\n  )\n  /*: ParseQuery*/\n  {\n    if (!(southwest instanceof _ParseGeoPoint.default)) {\n      southwest = new _ParseGeoPoint.default(southwest);\n    }\n\n    if (!(northeast instanceof _ParseGeoPoint.default)) {\n      northeast = new _ParseGeoPoint.default(northeast);\n    }\n\n    this._addCondition(key, '$within', {\n      $box: [southwest, northeast]\n    });\n\n    return this;\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's\n   * coordinates be contained within and on the bounds of a given polygon.\n   * Supports closed and open (last point is connected to first) paths\n   *\n   * Polygon must have at least 3 points\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Array} points Array of Coordinates / GeoPoints\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinPolygon(key\n  /*: string*/\n  , points\n  /*: Array<Array<number>>*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$geoWithin', {\n      $polygon: points\n    });\n  }\n  /**\n   * Add a constraint to the query that requires a particular key's\n   * coordinates that contains a ParseGeoPoint\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Parse.GeoPoint} point\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  polygonContains(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$geoIntersects', {\n      $point: point\n    });\n  }\n  /** Query Orderings * */\n\n  /**\n   * Sorts the results in ascending order by the given key.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  ascending()\n  /*: ParseQuery*/\n  {\n    this._order = [];\n\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    }\n\n    return this.addAscending.apply(this, keys);\n  }\n  /**\n   * Sorts the results in ascending order by the given key,\n   * but can also add secondary sort descriptors without overwriting _order.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  addAscending()\n  /*: ParseQuery*/\n  {\n    if (!this._order) {\n      this._order = [];\n    }\n\n    for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      keys[_key2] = arguments[_key2];\n    }\n\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        key = key.join();\n      }\n\n      this._order = this._order.concat(key.replace(/\\s/g, '').split(','));\n    });\n    return this;\n  }\n  /**\n   * Sorts the results in descending order by the given key.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  descending()\n  /*: ParseQuery*/\n  {\n    this._order = [];\n\n    for (var _len3 = arguments.length, keys = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      keys[_key3] = arguments[_key3];\n    }\n\n    return this.addDescending.apply(this, keys);\n  }\n  /**\n   * Sorts the results in descending order by the given key,\n   * but can also add secondary sort descriptors without overwriting _order.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  addDescending()\n  /*: ParseQuery*/\n  {\n    if (!this._order) {\n      this._order = [];\n    }\n\n    for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      keys[_key4] = arguments[_key4];\n    }\n\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        key = key.join();\n      }\n\n      this._order = this._order.concat(key.replace(/\\s/g, '').split(',').map(k => {\n        return `-${k}`;\n      }));\n    });\n    return this;\n  }\n  /** Query Options * */\n\n  /**\n   * Sets the number of results to skip before returning any results.\n   * This is useful for pagination.\n   * Default is to skip zero results.\n   *\n   * @param {number} n the number of results to skip.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  skip(n\n  /*: number*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof n !== 'number' || n < 0) {\n      throw new Error('You can only skip by a positive number');\n    }\n\n    this._skip = n;\n    return this;\n  }\n  /**\n   * Sets the limit of the number of results to return. The default limit is 100.\n   *\n   * @param {number} n the number of results to limit to.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  limit(n\n  /*: number*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof n !== 'number') {\n      throw new Error('You can only set the limit to a numeric value');\n    }\n\n    this._limit = n;\n    return this;\n  }\n  /**\n   * Sets the flag to include with response the total number of objects satisfying this query,\n   * despite limits/skip. Might be useful for pagination.\n   * Note that result of this query will be wrapped as an object with\n   * `results`: holding {ParseObject} array and `count`: integer holding total number\n   *\n   * @param {boolean} includeCount false - disable, true - enable.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withCount()\n  /*: ParseQuery*/\n  {\n    let includeCount\n    /*: boolean*/\n    = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    if (typeof includeCount !== 'boolean') {\n      throw new Error('You can only set withCount to a boolean value');\n    }\n\n    this._count = includeCount;\n    return this;\n  }\n  /**\n   * Includes nested Parse.Objects for the provided key.  You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * You can include all nested Parse.Objects by passing in '*'.\n   * Requires Parse Server 3.0.0+\n   * <pre>query.include('*');</pre>\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  include()\n  /*: ParseQuery*/\n  {\n    for (var _len5 = arguments.length, keys = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      keys[_key5] = arguments[_key5];\n    }\n\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        this._include = this._include.concat(key);\n      } else {\n        this._include.push(key);\n      }\n    });\n    return this;\n  }\n  /**\n   * Includes all nested Parse.Objects.\n   *\n   * Requires Parse Server 3.0.0+\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  includeAll()\n  /*: ParseQuery*/\n  {\n    return this.include('*');\n  }\n  /**\n   * Restricts the fields of the returned Parse.Objects to include only the\n   * provided keys.  If this is called multiple times, then all of the keys\n   * specified in each of the calls will be included.\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  select()\n  /*: ParseQuery*/\n  {\n    if (!this._select) {\n      this._select = [];\n    }\n\n    for (var _len6 = arguments.length, keys = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      keys[_key6] = arguments[_key6];\n    }\n\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        this._select = this._select.concat(key);\n      } else {\n        this._select.push(key);\n      }\n    });\n    return this;\n  }\n  /**\n   * Restricts the fields of the returned Parse.Objects to all keys except the\n   * provided keys. Exclude takes precedence over select and include.\n   *\n   * Requires Parse Server 3.6.0+\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to exclude.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  exclude()\n  /*: ParseQuery*/\n  {\n    for (var _len7 = arguments.length, keys = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      keys[_key7] = arguments[_key7];\n    }\n\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        this._exclude = this._exclude.concat(key);\n      } else {\n        this._exclude.push(key);\n      }\n    });\n    return this;\n  }\n  /**\n   * Changes the read preference that the backend will use when performing the query to the database.\n   *\n   * @param {string} readPreference The read preference for the main query.\n   * @param {string} includeReadPreference The read preference for the queries to include pointers.\n   * @param {string} subqueryReadPreference The read preference for the sub queries.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  readPreference(readPreference\n  /*: string*/\n  , includeReadPreference\n  /*:: ?: string*/\n  , subqueryReadPreference\n  /*:: ?: string*/\n  )\n  /*: ParseQuery*/\n  {\n    this._readPreference = readPreference;\n    this._includeReadPreference = includeReadPreference;\n    this._subqueryReadPreference = subqueryReadPreference;\n    return this;\n  }\n\n  onChange(onUpdate\n  /*: any*/\n  , onError\n  /*:: ?: any*/\n\n  /*:: ?: string*/\n  )\n  /*: Promise<LiveQuerySubscription>*/\n  {\n    let sub = null;\n    this.subscribe().then(subscription => {\n      sub = subscription;\n      subscription.on('create', object => {\n        onUpdate(object);\n      });\n      subscription.on('update', object => {\n        onUpdate(object);\n      });\n      subscription.on('error', err => {\n        if (onError) {\n          onError(err);\n        } else {\n          // eslint-disable-next-line no-console\n          console.warn('Moralis: Subscription error', err);\n        }\n      });\n    }).catch(err => {\n      if (onError) {\n        onError(err);\n      } else {\n        // eslint-disable-next-line no-console\n        console.warn('Moralis: Subscription connection error', err);\n      }\n    });\n    return function () {\n      if (sub) {\n        sub.unsubscribe();\n      }\n    };\n  }\n  /**\n   * Subscribe this query to get liveQuery updates\n   *\n   * @param {string} sessionToken (optional) Defaults to the currentUser\n   * @returns {Promise<LiveQuerySubscription>} Returns the liveQuerySubscription, it's an event emitter\n   * which can be used to get liveQuery updates.\n   */\n\n\n  async subscribe(sessionToken\n  /*:: ?: string*/\n  )\n  /*: Promise<LiveQuerySubscription>*/\n  {\n    const currentUser = await _CoreManager.default.getUserController().currentUserAsync();\n\n    if (!sessionToken) {\n      sessionToken = currentUser ? currentUser.getSessionToken() : undefined;\n    }\n\n    const liveQueryClient = await _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient();\n\n    if (liveQueryClient.shouldOpen()) {\n      liveQueryClient.open();\n    }\n\n    const subscription = liveQueryClient.subscribe(this, sessionToken);\n    return subscription.subscribePromise.then(() => {\n      return subscription;\n    });\n  }\n  /**\n   * Constructs a Parse.Query that is the OR of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an or of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to OR.\n   * @static\n   * @returns {Parse.Query} The query that is the OR of the passed in queries.\n   */\n\n\n  static or()\n  /*: ParseQuery*/\n  {\n    for (var _len8 = arguments.length, queries = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      queries[_key8] = arguments[_key8];\n    }\n\n    const className = _getClassNameFromQueries(queries);\n\n    const query = new ParseQuery(className);\n\n    query._orQuery(queries);\n\n    return query;\n  }\n  /**\n   * Constructs a Parse.Query that is the AND of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.and(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an and of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to AND.\n   * @static\n   * @returns {Parse.Query} The query that is the AND of the passed in queries.\n   */\n\n\n  static and()\n  /*: ParseQuery*/\n  {\n    for (var _len9 = arguments.length, queries = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      queries[_key9] = arguments[_key9];\n    }\n\n    const className = _getClassNameFromQueries(queries);\n\n    const query = new ParseQuery(className);\n\n    query._andQuery(queries);\n\n    return query;\n  }\n  /**\n   * Constructs a Parse.Query that is the NOR of the passed in queries.  For\n   * example:\n   * <pre>const compoundQuery = Parse.Query.nor(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is a nor of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to NOR.\n   * @static\n   * @returns {Parse.Query} The query that is the NOR of the passed in queries.\n   */\n\n\n  static nor()\n  /*: ParseQuery*/\n  {\n    for (var _len10 = arguments.length, queries = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      queries[_key10] = arguments[_key10];\n    }\n\n    const className = _getClassNameFromQueries(queries);\n\n    const query = new ParseQuery(className);\n\n    query._norQuery(queries);\n\n    return query;\n  }\n  /**\n   * Change the source of this query to the server.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fromNetwork()\n  /*: ParseQuery*/\n  {\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    return this;\n  }\n  /**\n   * Changes the source of this query to all pinned objects.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fromLocalDatastore()\n  /*: ParseQuery*/\n  {\n    return this.fromPinWithName(null);\n  }\n  /**\n   * Changes the source of this query to the default group of pinned objects.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fromPin()\n  /*: ParseQuery*/\n  {\n    return this.fromPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n  }\n  /**\n   * Changes the source of this query to a specific group of pinned objects.\n   *\n   * @param {string} name The name of query source.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fromPinWithName(name\n  /*:: ?: string*/\n  )\n  /*: ParseQuery*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (localDatastore.checkIfEnabled()) {\n      this._queriesLocalDatastore = true;\n      this._localDatastorePinName = name;\n    }\n\n    return this;\n  }\n  /**\n   * Cancels the current network request (if any is running).\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  cancel()\n  /*: ParseQuery*/\n  {\n    if (this._xhrRequest.task && typeof this._xhrRequest.task.abort === 'function') {\n      this._xhrRequest.task._aborted = true;\n\n      this._xhrRequest.task.abort();\n\n      this._xhrRequest.task = null;\n\n      this._xhrRequest.onchange = () => {};\n\n      return this;\n    }\n\n    return this._xhrRequest.onchange = () => this.cancel();\n  }\n\n  _setRequestTask(options) {\n    options.requestTask = task => {\n      this._xhrRequest.task = task;\n\n      this._xhrRequest.onchange();\n    };\n  }\n\n}\n\nconst DefaultController = {\n  find(className\n  /*: string*/\n  , params\n  /*: QueryJSON*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', `classes/${className}`, params, options);\n  },\n\n  aggregate(className\n  /*: string*/\n  , params\n  /*: any*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<Array<mixed>>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', `aggregate/${className}`, params, options);\n  }\n\n};\n\n_CoreManager.default.setQueryController(DefaultController);\n\nvar _default = ParseQuery;\nexports.default = _default;","map":{"version":3,"sources":["S:/final hackathon/nfi3/node_modules/moralis/lib/node/ParseQuery.js"],"names":["Object","defineProperty","exports","value","default","_CoreManager","_interopRequireDefault","require","_encode","_promiseUtils","_ParseError","_ParseGeoPoint","_ParseObject","_OfflineQuery","_LocalDatastoreUtils","obj","__esModule","_defineProperty","key","enumerable","configurable","writable","quote","s","replace","_getClassNameFromQueries","queries","className","forEach","q","Error","handleSelectResult","data","select","serverDataMask","field","hasSubObjectSelect","indexOf","hasOwnProperty","undefined","pathComponents","split","serverMask","component","index","arr","length","keys","serverData","getObjectStateController","getServerData","id","objectId","copyMissingDataWithMask","src","dest","mask","copyThisLevel","handleOfflineSort","a","b","sorts","order","operator","slice","isDescending","substring","test","INVALID_KEY_NAME","field1","get","field2","remainingSorts","ParseQuery","constructor","objectClass","TypeError","_where","_include","_exclude","_count","_limit","_skip","_readPreference","_includeReadPreference","_subqueryReadPreference","_queriesLocalDatastore","_localDatastorePinName","_extraOptions","_xhrRequest","task","onchange","_orQuery","queryJSON","map","toJSON","where","$or","_andQuery","$and","_norQuery","$nor","_addCondition","condition","_regexStartWith","string","_handleOfflineQuery","params","validateQuery","localDatastore","getLocalDatastore","objects","_serializeObjectsFromPinName","results","json","object","fromJSON","_localId","matchesQuery","filter","concat","_toFullJSON","includes","sort","count","skip","splice","limit","include","join","excludeKeys","_select","_order","readPreference","includeReadPreference","subqueryReadPreference","_hint","hint","_explain","explain","withJSON","query","options","equalTo","firstOptions","useMasterKey","sessionToken","context","first","then","response","errorObject","OBJECT_NOT_FOUND","Promise","reject","find","findOptions","_setRequestTask","controller","getQueryController","override","findAll","result","eachBatch","distinct","distinctOptions","aggregate","pipeline","aggregateOptions","Array","isArray","unshift","match","callback","batchSize","i","attr","val","v","conditionMap","cond","ascending","finished","previousResults","continueWhile","all","resolve","greaterThan","each","callbacksDone","array","push","reduce","initialValue","accumulator","flag","entries","k","doesNotExist","notEqualTo","lessThan","lessThanOrEqualTo","greaterThanOrEqualTo","containedIn","notContainedIn","containedBy","values","containsAll","containsAllStartingWith","_this","regexObject","$regex","exists","matches","regex","modifiers","ignoreCase","multiline","doesNotMatchQuery","matchesKeyInQuery","queryKey","doesNotMatchKeyInQuery","contains","fullText","fullOptions","$term","option","$language","$caseSensitive","$diacriticSensitive","$search","sortByTextScore","startsWith","prefix","endsWith","suffix","near","point","withinRadians","maxDistance","sorted","$centerSphere","longitude","latitude","withinMiles","withinKilometers","withinGeoBox","southwest","northeast","$box","withinPolygon","points","$polygon","polygonContains","$point","addAscending","apply","descending","addDescending","n","withCount","includeCount","includeAll","exclude","onChange","onUpdate","onError","sub","subscribe","subscription","on","err","console","warn","catch","unsubscribe","currentUser","getUserController","currentUserAsync","getSessionToken","liveQueryClient","getLiveQueryController","getDefaultLiveQueryClient","shouldOpen","open","subscribePromise","or","and","nor","fromNetwork","fromLocalDatastore","fromPinWithName","fromPin","DEFAULT_PIN","name","checkIfEnabled","cancel","abort","_aborted","requestTask","DefaultController","RESTController","getRESTController","request","setQueryController","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _promiseUtils = require(\"./promiseUtils\");\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _OfflineQuery = _interopRequireDefault(require(\"./OfflineQuery\"));\n\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Converts a string into a regex that matches it.\n * Surrounding with \\Q .. \\E does this, we just need to escape any \\E's in\n * the text separately.\n *\n * @param s\n * @private\n * @returns {string}\n */\n\n\nfunction quote(s\n/*: string*/\n)\n/*: string*/\n{\n  return `\\\\Q${s.replace('\\\\E', '\\\\E\\\\\\\\E\\\\Q')}\\\\E`;\n}\n/**\n * Extracts the class name from queries. If not all queries have the same\n * class name an error will be thrown.\n *\n * @param queries\n * @private\n * @returns {string}\n */\n\n\nfunction _getClassNameFromQueries(queries\n/*: Array<ParseQuery>*/\n)\n/*: ?string*/\n{\n  let className = null;\n  queries.forEach(q => {\n    if (!className) {\n      // eslint-disable-next-line prefer-destructuring\n      className = q.className;\n    }\n\n    if (className !== q.className) {\n      throw new Error('All queries must be for the same class.');\n    }\n  });\n  return className;\n}\n/*\n * Handles pre-populating the result data of a query with select fields,\n * making sure that the data object contains keys for all objects that have\n * been requested with a select, so that our cached state updates correctly.\n */\n\n\nfunction handleSelectResult(data\n/*: any*/\n, select\n/*: Array<string>*/\n) {\n  const serverDataMask = {};\n  select.forEach(field => {\n    const hasSubObjectSelect = field.indexOf('.') !== -1;\n\n    if (!hasSubObjectSelect && !data.hasOwnProperty(field)) {\n      // this field was selected, but is missing from the retrieved data\n      data[field] = undefined;\n    } else if (hasSubObjectSelect) {\n      // this field references a sub-object,\n      // so we need to walk down the path components\n      const pathComponents = field.split('.');\n      let obj = data;\n      let serverMask = serverDataMask;\n      pathComponents.forEach((component, index, arr) => {\n        // add keys if the expected data is missing\n        if (obj && !obj.hasOwnProperty(component)) {\n          obj[component] = undefined;\n        }\n\n        if (obj && typeof obj === 'object') {\n          obj = obj[component];\n        } // add this path component to the server mask so we can fill it in later if needed\n\n\n        if (index < arr.length - 1) {\n          if (!serverMask[component]) {\n            serverMask[component] = {};\n          }\n\n          serverMask = serverMask[component];\n        }\n      });\n    }\n  });\n\n  if (Object.keys(serverDataMask).length > 0) {\n    // When selecting from sub-objects, we don't want to blow away the missing\n    // information that we may have retrieved before. We've already added any\n    // missing selected keys to sub-objects, but we still need to add in the\n    // data for any previously retrieved sub-objects that were not selected.\n    const serverData = _CoreManager.default.getObjectStateController().getServerData({\n      id: data.objectId,\n      className: data.className\n    });\n\n    copyMissingDataWithMask(serverData, data, serverDataMask, false);\n  }\n}\n\nfunction copyMissingDataWithMask(src, dest, mask, copyThisLevel) {\n  // copy missing elements at this level\n  if (copyThisLevel) {\n    for (const key in src) {\n      if (src.hasOwnProperty(key) && !dest.hasOwnProperty(key)) {\n        dest[key] = src[key];\n      }\n    }\n  }\n\n  for (const key in mask) {\n    if (dest[key] !== undefined && dest[key] !== null && src !== undefined && src !== null) {\n      // traverse into objects as needed\n      copyMissingDataWithMask(src[key], dest[key], mask[key], true);\n    }\n  }\n}\n\nfunction handleOfflineSort(a, b, sorts) {\n  let order = sorts[0];\n  const operator = order.slice(0, 1);\n  const isDescending = operator === '-';\n\n  if (isDescending) {\n    order = order.substring(1);\n  }\n\n  if (order === '_created_at') {\n    order = 'createdAt';\n  }\n\n  if (order === '_updated_at') {\n    order = 'updatedAt';\n  }\n\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(order) || order === 'password') {\n    throw new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, `Invalid Key: ${order}`);\n  }\n\n  const field1 = a.get(order);\n  const field2 = b.get(order);\n\n  if (field1 < field2) {\n    return isDescending ? 1 : -1;\n  }\n\n  if (field1 > field2) {\n    return isDescending ? -1 : 1;\n  }\n\n  if (sorts.length > 1) {\n    const remainingSorts = sorts.slice(1);\n    return handleOfflineSort(a, b, remainingSorts);\n  }\n\n  return 0;\n}\n/**\n * Creates a new parse Parse.Query for the given Parse.Object subclass.\n *\n * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\n * most common use case is finding all objects that match a query through the\n * <code>find</code> method. for example, this sample code fetches all objects\n * of class <code>myclass</code>. it calls a different function depending on\n * whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.find().then((results) => {\n *   // results is an array of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to retrieve a single object whose id is\n * known, through the get method. for example, this sample code fetches an\n * object of class <code>myclass</code> and id <code>myid</code>. it calls a\n * different function depending on whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.get(myid).then((object) => {\n *     // object is an instance of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to count the number of objects that match\n * the query without retrieving all of those objects. for example, this\n * sample code counts the number of objects of the class <code>myclass</code>\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.count().then((number) => {\n *     // there are number instances of myclass.\n * }).catch((error) => {\n *     // error is an instance of Parse.Error.\n * });</pre></p>\n *\n * @alias Parse.Query\n */\n\n\nclass ParseQuery {\n  /**\n   * @property {string} className\n   */\n\n  /**\n   * @param {(string | Parse.Object)} objectClass An instance of a subclass of Parse.Object, or a Parse className string.\n   */\n  constructor(objectClass\n  /*: string | ParseObject*/\n  ) {\n    _defineProperty(this, \"className\", void 0);\n\n    _defineProperty(this, \"_where\", void 0);\n\n    _defineProperty(this, \"_include\", void 0);\n\n    _defineProperty(this, \"_exclude\", void 0);\n\n    _defineProperty(this, \"_select\", void 0);\n\n    _defineProperty(this, \"_limit\", void 0);\n\n    _defineProperty(this, \"_skip\", void 0);\n\n    _defineProperty(this, \"_count\", void 0);\n\n    _defineProperty(this, \"_order\", void 0);\n\n    _defineProperty(this, \"_readPreference\", void 0);\n\n    _defineProperty(this, \"_includeReadPreference\", void 0);\n\n    _defineProperty(this, \"_subqueryReadPreference\", void 0);\n\n    _defineProperty(this, \"_queriesLocalDatastore\", void 0);\n\n    _defineProperty(this, \"_localDatastorePinName\", void 0);\n\n    _defineProperty(this, \"_extraOptions\", void 0);\n\n    _defineProperty(this, \"_hint\", void 0);\n\n    _defineProperty(this, \"_explain\", void 0);\n\n    _defineProperty(this, \"_xhrRequest\", void 0);\n\n    if (typeof objectClass === 'string') {\n      if (objectClass === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = objectClass;\n      }\n    } else if (objectClass instanceof _ParseObject.default) {\n      this.className = objectClass.className;\n    } else if (typeof objectClass === 'function') {\n      if (typeof objectClass.className === 'string') {\n        this.className = objectClass.className;\n      } else {\n        const obj = new objectClass();\n        this.className = obj.className;\n      }\n    } else {\n      throw new TypeError('A ParseQuery must be constructed with a ParseObject or class name.');\n    }\n\n    this._where = {};\n    this._include = [];\n    this._exclude = [];\n    this._count = false; // negative limit is not sent in the server request\n\n    this._limit = -1;\n    this._skip = 0;\n    this._readPreference = null;\n    this._includeReadPreference = null;\n    this._subqueryReadPreference = null;\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    this._extraOptions = {};\n    this._xhrRequest = {\n      task: null,\n      onchange: () => {}\n    };\n  }\n  /**\n   * Adds constraint that at least one of the passed in queries matches.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  _orQuery(queries\n  /*: Array<ParseQuery>*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = queries.map(q => {\n      return q.toJSON().where;\n    });\n    this._where.$or = queryJSON;\n    return this;\n  }\n  /**\n   * Adds constraint that all of the passed in queries match.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  _andQuery(queries\n  /*: Array<ParseQuery>*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = queries.map(q => {\n      return q.toJSON().where;\n    });\n    this._where.$and = queryJSON;\n    return this;\n  }\n  /**\n   * Adds constraint that none of the passed in queries match.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  _norQuery(queries\n  /*: Array<ParseQuery>*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = queries.map(q => {\n      return q.toJSON().where;\n    });\n    this._where.$nor = queryJSON;\n    return this;\n  }\n  /**\n   * Helper for condition queries\n   *\n   * @param key\n   * @param condition\n   * @param value\n   * @returns {Parse.Query}\n   */\n\n\n  _addCondition(key\n  /*: string*/\n  , condition\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    if (!this._where[key] || typeof this._where[key] === 'string') {\n      this._where[key] = {};\n    }\n\n    this._where[key][condition] = (0, _encode.default)(value, false, true);\n    return this;\n  }\n  /**\n   * Converts string for regular expression at the beginning\n   *\n   * @param string\n   * @returns {string}\n   */\n\n\n  _regexStartWith(string\n  /*: string*/\n  )\n  /*: string*/\n  {\n    return `^${quote(string)}`;\n  }\n\n  async _handleOfflineQuery(params\n  /*: any*/\n  ) {\n    _OfflineQuery.default.validateQuery(this);\n\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    const objects = await localDatastore._serializeObjectsFromPinName(this._localDatastorePinName);\n    let results = objects.map((json, index, arr) => {\n      const object = _ParseObject.default.fromJSON(json, false);\n\n      if (json._localId && !json.objectId) {\n        object._localId = json._localId;\n      }\n\n      if (!_OfflineQuery.default.matchesQuery(this.className, object, arr, this)) {\n        return null;\n      }\n\n      return object;\n    }).filter(object => object !== null);\n\n    if (params.keys) {\n      let keys = params.keys.split(',');\n      keys = keys.concat(['className', 'objectId', 'createdAt', 'updatedAt', 'ACL']);\n      results = results.map(object => {\n        const json = object._toFullJSON();\n\n        Object.keys(json).forEach(key => {\n          if (!keys.includes(key)) {\n            delete json[key];\n          }\n        });\n        return _ParseObject.default.fromJSON(json, false);\n      });\n    }\n\n    if (params.order) {\n      const sorts = params.order.split(',');\n      results.sort((a, b) => {\n        return handleOfflineSort(a, b, sorts);\n      });\n    } // count total before applying limit/skip\n\n\n    let count;\n\n    if (params.count) {\n      // total count from response\n      count = results.length;\n    }\n\n    if (params.skip) {\n      if (params.skip >= results.length) {\n        results = [];\n      } else {\n        results = results.splice(params.skip, results.length);\n      }\n    }\n\n    let limit = results.length;\n\n    if (params.limit !== 0 && params.limit < results.length) {\n      // eslint-disable-next-line prefer-destructuring\n      limit = params.limit;\n    }\n\n    results = results.splice(0, limit);\n\n    if (typeof count === 'number') {\n      return {\n        results,\n        count\n      };\n    }\n\n    return results;\n  }\n  /**\n   * Returns a JSON representation of this query.\n   *\n   * @returns {object} The JSON representation of the query.\n   */\n\n\n  toJSON()\n  /*: QueryJSON*/\n  {\n    const params\n    /*: QueryJSON*/\n    = {\n      where: this._where\n    };\n\n    if (this._include.length) {\n      params.include = this._include.join(',');\n    }\n\n    if (this._exclude.length) {\n      params.excludeKeys = this._exclude.join(',');\n    }\n\n    if (this._select) {\n      params.keys = this._select.join(',');\n    }\n\n    if (this._count) {\n      params.count = 1;\n    }\n\n    if (this._limit >= 0) {\n      params.limit = this._limit;\n    }\n\n    if (this._skip > 0) {\n      params.skip = this._skip;\n    }\n\n    if (this._order) {\n      params.order = this._order.join(',');\n    }\n\n    if (this._readPreference) {\n      params.readPreference = this._readPreference;\n    }\n\n    if (this._includeReadPreference) {\n      params.includeReadPreference = this._includeReadPreference;\n    }\n\n    if (this._subqueryReadPreference) {\n      params.subqueryReadPreference = this._subqueryReadPreference;\n    }\n\n    if (this._hint) {\n      params.hint = this._hint;\n    }\n\n    if (this._explain) {\n      params.explain = true;\n    }\n\n    for (const key in this._extraOptions) {\n      params[key] = this._extraOptions[key];\n    }\n\n    return params;\n  }\n  /**\n   * Return a query with conditions from json, can be useful to send query from server side to client\n   * Not static, all query conditions was set before calling this method will be deleted.\n   * For example on the server side we have\n   * var query = new Parse.Query(\"className\");\n   * query.equalTo(key: value);\n   * query.limit(100);\n   * ... (others queries)\n   * Create JSON representation of Query Object\n   * var jsonFromServer = query.fromJSON();\n   *\n   * On client side getting query:\n   * var query = new Parse.Query(\"className\");\n   * query.fromJSON(jsonFromServer);\n   *\n   * and continue to query...\n   * query.skip(100).find().then(...);\n   *\n   * @param {QueryJSON} json from Parse.Query.toJSON() method\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withJSON(json\n  /*: QueryJSON*/\n  )\n  /*: ParseQuery*/\n  {\n    if (json.where) {\n      this._where = json.where;\n    }\n\n    if (json.include) {\n      this._include = json.include.split(',');\n    }\n\n    if (json.keys) {\n      this._select = json.keys.split(',');\n    }\n\n    if (json.excludeKeys) {\n      this._exclude = json.excludeKeys.split(',');\n    }\n\n    if (json.count) {\n      this._count = json.count === 1;\n    }\n\n    if (json.limit) {\n      this._limit = json.limit;\n    }\n\n    if (json.skip) {\n      this._skip = json.skip;\n    }\n\n    if (json.order) {\n      this._order = json.order.split(',');\n    }\n\n    if (json.readPreference) {\n      this._readPreference = json.readPreference;\n    }\n\n    if (json.includeReadPreference) {\n      this._includeReadPreference = json.includeReadPreference;\n    }\n\n    if (json.subqueryReadPreference) {\n      this._subqueryReadPreference = json.subqueryReadPreference;\n    }\n\n    if (json.hint) {\n      this._hint = json.hint;\n    }\n\n    if (json.explain) {\n      this._explain = !!json.explain;\n    }\n\n    for (const key in json) {\n      if (json.hasOwnProperty(key)) {\n        if (['where', 'include', 'keys', 'count', 'limit', 'skip', 'order', 'readPreference', 'includeReadPreference', 'subqueryReadPreference', 'hint', 'explain'].indexOf(key) === -1) {\n          this._extraOptions[key] = json[key];\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Static method to restore Parse.Query by json representation\n   * Internally calling Parse.Query.withJSON\n   *\n   * @param {string} className\n   * @param {QueryJSON} json from Parse.Query.toJSON() method\n   * @returns {Parse.Query} new created query\n   */\n\n\n  static fromJSON(className\n  /*: string*/\n  , json\n  /*: QueryJSON*/\n  )\n  /*: ParseQuery*/\n  {\n    const query = new ParseQuery(className);\n    return query.withJSON(json);\n  }\n  /**\n   * Constructs a Parse.Object whose id is already known by fetching data from\n   * the server. Unlike the <code>first</code> method, it never returns undefined.\n   *\n   * @param {string} objectId The id of the object to be fetched.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  get(objectId\n  /*: string*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseObject>*/\n  {\n    this.equalTo('objectId', objectId);\n    const firstOptions = {};\n\n    if (options && options.hasOwnProperty('useMasterKey')) {\n      firstOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options && options.hasOwnProperty('sessionToken')) {\n      firstOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options && options.hasOwnProperty('context') && typeof options.context === 'object') {\n      firstOptions.context = options.context;\n    }\n\n    return this.first(firstOptions).then(response => {\n      if (response) {\n        return response;\n      }\n\n      const errorObject = new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'Object not found.');\n      return Promise.reject(errorObject);\n    });\n  }\n  /**\n   * Retrieves a list of ParseObjects that satisfy this query.\n   *\n   * @param {object} options Valid options\n   * are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the results when\n   * the query completes.\n   */\n\n\n  find(options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    options = options || {};\n    const findOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n\n    this._setRequestTask(findOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    const select = this._select;\n\n    if (this._queriesLocalDatastore) {\n      return this._handleOfflineQuery(this.toJSON());\n    }\n\n    return controller.find(this.className, this.toJSON(), findOptions).then(response => {\n      // Return generic object when explain is used\n      if (this._explain) {\n        return response.results;\n      }\n\n      const results = response.results.map(data => {\n        // In cases of relations, the server may send back a className\n        // on the top level of the payload\n        const override = response.className || this.className;\n\n        if (!data.className) {\n          data.className = override;\n        } // Make sure the data object contains keys for all objects that\n        // have been requested with a select, so that our cached state\n        // updates correctly.\n\n\n        if (select) {\n          handleSelectResult(data, select);\n        }\n\n        return _ParseObject.default.fromJSON(data, !select);\n      });\n      const {\n        count\n      } = response;\n\n      if (typeof count === 'number') {\n        return {\n          results,\n          count\n        };\n      }\n\n      return results;\n    });\n  }\n  /**\n   * Retrieves a complete list of ParseObjects that satisfy this query.\n   * Using `eachBatch` under the hood to fetch all the valid objects.\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>batchSize: How many objects to yield in each batch (default: 100)\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the results when\n   * the query completes.\n   */\n\n\n  async findAll(options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    let result\n    /*: ParseObject[]*/\n    = [];\n    await this.eachBatch((objects\n    /*: ParseObject[]*/\n    ) => {\n      result = [...result, ...objects];\n    }, options);\n    return result;\n  }\n  /**\n   * Counts the number of objects that match this query.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the count when\n   * the query completes.\n   */\n\n\n  count(options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<number>*/\n  {\n    options = options || {};\n    const findOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n\n    this._setRequestTask(findOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    const params = this.toJSON();\n    params.limit = 0;\n    params.count = 1;\n    return controller.find(this.className, params, findOptions).then(result => {\n      return result.count;\n    });\n  }\n  /**\n   * Executes a distinct query and returns unique values\n   *\n   * @param {string} key A field to find distinct values\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the query completes.\n   */\n\n\n  distinct(key\n  /*: string*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<Array<mixed>>*/\n  {\n    options = options || {};\n    const distinctOptions = {};\n    distinctOptions.useMasterKey = true;\n\n    if (options.hasOwnProperty('sessionToken')) {\n      distinctOptions.sessionToken = options.sessionToken;\n    }\n\n    this._setRequestTask(distinctOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    const params = {\n      distinct: key,\n      where: this._where,\n      hint: this._hint\n    };\n    return controller.aggregate(this.className, params, distinctOptions).then(results => {\n      return results.results;\n    });\n  }\n  /**\n   * Executes an aggregate query and returns aggregate results\n   *\n   * @param {(Array|object)} pipeline Array or Object of stages to process query\n   * @param {object} options Valid options are:<ul>\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the query completes.\n   */\n\n\n  aggregate(pipeline\n  /*: mixed*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<Array<mixed>>*/\n  {\n    options = options || {};\n    const aggregateOptions = {};\n    aggregateOptions.useMasterKey = true;\n\n    if (options.hasOwnProperty('sessionToken')) {\n      aggregateOptions.sessionToken = options.sessionToken;\n    }\n\n    this._setRequestTask(aggregateOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    if (!Array.isArray(pipeline) && typeof pipeline !== 'object') {\n      throw new Error('Invalid pipeline must be Array or Object');\n    }\n\n    if (Object.keys(this._where || {}).length) {\n      if (!Array.isArray(pipeline)) {\n        pipeline = [pipeline];\n      }\n\n      pipeline.unshift({\n        match: this._where\n      });\n    }\n\n    const params = {\n      pipeline,\n      hint: this._hint,\n      explain: this._explain,\n      readPreference: this._readPreference\n    };\n    return controller.aggregate(this.className, params, aggregateOptions).then(results => {\n      return results.results;\n    });\n  }\n  /**\n   * Retrieves at most one Parse.Object that satisfies this query.\n   *\n   * Returns the object if there is one, otherwise undefined.\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the object when\n   * the query completes.\n   */\n\n\n  first(options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseObject | void>*/\n  {\n    options = options || {};\n    const findOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n\n    this._setRequestTask(findOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    const params = this.toJSON();\n    params.limit = 1;\n    const select = this._select;\n\n    if (this._queriesLocalDatastore) {\n      return this._handleOfflineQuery(params).then(objects => {\n        if (!objects[0]) {\n          return undefined;\n        }\n\n        return objects[0];\n      });\n    }\n\n    return controller.find(this.className, params, findOptions).then(response => {\n      const objects = response.results;\n\n      if (!objects[0]) {\n        return undefined;\n      }\n\n      if (!objects[0].className) {\n        objects[0].className = this.className;\n      } // Make sure the data object contains keys for all objects that\n      // have been requested with a select, so that our cached state\n      // updates correctly.\n\n\n      if (select) {\n        handleSelectResult(objects[0], select);\n      }\n\n      return _ParseObject.default.fromJSON(objects[0], !select);\n    });\n  }\n  /**\n   * Iterates over objects matching a query, calling a callback for each batch.\n   * If the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are processed\n   * in an unspecified order. The query may not have any sort order, and may\n   * not use limit or skip.\n   *\n   * @param {Function} callback Callback that will be called with each result\n   *     of the query.\n   * @param {object} options Valid options are:<ul>\n   *   <li>batchSize: How many objects to yield in each batch (default: 100)\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  eachBatch(callback\n  /*: (objs: Array<ParseObject>) => Promise<*>*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<void>*/\n  {\n    options = options || {};\n\n    if (this._order || this._skip || this._limit >= 0) {\n      return Promise.reject('Cannot iterate on a query with sort, skip, or limit.');\n    }\n\n    const query = new ParseQuery(this.className);\n    query._limit = options.batchSize || 100;\n    query._include = this._include.map(i => {\n      return i;\n    });\n\n    if (this._select) {\n      query._select = this._select.map(s => {\n        return s;\n      });\n    }\n\n    query._hint = this._hint;\n    query._where = {};\n\n    for (const attr in this._where) {\n      const val = this._where[attr];\n\n      if (Array.isArray(val)) {\n        query._where[attr] = val.map(v => {\n          return v;\n        });\n      } else if (val && typeof val === 'object') {\n        const conditionMap = {};\n        query._where[attr] = conditionMap;\n\n        for (const cond in val) {\n          conditionMap[cond] = val[cond];\n        }\n      } else {\n        query._where[attr] = val;\n      }\n    }\n\n    query.ascending('objectId');\n    const findOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n\n    let finished = false;\n    let previousResults = [];\n    return (0, _promiseUtils.continueWhile)(() => {\n      return !finished;\n    }, async () => {\n      const [results] = await Promise.all([query.find(findOptions), Promise.resolve(previousResults.length > 0 && callback(previousResults))]);\n\n      if (results.length >= query._limit) {\n        query.greaterThan('objectId', results[results.length - 1].id);\n        previousResults = results;\n      } else if (results.length > 0) {\n        await Promise.resolve(callback(results));\n        finished = true;\n      } else {\n        finished = true;\n      }\n    });\n  }\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback that will be called with each result\n   *     of the query.\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  each(callback\n  /*: (obj: ParseObject) => any*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<void>*/\n  {\n    return this.eachBatch(results => {\n      let callbacksDone = Promise.resolve();\n      results.forEach(result => {\n        callbacksDone = callbacksDone.then(() => {\n          return callback(result);\n        });\n      });\n      return callbacksDone;\n    }, options);\n  }\n  /**\n   * Adds a hint to force index selection. (https://docs.mongodb.com/manual/reference/operator/meta/hint/)\n   *\n   * @param {(string|object)} value String or Object of index that should be used when executing query\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  hint(value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof value === 'undefined') {\n      delete this._hint;\n    }\n\n    this._hint = value;\n    return this;\n  }\n  /**\n   * Investigates the query execution plan. Useful for optimizing queries. (https://docs.mongodb.com/manual/reference/operator/meta/explain/)\n   *\n   * @param {boolean} explain Used to toggle the information on the query plan.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  explain(explain\n  /*: boolean*/\n  = true)\n  /*: ParseQuery*/\n  {\n    if (typeof explain !== 'boolean') {\n      throw new Error('You can only set explain to a boolean value');\n    }\n\n    this._explain = explain;\n    return this;\n  }\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   *   <li>query: The query map was called upon.</li>\n   * </ul>\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  async map(callback\n  /*: (currentObject: ParseObject, index: number, query: ParseQuery) => any*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<Array<any>>*/\n  {\n    const array = [];\n    let index = 0;\n    await this.each(object => {\n      return Promise.resolve(callback(object, index, this)).then(result => {\n        array.push(result);\n        index += 1;\n      });\n    }, options);\n    return array;\n  }\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>accumulator: The accumulator accumulates the callback's return values. It is the accumulated value previously returned in the last invocation of the callback.</li>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   * </ul>\n   * @param {*} initialValue A value to use as the first argument to the first call of the callback. If no initialValue is supplied, the first object in the query will be used and skipped.\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  async reduce(callback\n  /*: (accumulator: any, currentObject: ParseObject, index: number) => any*/\n  , initialValue\n  /*: any*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<Array<any>>*/\n  {\n    let accumulator = initialValue;\n    let index = 0;\n    await this.each(object => {\n      // If no initial value was given, we take the first object from the query\n      // as the initial value and don't call the callback with it.\n      if (index === 0 && initialValue === undefined) {\n        accumulator = object;\n        index += 1;\n        return;\n      }\n\n      return Promise.resolve(callback(accumulator, object, index)).then(result => {\n        accumulator = result;\n        index += 1;\n      });\n    }, options);\n\n    if (index === 0 && initialValue === undefined) {\n      // Match Array.reduce behavior: \"Calling reduce() on an empty array\n      // without an initialValue will throw a TypeError\".\n      throw new TypeError('Reducing empty query result set with no initial value');\n    }\n\n    return accumulator;\n  }\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   *   <li>query: The query filter was called upon.</li>\n   * </ul>\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  async filter(callback\n  /*: (currentObject: ParseObject, index: number, query: ParseQuery) => boolean*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    const array = [];\n    let index = 0;\n    await this.each(object => {\n      return Promise.resolve(callback(object, index, this)).then(flag => {\n        if (flag) {\n          array.push(object);\n        }\n\n        index += 1;\n      });\n    }, options);\n    return array;\n  }\n  /** Query Conditions * */\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that the Parse.Object must contain.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  equalTo(key\n  /*: string | { [key: string]: any }*/\n  , value\n  /*: ?mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    if (key && typeof key === 'object') {\n      Object.entries(key).forEach(([k, val]) => this.equalTo(k, val));\n      return this;\n    }\n\n    if (typeof value === 'undefined') {\n      return this.doesNotExist(key);\n    }\n\n    this._where[key] = (0, _encode.default)(value, false, true);\n    return this;\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be not equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that must not be equalled.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  notEqualTo(key\n  /*: string | { [key: string]: any }*/\n  , value\n  /*: ?mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    if (key && typeof key === 'object') {\n      Object.entries(key).forEach(([k, val]) => this.notEqualTo(k, val));\n      return this;\n    }\n\n    return this._addCondition(key, '$ne', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be less than the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an upper bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  lessThan(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$lt', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be greater than the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an lower bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  greaterThan(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$gt', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be less than or equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an upper bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  lessThanOrEqualTo(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$lte', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be greater than or equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param {*} value The value that provides an lower bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  greaterThanOrEqualTo(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$gte', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be contained in the provided list of values.\n   *\n   * @param {string} key The key to check.\n   * @param {*} value The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  containedIn(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$in', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * not be contained in the provided list of values.\n   *\n   * @param {string} key The key to check.\n   * @param {*} value The values that will not match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  notContainedIn(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$nin', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be contained by the provided list of values. Get objects where all array elements match.\n   *\n   * @param {string} key The key to check.\n   * @param {Array} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  containedBy(key\n  /*: string*/\n  , values\n  /*: Array<mixed>*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$containedBy', values);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * contain each one of the provided list of values.\n   *\n   * @param {string} key The key to check.  This key's value must be an array.\n   * @param {Array} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  containsAll(key\n  /*: string*/\n  , values\n  /*: Array<mixed>*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$all', values);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * contain each one of the provided list of values starting with given strings.\n   *\n   * @param {string} key The key to check.  This key's value must be an array.\n   * @param {Array<string>} values The string values that will match as starting string.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  containsAllStartingWith(key\n  /*: string*/\n  , values\n  /*: Array<string>*/\n  )\n  /*: ParseQuery*/\n  {\n    const _this = this;\n\n    if (!Array.isArray(values)) {\n      values = [values];\n    }\n\n    const regexObject = values.map(value => {\n      return {\n        $regex: _this._regexStartWith(value)\n      };\n    });\n    return this.containsAll(key, regexObject);\n  }\n  /**\n   * Adds a constraint for finding objects that contain the given key.\n   *\n   * @param {string} key The key that should exist.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  exists(key\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$exists', true);\n  }\n  /**\n   * Adds a constraint for finding objects that do not contain a given key.\n   *\n   * @param {string} key The key that should not exist\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  doesNotExist(key\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$exists', false);\n  }\n  /**\n   * Adds a regular expression constraint for finding string values that match\n   * the provided regular expression.\n   * This may be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {RegExp} regex The regular expression pattern to match.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  matches(key\n  /*: string*/\n  , regex\n  /*: RegExp*/\n  , modifiers\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    this._addCondition(key, '$regex', regex);\n\n    if (!modifiers) {\n      modifiers = '';\n    }\n\n    if (regex.ignoreCase) {\n      modifiers += 'i';\n    }\n\n    if (regex.multiline) {\n      modifiers += 'm';\n    }\n\n    if (modifiers.length) {\n      this._addCondition(key, '$options', modifiers);\n    }\n\n    return this;\n  }\n  /**\n   * Adds a constraint that requires that a key's value matches a Parse.Query\n   * constraint.\n   *\n   * @param {string} key The key that the contains the object to match the\n   *                     query.\n   * @param {Parse.Query} query The query that should match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  matchesQuery(key\n  /*: string*/\n  , query\n  /*: ParseQuery*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$inQuery', queryJSON);\n  }\n  /**\n   * Adds a constraint that requires that a key's value not matches a\n   * Parse.Query constraint.\n   *\n   * @param {string} key The key that the contains the object to match the\n   *                     query.\n   * @param {Parse.Query} query The query that should not match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  doesNotMatchQuery(key\n  /*: string*/\n  , query\n  /*: ParseQuery*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$notInQuery', queryJSON);\n  }\n  /**\n   * Adds a constraint that requires that a key's value matches a value in\n   * an object returned by a different Parse.Query.\n   *\n   * @param {string} key The key that contains the value that is being\n   *                     matched.\n   * @param {string} queryKey The key in the objects returned by the query to\n   *                          match against.\n   * @param {Parse.Query} query The query to run.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  matchesKeyInQuery(key\n  /*: string*/\n  , queryKey\n  /*: string*/\n  , query\n  /*: ParseQuery*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$select', {\n      key: queryKey,\n      query: queryJSON\n    });\n  }\n  /**\n   * Adds a constraint that requires that a key's value not match a value in\n   * an object returned by a different Parse.Query.\n   *\n   * @param {string} key The key that contains the value that is being\n   *                     excluded.\n   * @param {string} queryKey The key in the objects returned by the query to\n   *                          match against.\n   * @param {Parse.Query} query The query to run.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  doesNotMatchKeyInQuery(key\n  /*: string*/\n  , queryKey\n  /*: string*/\n  , query\n  /*: ParseQuery*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$dontSelect', {\n      key: queryKey,\n      query: queryJSON\n    });\n  }\n  /**\n   * Adds a constraint for finding string values that contain a provided\n   * string.  This may be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} substring The substring that the value must contain.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  contains(key\n  /*: string*/\n  , substring\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof substring !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n\n    return this._addCondition(key, '$regex', quote(substring));\n  }\n  /**\n   * Adds a constraint for finding string values that contain a provided\n   * string. This may be slow for large datasets. Requires Parse-Server > 2.5.0\n   *\n   * In order to sort you must use select and ascending ($score is required)\n   *  <pre>\n   *   query.fullText('field', 'term');\n   *   query.ascending('$score');\n   *   query.select('$score');\n   *  </pre>\n   *\n   * To retrieve the weight / rank\n   *  <pre>\n   *   object->get('score');\n   *  </pre>\n   *\n   * You can define optionals by providing an object as a third parameter\n   *  <pre>\n   *   query.fullText('field', 'term', { language: 'es', diacriticSensitive: true });\n   *  </pre>\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} value The string to search\n   * @param {object} options (Optional)\n   * @param {string} options.language The language that determines the list of stop words for the search and the rules for the stemmer and tokenizer.\n   * @param {boolean} options.caseSensitive A boolean flag to enable or disable case sensitive search.\n   * @param {boolean} options.diacriticSensitive A boolean flag to enable or disable diacritic sensitive search.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fullText(key\n  /*: string*/\n  , value\n  /*: string*/\n  , options\n  /*: ?Object*/\n  )\n  /*: ParseQuery*/\n  {\n    options = options || {};\n\n    if (!key) {\n      throw new Error('A key is required.');\n    }\n\n    if (!value) {\n      throw new Error('A search term is required');\n    }\n\n    if (typeof value !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n\n    const fullOptions = {};\n    fullOptions.$term = value;\n\n    for (const option in options) {\n      switch (option) {\n        case 'language':\n          fullOptions.$language = options[option];\n          break;\n\n        case 'caseSensitive':\n          fullOptions.$caseSensitive = options[option];\n          break;\n\n        case 'diacriticSensitive':\n          fullOptions.$diacriticSensitive = options[option];\n          break;\n\n        default:\n          throw new Error(`Unknown option: ${option}`);\n      }\n    }\n\n    return this._addCondition(key, '$text', {\n      $search: fullOptions\n    });\n  }\n  /**\n   * Method to sort the full text search by text score\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  sortByTextScore() {\n    this.ascending('$score');\n    this.select(['$score']);\n    return this;\n  }\n  /**\n   * Adds a constraint for finding string values that start with a provided\n   * string.  This query will use the backend index, so it will be fast even\n   * for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} prefix The substring that the value must start with.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  startsWith(key\n  /*: string*/\n  , prefix\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof prefix !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n\n    return this._addCondition(key, '$regex', this._regexStartWith(prefix));\n  }\n  /**\n   * Adds a constraint for finding string values that end with a provided\n   * string.  This will be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} suffix The substring that the value must end with.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  endsWith(key\n  /*: string*/\n  , suffix\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof suffix !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n\n    return this._addCondition(key, '$regex', `${quote(suffix)}$`);\n  }\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  near(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  )\n  /*: ParseQuery*/\n  {\n    if (!(point instanceof _ParseGeoPoint.default)) {\n      // Try to cast it as a GeoPoint\n      point = new _ParseGeoPoint.default(point);\n    }\n\n    return this._addCondition(key, '$nearSphere', point);\n  }\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in radians) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinRadians(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  , maxDistance\n  /*: number*/\n  , sorted\n  /*: boolean*/\n  )\n  /*: ParseQuery*/\n  {\n    if (sorted || sorted === undefined) {\n      this.near(key, point);\n      return this._addCondition(key, '$maxDistance', maxDistance);\n    }\n\n    return this._addCondition(key, '$geoWithin', {\n      $centerSphere: [[point.longitude, point.latitude], maxDistance]\n    });\n  }\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   * Radius of earth used is 3958.8 miles.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in miles) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinMiles(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  , maxDistance\n  /*: number*/\n  , sorted\n  /*: boolean*/\n  )\n  /*: ParseQuery*/\n  {\n    return this.withinRadians(key, point, maxDistance / 3958.8, sorted);\n  }\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   * Radius of earth used is 6371.0 kilometers.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in kilometers) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinKilometers(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  , maxDistance\n  /*: number*/\n  , sorted\n  /*: boolean*/\n  )\n  /*: ParseQuery*/\n  {\n    return this.withinRadians(key, point, maxDistance / 6371.0, sorted);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's\n   * coordinates be contained within a given rectangular geographic bounding\n   * box.\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Parse.GeoPoint} southwest\n   *     The lower-left inclusive corner of the box.\n   * @param {Parse.GeoPoint} northeast\n   *     The upper-right inclusive corner of the box.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinGeoBox(key\n  /*: string*/\n  , southwest\n  /*: ParseGeoPoint*/\n  , northeast\n  /*: ParseGeoPoint*/\n  )\n  /*: ParseQuery*/\n  {\n    if (!(southwest instanceof _ParseGeoPoint.default)) {\n      southwest = new _ParseGeoPoint.default(southwest);\n    }\n\n    if (!(northeast instanceof _ParseGeoPoint.default)) {\n      northeast = new _ParseGeoPoint.default(northeast);\n    }\n\n    this._addCondition(key, '$within', {\n      $box: [southwest, northeast]\n    });\n\n    return this;\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's\n   * coordinates be contained within and on the bounds of a given polygon.\n   * Supports closed and open (last point is connected to first) paths\n   *\n   * Polygon must have at least 3 points\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Array} points Array of Coordinates / GeoPoints\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinPolygon(key\n  /*: string*/\n  , points\n  /*: Array<Array<number>>*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$geoWithin', {\n      $polygon: points\n    });\n  }\n  /**\n   * Add a constraint to the query that requires a particular key's\n   * coordinates that contains a ParseGeoPoint\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Parse.GeoPoint} point\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  polygonContains(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$geoIntersects', {\n      $point: point\n    });\n  }\n  /** Query Orderings * */\n\n  /**\n   * Sorts the results in ascending order by the given key.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  ascending(...keys)\n  /*: ParseQuery*/\n  {\n    this._order = [];\n    return this.addAscending.apply(this, keys);\n  }\n  /**\n   * Sorts the results in ascending order by the given key,\n   * but can also add secondary sort descriptors without overwriting _order.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  addAscending(...keys)\n  /*: ParseQuery*/\n  {\n    if (!this._order) {\n      this._order = [];\n    }\n\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        key = key.join();\n      }\n\n      this._order = this._order.concat(key.replace(/\\s/g, '').split(','));\n    });\n    return this;\n  }\n  /**\n   * Sorts the results in descending order by the given key.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  descending(...keys)\n  /*: ParseQuery*/\n  {\n    this._order = [];\n    return this.addDescending.apply(this, keys);\n  }\n  /**\n   * Sorts the results in descending order by the given key,\n   * but can also add secondary sort descriptors without overwriting _order.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  addDescending(...keys)\n  /*: ParseQuery*/\n  {\n    if (!this._order) {\n      this._order = [];\n    }\n\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        key = key.join();\n      }\n\n      this._order = this._order.concat(key.replace(/\\s/g, '').split(',').map(k => {\n        return `-${k}`;\n      }));\n    });\n    return this;\n  }\n  /** Query Options * */\n\n  /**\n   * Sets the number of results to skip before returning any results.\n   * This is useful for pagination.\n   * Default is to skip zero results.\n   *\n   * @param {number} n the number of results to skip.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  skip(n\n  /*: number*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof n !== 'number' || n < 0) {\n      throw new Error('You can only skip by a positive number');\n    }\n\n    this._skip = n;\n    return this;\n  }\n  /**\n   * Sets the limit of the number of results to return. The default limit is 100.\n   *\n   * @param {number} n the number of results to limit to.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  limit(n\n  /*: number*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof n !== 'number') {\n      throw new Error('You can only set the limit to a numeric value');\n    }\n\n    this._limit = n;\n    return this;\n  }\n  /**\n   * Sets the flag to include with response the total number of objects satisfying this query,\n   * despite limits/skip. Might be useful for pagination.\n   * Note that result of this query will be wrapped as an object with\n   * `results`: holding {ParseObject} array and `count`: integer holding total number\n   *\n   * @param {boolean} includeCount false - disable, true - enable.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withCount(includeCount\n  /*: boolean*/\n  = true)\n  /*: ParseQuery*/\n  {\n    if (typeof includeCount !== 'boolean') {\n      throw new Error('You can only set withCount to a boolean value');\n    }\n\n    this._count = includeCount;\n    return this;\n  }\n  /**\n   * Includes nested Parse.Objects for the provided key.  You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * You can include all nested Parse.Objects by passing in '*'.\n   * Requires Parse Server 3.0.0+\n   * <pre>query.include('*');</pre>\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  include(...keys)\n  /*: ParseQuery*/\n  {\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        this._include = this._include.concat(key);\n      } else {\n        this._include.push(key);\n      }\n    });\n    return this;\n  }\n  /**\n   * Includes all nested Parse.Objects.\n   *\n   * Requires Parse Server 3.0.0+\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  includeAll()\n  /*: ParseQuery*/\n  {\n    return this.include('*');\n  }\n  /**\n   * Restricts the fields of the returned Parse.Objects to include only the\n   * provided keys.  If this is called multiple times, then all of the keys\n   * specified in each of the calls will be included.\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  select(...keys)\n  /*: ParseQuery*/\n  {\n    if (!this._select) {\n      this._select = [];\n    }\n\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        this._select = this._select.concat(key);\n      } else {\n        this._select.push(key);\n      }\n    });\n    return this;\n  }\n  /**\n   * Restricts the fields of the returned Parse.Objects to all keys except the\n   * provided keys. Exclude takes precedence over select and include.\n   *\n   * Requires Parse Server 3.6.0+\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to exclude.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  exclude(...keys)\n  /*: ParseQuery*/\n  {\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        this._exclude = this._exclude.concat(key);\n      } else {\n        this._exclude.push(key);\n      }\n    });\n    return this;\n  }\n  /**\n   * Changes the read preference that the backend will use when performing the query to the database.\n   *\n   * @param {string} readPreference The read preference for the main query.\n   * @param {string} includeReadPreference The read preference for the queries to include pointers.\n   * @param {string} subqueryReadPreference The read preference for the sub queries.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  readPreference(readPreference\n  /*: string*/\n  , includeReadPreference\n  /*:: ?: string*/\n  , subqueryReadPreference\n  /*:: ?: string*/\n  )\n  /*: ParseQuery*/\n  {\n    this._readPreference = readPreference;\n    this._includeReadPreference = includeReadPreference;\n    this._subqueryReadPreference = subqueryReadPreference;\n    return this;\n  }\n\n  onChange(onUpdate\n  /*: any*/\n  , onError\n  /*:: ?: any*/\n\n  /*:: ?: string*/\n  )\n  /*: Promise<LiveQuerySubscription>*/\n  {\n    let sub = null;\n    this.subscribe().then(subscription => {\n      sub = subscription;\n      subscription.on('create', object => {\n        onUpdate(object);\n      });\n      subscription.on('update', object => {\n        onUpdate(object);\n      });\n      subscription.on('error', err => {\n        if (onError) {\n          onError(err);\n        } else {\n          // eslint-disable-next-line no-console\n          console.warn('Moralis: Subscription error', err);\n        }\n      });\n    }).catch(err => {\n      if (onError) {\n        onError(err);\n      } else {\n        // eslint-disable-next-line no-console\n        console.warn('Moralis: Subscription connection error', err);\n      }\n    });\n    return function () {\n      if (sub) {\n        sub.unsubscribe();\n      }\n    };\n  }\n  /**\n   * Subscribe this query to get liveQuery updates\n   *\n   * @param {string} sessionToken (optional) Defaults to the currentUser\n   * @returns {Promise<LiveQuerySubscription>} Returns the liveQuerySubscription, it's an event emitter\n   * which can be used to get liveQuery updates.\n   */\n\n\n  async subscribe(sessionToken\n  /*:: ?: string*/\n  )\n  /*: Promise<LiveQuerySubscription>*/\n  {\n    const currentUser = await _CoreManager.default.getUserController().currentUserAsync();\n\n    if (!sessionToken) {\n      sessionToken = currentUser ? currentUser.getSessionToken() : undefined;\n    }\n\n    const liveQueryClient = await _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient();\n\n    if (liveQueryClient.shouldOpen()) {\n      liveQueryClient.open();\n    }\n\n    const subscription = liveQueryClient.subscribe(this, sessionToken);\n    return subscription.subscribePromise.then(() => {\n      return subscription;\n    });\n  }\n  /**\n   * Constructs a Parse.Query that is the OR of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an or of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to OR.\n   * @static\n   * @returns {Parse.Query} The query that is the OR of the passed in queries.\n   */\n\n\n  static or(...queries)\n  /*: ParseQuery*/\n  {\n    const className = _getClassNameFromQueries(queries);\n\n    const query = new ParseQuery(className);\n\n    query._orQuery(queries);\n\n    return query;\n  }\n  /**\n   * Constructs a Parse.Query that is the AND of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.and(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an and of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to AND.\n   * @static\n   * @returns {Parse.Query} The query that is the AND of the passed in queries.\n   */\n\n\n  static and(...queries)\n  /*: ParseQuery*/\n  {\n    const className = _getClassNameFromQueries(queries);\n\n    const query = new ParseQuery(className);\n\n    query._andQuery(queries);\n\n    return query;\n  }\n  /**\n   * Constructs a Parse.Query that is the NOR of the passed in queries.  For\n   * example:\n   * <pre>const compoundQuery = Parse.Query.nor(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is a nor of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to NOR.\n   * @static\n   * @returns {Parse.Query} The query that is the NOR of the passed in queries.\n   */\n\n\n  static nor(...queries)\n  /*: ParseQuery*/\n  {\n    const className = _getClassNameFromQueries(queries);\n\n    const query = new ParseQuery(className);\n\n    query._norQuery(queries);\n\n    return query;\n  }\n  /**\n   * Change the source of this query to the server.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fromNetwork()\n  /*: ParseQuery*/\n  {\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    return this;\n  }\n  /**\n   * Changes the source of this query to all pinned objects.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fromLocalDatastore()\n  /*: ParseQuery*/\n  {\n    return this.fromPinWithName(null);\n  }\n  /**\n   * Changes the source of this query to the default group of pinned objects.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fromPin()\n  /*: ParseQuery*/\n  {\n    return this.fromPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n  }\n  /**\n   * Changes the source of this query to a specific group of pinned objects.\n   *\n   * @param {string} name The name of query source.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fromPinWithName(name\n  /*:: ?: string*/\n  )\n  /*: ParseQuery*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (localDatastore.checkIfEnabled()) {\n      this._queriesLocalDatastore = true;\n      this._localDatastorePinName = name;\n    }\n\n    return this;\n  }\n  /**\n   * Cancels the current network request (if any is running).\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  cancel()\n  /*: ParseQuery*/\n  {\n    if (this._xhrRequest.task && typeof this._xhrRequest.task.abort === 'function') {\n      this._xhrRequest.task._aborted = true;\n\n      this._xhrRequest.task.abort();\n\n      this._xhrRequest.task = null;\n\n      this._xhrRequest.onchange = () => {};\n\n      return this;\n    }\n\n    return this._xhrRequest.onchange = () => this.cancel();\n  }\n\n  _setRequestTask(options) {\n    options.requestTask = task => {\n      this._xhrRequest.task = task;\n\n      this._xhrRequest.onchange();\n    };\n  }\n\n}\n\nconst DefaultController = {\n  find(className\n  /*: string*/\n  , params\n  /*: QueryJSON*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', `classes/${className}`, params, options);\n  },\n\n  aggregate(className\n  /*: string*/\n  , params\n  /*: any*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<Array<mixed>>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', `aggregate/${className}`, params, options);\n  }\n\n};\n\n_CoreManager.default.setQueryController(DefaultController);\n\nvar _default = ParseQuery;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}