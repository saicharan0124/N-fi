{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnsetOp = exports.SetOp = exports.RemoveOp = exports.RelationOp = exports.Op = exports.IncrementOp = exports.AddUniqueOp = exports.AddOp = void 0;\nexports.opFromJSON = opFromJSON;\n\nvar _arrayContainsObject = _interopRequireDefault(require(\"./arrayContainsObject\"));\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\n\nvar _unique = _interopRequireDefault(require(\"./unique\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction opFromJSON(json\n/*: { [key: string]: any }*/\n)\n/*: ?Op*/\n{\n  if (!json || !json.__op) {\n    return null;\n  }\n\n  switch (json.__op) {\n    case 'Delete':\n      return new UnsetOp();\n\n    case 'Increment':\n      return new IncrementOp(json.amount);\n\n    case 'Add':\n      return new AddOp((0, _decode.default)(json.objects));\n\n    case 'AddUnique':\n      return new AddUniqueOp((0, _decode.default)(json.objects));\n\n    case 'Remove':\n      return new RemoveOp((0, _decode.default)(json.objects));\n\n    case 'AddRelation':\n      {\n        const toAdd = (0, _decode.default)(json.objects);\n\n        if (!Array.isArray(toAdd)) {\n          return new RelationOp([], []);\n        }\n\n        return new RelationOp(toAdd, []);\n      }\n\n    case 'RemoveRelation':\n      {\n        const toRemove = (0, _decode.default)(json.objects);\n\n        if (!Array.isArray(toRemove)) {\n          return new RelationOp([], []);\n        }\n\n        return new RelationOp([], toRemove);\n      }\n\n    case 'Batch':\n      {\n        let toAdd = [];\n        let toRemove = [];\n\n        for (let i = 0; i < json.ops.length; i++) {\n          if (json.ops[i].__op === 'AddRelation') {\n            toAdd = toAdd.concat((0, _decode.default)(json.ops[i].objects));\n          } else if (json.ops[i].__op === 'RemoveRelation') {\n            toRemove = toRemove.concat((0, _decode.default)(json.ops[i].objects));\n          }\n        }\n\n        return new RelationOp(toAdd, toRemove);\n      }\n\n    default:\n      return null;\n  }\n}\n\nclass Op {\n  // Empty parent class\n  applyTo()\n  /*: mixed*/\n  {}\n  /* eslint-disable-line no-unused-vars */\n\n\n  mergeWith()\n  /*: ?Op*/\n  {}\n  /* eslint-disable-line no-unused-vars */\n\n\n  toJSON()\n  /*: mixed*/\n  {}\n\n}\n\nexports.Op = Op;\n\nclass SetOp extends Op {\n  constructor(value\n  /*: mixed*/\n  ) {\n    super();\n\n    _defineProperty(this, \"_value\", void 0);\n\n    this._value = value;\n  }\n\n  applyTo()\n  /*: mixed*/\n  {\n    return this._value;\n  }\n\n  mergeWith()\n  /*: SetOp*/\n  {\n    return new SetOp(this._value);\n  }\n\n  toJSON(offline\n  /*:: ?: boolean*/\n  ) {\n    return (0, _encode.default)(this._value, false, true, undefined, offline);\n  }\n\n}\n\nexports.SetOp = SetOp;\n\nclass UnsetOp extends Op {\n  applyTo() {\n    return undefined;\n  }\n\n  mergeWith()\n  /*: UnsetOp*/\n  {\n    return new UnsetOp();\n  }\n\n  toJSON()\n  /*: { __op: string }*/\n  {\n    return {\n      __op: 'Delete'\n    };\n  }\n\n}\n\nexports.UnsetOp = UnsetOp;\n\nclass IncrementOp extends Op {\n  constructor(amount\n  /*: number*/\n  ) {\n    super();\n\n    _defineProperty(this, \"_amount\", void 0);\n\n    if (typeof amount !== 'number') {\n      throw new TypeError('Increment Op must be initialized with a numeric amount.');\n    }\n\n    this._amount = amount;\n  }\n\n  applyTo(value\n  /*: ?mixed*/\n  )\n  /*: number*/\n  {\n    if (typeof value === 'undefined') {\n      return this._amount;\n    }\n\n    if (typeof value !== 'number') {\n      throw new TypeError('Cannot increment a non-numeric value.');\n    }\n\n    return this._amount + value;\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof SetOp) {\n      return new SetOp(this.applyTo(previous._value));\n    }\n\n    if (previous instanceof UnsetOp) {\n      return new SetOp(this._amount);\n    }\n\n    if (previous instanceof IncrementOp) {\n      return new IncrementOp(this.applyTo(previous._amount));\n    }\n\n    throw new Error('Cannot merge Increment Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op: string, amount: number }*/\n  {\n    return {\n      __op: 'Increment',\n      amount: this._amount\n    };\n  }\n\n}\n\nexports.IncrementOp = IncrementOp;\n\nclass AddOp extends Op {\n  constructor(value\n  /*: mixed | Array<mixed>*/\n  ) {\n    super();\n\n    _defineProperty(this, \"_value\", void 0);\n\n    this._value = Array.isArray(value) ? value : [value];\n  }\n\n  applyTo(value\n  /*: mixed*/\n  )\n  /*: Array<mixed>*/\n  {\n    if (value == null) {\n      return this._value;\n    }\n\n    if (Array.isArray(value)) {\n      return value.concat(this._value);\n    }\n\n    throw new Error('Cannot add elements to a non-array value');\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof SetOp) {\n      return new SetOp(this.applyTo(previous._value));\n    }\n\n    if (previous instanceof UnsetOp) {\n      return new SetOp(this._value);\n    }\n\n    if (previous instanceof AddOp) {\n      return new AddOp(this.applyTo(previous._value));\n    }\n\n    throw new Error('Cannot merge Add Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op: string, objects: mixed }*/\n  {\n    return {\n      __op: 'Add',\n      objects: (0, _encode.default)(this._value, false, true)\n    };\n  }\n\n}\n\nexports.AddOp = AddOp;\n\nclass AddUniqueOp extends Op {\n  constructor(value\n  /*: mixed | Array<mixed>*/\n  ) {\n    super();\n\n    _defineProperty(this, \"_value\", void 0);\n\n    this._value = (0, _unique.default)(Array.isArray(value) ? value : [value]);\n  }\n\n  applyTo(value\n  /*: mixed | Array<mixed>*/\n  )\n  /*: Array<mixed>*/\n  {\n    if (value == null) {\n      return this._value || [];\n    }\n\n    if (Array.isArray(value)) {\n      const toAdd = [];\n\n      this._value.forEach(v => {\n        if (v instanceof _ParseObject.default) {\n          if (!(0, _arrayContainsObject.default)(value, v)) {\n            toAdd.push(v);\n          }\n        } else {\n          if (value.indexOf(v) < 0) {\n            toAdd.push(v);\n          }\n        }\n      });\n\n      return value.concat(toAdd);\n    }\n\n    throw new Error('Cannot add elements to a non-array value');\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof SetOp) {\n      return new SetOp(this.applyTo(previous._value));\n    }\n\n    if (previous instanceof UnsetOp) {\n      return new SetOp(this._value);\n    }\n\n    if (previous instanceof AddUniqueOp) {\n      return new AddUniqueOp(this.applyTo(previous._value));\n    }\n\n    throw new Error('Cannot merge AddUnique Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op: string, objects: mixed }*/\n  {\n    return {\n      __op: 'AddUnique',\n      objects: (0, _encode.default)(this._value, false, true)\n    };\n  }\n\n}\n\nexports.AddUniqueOp = AddUniqueOp;\n\nclass RemoveOp extends Op {\n  constructor(value\n  /*: mixed | Array<mixed>*/\n  ) {\n    super();\n\n    _defineProperty(this, \"_value\", void 0);\n\n    this._value = (0, _unique.default)(Array.isArray(value) ? value : [value]);\n  }\n\n  applyTo(value\n  /*: mixed | Array<mixed>*/\n  )\n  /*: Array<mixed>*/\n  {\n    if (value == null) {\n      return [];\n    }\n\n    if (Array.isArray(value)) {\n      // var i = value.indexOf(this._value);\n      const removed = value.concat([]);\n\n      for (let i = 0; i < this._value.length; i++) {\n        let index = removed.indexOf(this._value[i]);\n\n        while (index > -1) {\n          removed.splice(index, 1);\n          index = removed.indexOf(this._value[i]);\n        }\n\n        if (this._value[i] instanceof _ParseObject.default && this._value[i].id) {\n          for (let j = 0; j < removed.length; j++) {\n            if (removed[j] instanceof _ParseObject.default && this._value[i].id === removed[j].id) {\n              removed.splice(j, 1);\n              j--;\n            }\n          }\n        }\n      }\n\n      return removed;\n    }\n\n    throw new Error('Cannot remove elements from a non-array value');\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof SetOp) {\n      return new SetOp(this.applyTo(previous._value));\n    }\n\n    if (previous instanceof UnsetOp) {\n      return new UnsetOp();\n    }\n\n    if (previous instanceof RemoveOp) {\n      const uniques = previous._value.concat([]);\n\n      for (let i = 0; i < this._value.length; i++) {\n        if (this._value[i] instanceof _ParseObject.default) {\n          if (!(0, _arrayContainsObject.default)(uniques, this._value[i])) {\n            uniques.push(this._value[i]);\n          }\n        } else {\n          if (uniques.indexOf(this._value[i]) < 0) {\n            uniques.push(this._value[i]);\n          }\n        }\n      }\n\n      return new RemoveOp(uniques);\n    }\n\n    throw new Error('Cannot merge Remove Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op: string, objects: mixed }*/\n  {\n    return {\n      __op: 'Remove',\n      objects: (0, _encode.default)(this._value, false, true)\n    };\n  }\n\n}\n\nexports.RemoveOp = RemoveOp;\n\nclass RelationOp extends Op {\n  constructor(adds\n  /*: Array<ParseObject | string>*/\n  , removes\n  /*: Array<ParseObject | string>*/\n  ) {\n    super();\n\n    _defineProperty(this, \"_targetClassName\", void 0);\n\n    _defineProperty(this, \"relationsToAdd\", void 0);\n\n    _defineProperty(this, \"relationsToRemove\", void 0);\n\n    this._targetClassName = null;\n\n    if (Array.isArray(adds)) {\n      this.relationsToAdd = (0, _unique.default)(adds.map(this._extractId, this));\n    }\n\n    if (Array.isArray(removes)) {\n      this.relationsToRemove = (0, _unique.default)(removes.map(this._extractId, this));\n    }\n  }\n\n  _extractId(obj\n  /*: string | ParseObject*/\n  )\n  /*: string*/\n  {\n    if (typeof obj === 'string') {\n      return obj;\n    }\n\n    if (!obj.id) {\n      throw new Error('You cannot add or remove an unsaved Parse Object from a relation');\n    }\n\n    if (!this._targetClassName) {\n      this._targetClassName = obj.className;\n    }\n\n    if (this._targetClassName !== obj.className) {\n      throw new Error(`Tried to create a Relation with 2 different object types: ${this._targetClassName} and ${obj.className}.`);\n    }\n\n    return obj.id;\n  }\n\n  applyTo(value\n  /*: mixed*/\n  , object\n  /*:: ?: { className: string, id: ?string }*/\n  , key\n  /*:: ?: string*/\n  )\n  /*: ?ParseRelation*/\n  {\n    if (!value) {\n      if (!object || !key) {\n        throw new Error('Cannot apply a RelationOp without either a previous value, or an object and a key');\n      }\n\n      const parent = new _ParseObject.default(object.className);\n\n      if (object.id && object.id.indexOf('local') === 0) {\n        parent._localId = object.id;\n      } else if (object.id) {\n        parent.id = object.id;\n      }\n\n      const relation = new _ParseRelation.default(parent, key);\n      relation.targetClassName = this._targetClassName;\n      return relation;\n    }\n\n    if (value instanceof _ParseRelation.default) {\n      if (this._targetClassName) {\n        if (value.targetClassName) {\n          if (this._targetClassName !== value.targetClassName) {\n            throw new Error(`Related object must be a ${value.targetClassName}, but a ${this._targetClassName} was passed in.`);\n          }\n        } else {\n          value.targetClassName = this._targetClassName;\n        }\n      }\n\n      return value;\n    }\n\n    throw new Error('Relation cannot be applied to a non-relation field');\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof UnsetOp) {\n      throw new Error('You cannot modify a relation after deleting it.');\n    }\n\n    if (previous instanceof SetOp && previous._value instanceof _ParseRelation.default) {\n      return this;\n    }\n\n    if (previous instanceof RelationOp) {\n      if (previous._targetClassName && previous._targetClassName !== this._targetClassName) {\n        throw new Error(`Related object must be of class ${previous._targetClassName}, but ${this._targetClassName || 'null'} was passed in.`);\n      }\n\n      const newAdd = previous.relationsToAdd.concat([]);\n      this.relationsToRemove.forEach(r => {\n        const index = newAdd.indexOf(r);\n\n        if (index > -1) {\n          newAdd.splice(index, 1);\n        }\n      });\n      this.relationsToAdd.forEach(r => {\n        const index = newAdd.indexOf(r);\n\n        if (index < 0) {\n          newAdd.push(r);\n        }\n      });\n      const newRemove = previous.relationsToRemove.concat([]);\n      this.relationsToAdd.forEach(r => {\n        const index = newRemove.indexOf(r);\n\n        if (index > -1) {\n          newRemove.splice(index, 1);\n        }\n      });\n      this.relationsToRemove.forEach(r => {\n        const index = newRemove.indexOf(r);\n\n        if (index < 0) {\n          newRemove.push(r);\n        }\n      });\n      const newRelation = new RelationOp(newAdd, newRemove);\n      newRelation._targetClassName = this._targetClassName;\n      return newRelation;\n    }\n\n    throw new Error('Cannot merge Relation Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op?: string, objects?: mixed, ops?: mixed }*/\n  {\n    const idToPointer = id => {\n      return {\n        __type: 'Pointer',\n        className: this._targetClassName,\n        objectId: id\n      };\n    };\n\n    let adds = null;\n    let removes = null;\n    let pointers = null;\n\n    if (this.relationsToAdd.length > 0) {\n      pointers = this.relationsToAdd.map(idToPointer);\n      adds = {\n        __op: 'AddRelation',\n        objects: pointers\n      };\n    }\n\n    if (this.relationsToRemove.length > 0) {\n      pointers = this.relationsToRemove.map(idToPointer);\n      removes = {\n        __op: 'RemoveRelation',\n        objects: pointers\n      };\n    }\n\n    if (adds && removes) {\n      return {\n        __op: 'Batch',\n        ops: [adds, removes]\n      };\n    }\n\n    return adds || removes || {};\n  }\n\n}\n\nexports.RelationOp = RelationOp;","map":{"version":3,"sources":["S:/final hackathon/nfi3/node_modules/moralis/lib/node/ParseOp.js"],"names":["Object","defineProperty","exports","value","UnsetOp","SetOp","RemoveOp","RelationOp","Op","IncrementOp","AddUniqueOp","AddOp","opFromJSON","_arrayContainsObject","_interopRequireDefault","require","_decode","_encode","_ParseObject","_ParseRelation","_unique","obj","__esModule","default","_defineProperty","key","enumerable","configurable","writable","json","__op","amount","objects","toAdd","Array","isArray","toRemove","i","ops","length","concat","applyTo","mergeWith","toJSON","constructor","_value","offline","undefined","TypeError","_amount","previous","Error","forEach","v","push","indexOf","removed","index","splice","id","j","uniques","adds","removes","_targetClassName","relationsToAdd","map","_extractId","relationsToRemove","className","object","parent","_localId","relation","targetClassName","newAdd","r","newRemove","newRelation","idToPointer","__type","objectId","pointers"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnsetOp = exports.SetOp = exports.RemoveOp = exports.RelationOp = exports.Op = exports.IncrementOp = exports.AddUniqueOp = exports.AddOp = void 0;\nexports.opFromJSON = opFromJSON;\n\nvar _arrayContainsObject = _interopRequireDefault(require(\"./arrayContainsObject\"));\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\n\nvar _unique = _interopRequireDefault(require(\"./unique\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction opFromJSON(json\n/*: { [key: string]: any }*/\n)\n/*: ?Op*/\n{\n  if (!json || !json.__op) {\n    return null;\n  }\n\n  switch (json.__op) {\n    case 'Delete':\n      return new UnsetOp();\n\n    case 'Increment':\n      return new IncrementOp(json.amount);\n\n    case 'Add':\n      return new AddOp((0, _decode.default)(json.objects));\n\n    case 'AddUnique':\n      return new AddUniqueOp((0, _decode.default)(json.objects));\n\n    case 'Remove':\n      return new RemoveOp((0, _decode.default)(json.objects));\n\n    case 'AddRelation':\n      {\n        const toAdd = (0, _decode.default)(json.objects);\n\n        if (!Array.isArray(toAdd)) {\n          return new RelationOp([], []);\n        }\n\n        return new RelationOp(toAdd, []);\n      }\n\n    case 'RemoveRelation':\n      {\n        const toRemove = (0, _decode.default)(json.objects);\n\n        if (!Array.isArray(toRemove)) {\n          return new RelationOp([], []);\n        }\n\n        return new RelationOp([], toRemove);\n      }\n\n    case 'Batch':\n      {\n        let toAdd = [];\n        let toRemove = [];\n\n        for (let i = 0; i < json.ops.length; i++) {\n          if (json.ops[i].__op === 'AddRelation') {\n            toAdd = toAdd.concat((0, _decode.default)(json.ops[i].objects));\n          } else if (json.ops[i].__op === 'RemoveRelation') {\n            toRemove = toRemove.concat((0, _decode.default)(json.ops[i].objects));\n          }\n        }\n\n        return new RelationOp(toAdd, toRemove);\n      }\n\n    default:\n      return null;\n  }\n}\n\nclass Op {\n  // Empty parent class\n  applyTo()\n  /*: mixed*/\n  {}\n  /* eslint-disable-line no-unused-vars */\n\n\n  mergeWith()\n  /*: ?Op*/\n  {}\n  /* eslint-disable-line no-unused-vars */\n\n\n  toJSON()\n  /*: mixed*/\n  {}\n\n}\n\nexports.Op = Op;\n\nclass SetOp extends Op {\n  constructor(value\n  /*: mixed*/\n  ) {\n    super();\n\n    _defineProperty(this, \"_value\", void 0);\n\n    this._value = value;\n  }\n\n  applyTo()\n  /*: mixed*/\n  {\n    return this._value;\n  }\n\n  mergeWith()\n  /*: SetOp*/\n  {\n    return new SetOp(this._value);\n  }\n\n  toJSON(offline\n  /*:: ?: boolean*/\n  ) {\n    return (0, _encode.default)(this._value, false, true, undefined, offline);\n  }\n\n}\n\nexports.SetOp = SetOp;\n\nclass UnsetOp extends Op {\n  applyTo() {\n    return undefined;\n  }\n\n  mergeWith()\n  /*: UnsetOp*/\n  {\n    return new UnsetOp();\n  }\n\n  toJSON()\n  /*: { __op: string }*/\n  {\n    return {\n      __op: 'Delete'\n    };\n  }\n\n}\n\nexports.UnsetOp = UnsetOp;\n\nclass IncrementOp extends Op {\n  constructor(amount\n  /*: number*/\n  ) {\n    super();\n\n    _defineProperty(this, \"_amount\", void 0);\n\n    if (typeof amount !== 'number') {\n      throw new TypeError('Increment Op must be initialized with a numeric amount.');\n    }\n\n    this._amount = amount;\n  }\n\n  applyTo(value\n  /*: ?mixed*/\n  )\n  /*: number*/\n  {\n    if (typeof value === 'undefined') {\n      return this._amount;\n    }\n\n    if (typeof value !== 'number') {\n      throw new TypeError('Cannot increment a non-numeric value.');\n    }\n\n    return this._amount + value;\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof SetOp) {\n      return new SetOp(this.applyTo(previous._value));\n    }\n\n    if (previous instanceof UnsetOp) {\n      return new SetOp(this._amount);\n    }\n\n    if (previous instanceof IncrementOp) {\n      return new IncrementOp(this.applyTo(previous._amount));\n    }\n\n    throw new Error('Cannot merge Increment Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op: string, amount: number }*/\n  {\n    return {\n      __op: 'Increment',\n      amount: this._amount\n    };\n  }\n\n}\n\nexports.IncrementOp = IncrementOp;\n\nclass AddOp extends Op {\n  constructor(value\n  /*: mixed | Array<mixed>*/\n  ) {\n    super();\n\n    _defineProperty(this, \"_value\", void 0);\n\n    this._value = Array.isArray(value) ? value : [value];\n  }\n\n  applyTo(value\n  /*: mixed*/\n  )\n  /*: Array<mixed>*/\n  {\n    if (value == null) {\n      return this._value;\n    }\n\n    if (Array.isArray(value)) {\n      return value.concat(this._value);\n    }\n\n    throw new Error('Cannot add elements to a non-array value');\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof SetOp) {\n      return new SetOp(this.applyTo(previous._value));\n    }\n\n    if (previous instanceof UnsetOp) {\n      return new SetOp(this._value);\n    }\n\n    if (previous instanceof AddOp) {\n      return new AddOp(this.applyTo(previous._value));\n    }\n\n    throw new Error('Cannot merge Add Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op: string, objects: mixed }*/\n  {\n    return {\n      __op: 'Add',\n      objects: (0, _encode.default)(this._value, false, true)\n    };\n  }\n\n}\n\nexports.AddOp = AddOp;\n\nclass AddUniqueOp extends Op {\n  constructor(value\n  /*: mixed | Array<mixed>*/\n  ) {\n    super();\n\n    _defineProperty(this, \"_value\", void 0);\n\n    this._value = (0, _unique.default)(Array.isArray(value) ? value : [value]);\n  }\n\n  applyTo(value\n  /*: mixed | Array<mixed>*/\n  )\n  /*: Array<mixed>*/\n  {\n    if (value == null) {\n      return this._value || [];\n    }\n\n    if (Array.isArray(value)) {\n      const toAdd = [];\n\n      this._value.forEach(v => {\n        if (v instanceof _ParseObject.default) {\n          if (!(0, _arrayContainsObject.default)(value, v)) {\n            toAdd.push(v);\n          }\n        } else {\n          if (value.indexOf(v) < 0) {\n            toAdd.push(v);\n          }\n        }\n      });\n\n      return value.concat(toAdd);\n    }\n\n    throw new Error('Cannot add elements to a non-array value');\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof SetOp) {\n      return new SetOp(this.applyTo(previous._value));\n    }\n\n    if (previous instanceof UnsetOp) {\n      return new SetOp(this._value);\n    }\n\n    if (previous instanceof AddUniqueOp) {\n      return new AddUniqueOp(this.applyTo(previous._value));\n    }\n\n    throw new Error('Cannot merge AddUnique Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op: string, objects: mixed }*/\n  {\n    return {\n      __op: 'AddUnique',\n      objects: (0, _encode.default)(this._value, false, true)\n    };\n  }\n\n}\n\nexports.AddUniqueOp = AddUniqueOp;\n\nclass RemoveOp extends Op {\n  constructor(value\n  /*: mixed | Array<mixed>*/\n  ) {\n    super();\n\n    _defineProperty(this, \"_value\", void 0);\n\n    this._value = (0, _unique.default)(Array.isArray(value) ? value : [value]);\n  }\n\n  applyTo(value\n  /*: mixed | Array<mixed>*/\n  )\n  /*: Array<mixed>*/\n  {\n    if (value == null) {\n      return [];\n    }\n\n    if (Array.isArray(value)) {\n      // var i = value.indexOf(this._value);\n      const removed = value.concat([]);\n\n      for (let i = 0; i < this._value.length; i++) {\n        let index = removed.indexOf(this._value[i]);\n\n        while (index > -1) {\n          removed.splice(index, 1);\n          index = removed.indexOf(this._value[i]);\n        }\n\n        if (this._value[i] instanceof _ParseObject.default && this._value[i].id) {\n          for (let j = 0; j < removed.length; j++) {\n            if (removed[j] instanceof _ParseObject.default && this._value[i].id === removed[j].id) {\n              removed.splice(j, 1);\n              j--;\n            }\n          }\n        }\n      }\n\n      return removed;\n    }\n\n    throw new Error('Cannot remove elements from a non-array value');\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof SetOp) {\n      return new SetOp(this.applyTo(previous._value));\n    }\n\n    if (previous instanceof UnsetOp) {\n      return new UnsetOp();\n    }\n\n    if (previous instanceof RemoveOp) {\n      const uniques = previous._value.concat([]);\n\n      for (let i = 0; i < this._value.length; i++) {\n        if (this._value[i] instanceof _ParseObject.default) {\n          if (!(0, _arrayContainsObject.default)(uniques, this._value[i])) {\n            uniques.push(this._value[i]);\n          }\n        } else {\n          if (uniques.indexOf(this._value[i]) < 0) {\n            uniques.push(this._value[i]);\n          }\n        }\n      }\n\n      return new RemoveOp(uniques);\n    }\n\n    throw new Error('Cannot merge Remove Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op: string, objects: mixed }*/\n  {\n    return {\n      __op: 'Remove',\n      objects: (0, _encode.default)(this._value, false, true)\n    };\n  }\n\n}\n\nexports.RemoveOp = RemoveOp;\n\nclass RelationOp extends Op {\n  constructor(adds\n  /*: Array<ParseObject | string>*/\n  , removes\n  /*: Array<ParseObject | string>*/\n  ) {\n    super();\n\n    _defineProperty(this, \"_targetClassName\", void 0);\n\n    _defineProperty(this, \"relationsToAdd\", void 0);\n\n    _defineProperty(this, \"relationsToRemove\", void 0);\n\n    this._targetClassName = null;\n\n    if (Array.isArray(adds)) {\n      this.relationsToAdd = (0, _unique.default)(adds.map(this._extractId, this));\n    }\n\n    if (Array.isArray(removes)) {\n      this.relationsToRemove = (0, _unique.default)(removes.map(this._extractId, this));\n    }\n  }\n\n  _extractId(obj\n  /*: string | ParseObject*/\n  )\n  /*: string*/\n  {\n    if (typeof obj === 'string') {\n      return obj;\n    }\n\n    if (!obj.id) {\n      throw new Error('You cannot add or remove an unsaved Parse Object from a relation');\n    }\n\n    if (!this._targetClassName) {\n      this._targetClassName = obj.className;\n    }\n\n    if (this._targetClassName !== obj.className) {\n      throw new Error(`Tried to create a Relation with 2 different object types: ${this._targetClassName} and ${obj.className}.`);\n    }\n\n    return obj.id;\n  }\n\n  applyTo(value\n  /*: mixed*/\n  , object\n  /*:: ?: { className: string, id: ?string }*/\n  , key\n  /*:: ?: string*/\n  )\n  /*: ?ParseRelation*/\n  {\n    if (!value) {\n      if (!object || !key) {\n        throw new Error('Cannot apply a RelationOp without either a previous value, or an object and a key');\n      }\n\n      const parent = new _ParseObject.default(object.className);\n\n      if (object.id && object.id.indexOf('local') === 0) {\n        parent._localId = object.id;\n      } else if (object.id) {\n        parent.id = object.id;\n      }\n\n      const relation = new _ParseRelation.default(parent, key);\n      relation.targetClassName = this._targetClassName;\n      return relation;\n    }\n\n    if (value instanceof _ParseRelation.default) {\n      if (this._targetClassName) {\n        if (value.targetClassName) {\n          if (this._targetClassName !== value.targetClassName) {\n            throw new Error(`Related object must be a ${value.targetClassName}, but a ${this._targetClassName} was passed in.`);\n          }\n        } else {\n          value.targetClassName = this._targetClassName;\n        }\n      }\n\n      return value;\n    }\n\n    throw new Error('Relation cannot be applied to a non-relation field');\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof UnsetOp) {\n      throw new Error('You cannot modify a relation after deleting it.');\n    }\n\n    if (previous instanceof SetOp && previous._value instanceof _ParseRelation.default) {\n      return this;\n    }\n\n    if (previous instanceof RelationOp) {\n      if (previous._targetClassName && previous._targetClassName !== this._targetClassName) {\n        throw new Error(`Related object must be of class ${previous._targetClassName}, but ${this._targetClassName || 'null'} was passed in.`);\n      }\n\n      const newAdd = previous.relationsToAdd.concat([]);\n      this.relationsToRemove.forEach(r => {\n        const index = newAdd.indexOf(r);\n\n        if (index > -1) {\n          newAdd.splice(index, 1);\n        }\n      });\n      this.relationsToAdd.forEach(r => {\n        const index = newAdd.indexOf(r);\n\n        if (index < 0) {\n          newAdd.push(r);\n        }\n      });\n      const newRemove = previous.relationsToRemove.concat([]);\n      this.relationsToAdd.forEach(r => {\n        const index = newRemove.indexOf(r);\n\n        if (index > -1) {\n          newRemove.splice(index, 1);\n        }\n      });\n      this.relationsToRemove.forEach(r => {\n        const index = newRemove.indexOf(r);\n\n        if (index < 0) {\n          newRemove.push(r);\n        }\n      });\n      const newRelation = new RelationOp(newAdd, newRemove);\n      newRelation._targetClassName = this._targetClassName;\n      return newRelation;\n    }\n\n    throw new Error('Cannot merge Relation Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op?: string, objects?: mixed, ops?: mixed }*/\n  {\n    const idToPointer = id => {\n      return {\n        __type: 'Pointer',\n        className: this._targetClassName,\n        objectId: id\n      };\n    };\n\n    let adds = null;\n    let removes = null;\n    let pointers = null;\n\n    if (this.relationsToAdd.length > 0) {\n      pointers = this.relationsToAdd.map(idToPointer);\n      adds = {\n        __op: 'AddRelation',\n        objects: pointers\n      };\n    }\n\n    if (this.relationsToRemove.length > 0) {\n      pointers = this.relationsToRemove.map(idToPointer);\n      removes = {\n        __op: 'RemoveRelation',\n        objects: pointers\n      };\n    }\n\n    if (adds && removes) {\n      return {\n        __op: 'Batch',\n        ops: [adds, removes]\n      };\n    }\n\n    return adds || removes || {};\n  }\n\n}\n\nexports.RelationOp = RelationOp;"]},"metadata":{},"sourceType":"script"}