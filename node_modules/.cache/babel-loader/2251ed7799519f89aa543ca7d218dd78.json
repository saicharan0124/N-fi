{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseCLP = _interopRequireDefault(require(\"./ParseCLP\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst FIELD_TYPES = ['String', 'Number', 'Boolean', 'Date', 'File', 'GeoPoint', 'Polygon', 'Array', 'Object', 'Pointer', 'Relation'];\n/*:: type FieldOptions = {\n  required: boolean,\n  defaultValue: mixed,\n};*/\n\n/**\n * A Parse.Schema object is for handling schema data from Parse.\n * <p>All the schemas methods require MasterKey.\n *\n * When adding fields, you may set required and default values. (Requires Parse Server 3.7.0+)\n *\n * <pre>\n * const options = { required: true, defaultValue: 'hello world' };\n * const schema = new Parse.Schema('MyClass');\n * schema.addString('field', options);\n * schema.addIndex('index_name', { 'field': 1 });\n * schema.save();\n * </pre>\n * </p>\n *\n * @alias Parse.Schema\n */\n\nclass ParseSchema {\n  /**\n   * @param {string} className Parse Class string.\n   */\n  constructor(className\n  /*: string*/\n  ) {\n    _defineProperty(this, \"className\", void 0);\n\n    _defineProperty(this, \"_fields\", void 0);\n\n    _defineProperty(this, \"_indexes\", void 0);\n\n    _defineProperty(this, \"_clp\", void 0);\n\n    if (typeof className === 'string') {\n      if (className === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = className;\n      }\n    }\n\n    this._fields = {};\n    this._indexes = {};\n  }\n  /**\n   * Static method to get all schemas\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  static all() {\n    const controller = _CoreManager.default.getSchemaController();\n\n    return controller.get('').then(response => {\n      if (response.results.length === 0) {\n        throw new Error('Schema not found.');\n      }\n\n      return response.results;\n    });\n  }\n  /**\n   * Get the Schema from Parse\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  get() {\n    this.assertClassName();\n\n    const controller = _CoreManager.default.getSchemaController();\n\n    return controller.get(this.className).then(response => {\n      if (!response) {\n        throw new Error('Schema not found.');\n      }\n\n      return response;\n    });\n  }\n  /**\n   * Create a new Schema on Parse\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  save() {\n    this.assertClassName();\n\n    const controller = _CoreManager.default.getSchemaController();\n\n    const params = {\n      className: this.className,\n      fields: this._fields,\n      indexes: this._indexes,\n      classLevelPermissions: this._clp\n    };\n    return controller.create(this.className, params);\n  }\n  /**\n   * Update a Schema on Parse\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  update() {\n    this.assertClassName();\n\n    const controller = _CoreManager.default.getSchemaController();\n\n    const params = {\n      className: this.className,\n      fields: this._fields,\n      indexes: this._indexes,\n      classLevelPermissions: this._clp\n    };\n    this._fields = {};\n    this._indexes = {};\n    return controller.update(this.className, params);\n  }\n  /**\n   * Removing a Schema from Parse\n   * Can only be used on Schema without objects\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  delete() {\n    this.assertClassName();\n\n    const controller = _CoreManager.default.getSchemaController();\n\n    return controller.delete(this.className);\n  }\n  /**\n   * Removes all objects from a Schema (class) in Parse.\n   * EXERCISE CAUTION, running this will delete all objects for this schema and cannot be reversed\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  purge() {\n    this.assertClassName();\n\n    const controller = _CoreManager.default.getSchemaController();\n\n    return controller.purge(this.className);\n  }\n  /**\n   * Assert if ClassName has been filled\n   *\n   * @private\n   */\n\n\n  assertClassName() {\n    if (!this.className) {\n      throw new Error('You must set a Class Name before making any request.');\n    }\n  }\n  /**\n   * Sets Class Level Permissions when creating / updating a Schema.\n   * EXERCISE CAUTION, running this may override CLP for this schema and cannot be reversed\n   *\n   * @param {object | Parse.CLP} clp Class Level Permissions\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  setCLP(clp\n  /*: PermissionsMap | ParseCLP*/\n  ) {\n    if (clp instanceof _ParseCLP.default) {\n      this._clp = clp.toJSON();\n    } else {\n      this._clp = clp;\n    }\n\n    return this;\n  }\n  /**\n   * Adding a Field to Create / Update a Schema\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {string} type Can be a (String|Number|Boolean|Date|Parse.File|Parse.GeoPoint|Array|Object|Pointer|Parse.Relation)\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>required: If field is not set, save operation fails (Requires Parse Server 3.7.0+)\n   *   <li>defaultValue: If field is not set, a default value is selected (Requires Parse Server 3.7.0+)\n   * </ul>\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addField(name\n  /*: string*/\n  , type\n  /*: string*/\n  ) {\n    let options\n    /*: FieldOptions*/\n    = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    type = type || 'String';\n\n    if (!name) {\n      throw new Error('field name may not be null.');\n    }\n\n    if (FIELD_TYPES.indexOf(type) === -1) {\n      throw new Error(`${type} is not a valid type.`);\n    }\n\n    const fieldOptions = {\n      type\n    };\n\n    if (typeof options.required === 'boolean') {\n      fieldOptions.required = options.required;\n    }\n\n    if (options.defaultValue !== undefined) {\n      fieldOptions.defaultValue = options.defaultValue;\n    }\n\n    this._fields[name] = fieldOptions;\n    return this;\n  }\n  /**\n   * Adding an Index to Create / Update a Schema\n   *\n   * @param {string} name Name of the index\n   * @param {object} index { field: value }\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   *\n   * <pre>\n   * schema.addIndex('index_name', { 'field': 1 });\n   * </pre>\n   */\n\n\n  addIndex(name\n  /*: string*/\n  , index\n  /*: any*/\n  ) {\n    if (!name) {\n      throw new Error('index name may not be null.');\n    }\n\n    if (!index) {\n      throw new Error('index may not be null.');\n    }\n\n    this._indexes[name] = index;\n    return this;\n  }\n  /**\n   * Adding String Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addString(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    return this.addField(name, 'String', options);\n  }\n  /**\n   * Adding Number Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addNumber(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    return this.addField(name, 'Number', options);\n  }\n  /**\n   * Adding Boolean Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addBoolean(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    return this.addField(name, 'Boolean', options);\n  }\n  /**\n   * Adding Date Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addDate(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    if (options && options.defaultValue) {\n      options.defaultValue = {\n        __type: 'Date',\n        iso: new Date(options.defaultValue)\n      };\n    }\n\n    return this.addField(name, 'Date', options);\n  }\n  /**\n   * Adding File Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addFile(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    return this.addField(name, 'File', options);\n  }\n  /**\n   * Adding GeoPoint Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addGeoPoint(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    return this.addField(name, 'GeoPoint', options);\n  }\n  /**\n   * Adding Polygon Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addPolygon(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    return this.addField(name, 'Polygon', options);\n  }\n  /**\n   * Adding Array Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addArray(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    return this.addField(name, 'Array', options);\n  }\n  /**\n   * Adding Object Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addObject(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    return this.addField(name, 'Object', options);\n  }\n  /**\n   * Adding Pointer Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {string} targetClass Name of the target Pointer Class\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addPointer(name\n  /*: string*/\n  , targetClass\n  /*: string*/\n  ) {\n    let options\n    /*: FieldOptions*/\n    = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!name) {\n      throw new Error('field name may not be null.');\n    }\n\n    if (!targetClass) {\n      throw new Error('You need to set the targetClass of the Pointer.');\n    }\n\n    const fieldOptions = {\n      type: 'Pointer',\n      targetClass\n    };\n\n    if (typeof options.required === 'boolean') {\n      fieldOptions.required = options.required;\n    }\n\n    if (options.defaultValue !== undefined) {\n      fieldOptions.defaultValue = options.defaultValue;\n\n      if (options.defaultValue instanceof _ParseObject.default) {\n        fieldOptions.defaultValue = options.defaultValue.toPointer();\n      }\n    }\n\n    this._fields[name] = fieldOptions;\n    return this;\n  }\n  /**\n   * Adding Relation Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {string} targetClass Name of the target Pointer Class\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addRelation(name\n  /*: string*/\n  , targetClass\n  /*: string*/\n  ) {\n    if (!name) {\n      throw new Error('field name may not be null.');\n    }\n\n    if (!targetClass) {\n      throw new Error('You need to set the targetClass of the Relation.');\n    }\n\n    this._fields[name] = {\n      type: 'Relation',\n      targetClass\n    };\n    return this;\n  }\n  /**\n   * Deleting a Field to Update on a Schema\n   *\n   * @param {string} name Name of the field\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  deleteField(name\n  /*: string*/\n  ) {\n    this._fields[name] = {\n      __op: 'Delete'\n    };\n    return this;\n  }\n  /**\n   * Deleting an Index to Update on a Schema\n   *\n   * @param {string} name Name of the field\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  deleteIndex(name\n  /*: string*/\n  ) {\n    this._indexes[name] = {\n      __op: 'Delete'\n    };\n    return this;\n  }\n\n}\n\nconst DefaultController = {\n  send(className\n  /*: string*/\n  , method\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    let params\n    /*: any*/\n    = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request(method, `schemas/${className}`, params, {\n      useMasterKey: true\n    });\n  },\n\n  get(className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'GET');\n  },\n\n  create(className\n  /*: string*/\n  , params\n  /*: any*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'POST', params);\n  },\n\n  update(className\n  /*: string*/\n  , params\n  /*: any*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'PUT', params);\n  },\n\n  delete(className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'DELETE');\n  },\n\n  purge(className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('DELETE', `purge/${className}`, {}, {\n      useMasterKey: true\n    });\n  }\n\n};\n\n_CoreManager.default.setSchemaController(DefaultController);\n\nvar _default = ParseSchema;\nexports.default = _default;","map":{"version":3,"sources":["S:/final hackathon/nfi3/node_modules/moralis/lib/node/ParseSchema.js"],"names":["Object","defineProperty","exports","value","default","_CoreManager","_interopRequireDefault","require","_ParseObject","_ParseCLP","obj","__esModule","_defineProperty","key","enumerable","configurable","writable","FIELD_TYPES","ParseSchema","constructor","className","get","_fields","_indexes","all","controller","getSchemaController","then","response","results","length","Error","assertClassName","save","params","fields","indexes","classLevelPermissions","_clp","create","update","delete","purge","setCLP","clp","toJSON","addField","name","type","options","indexOf","fieldOptions","required","defaultValue","undefined","addIndex","index","addString","addNumber","addBoolean","addDate","__type","iso","Date","addFile","addGeoPoint","addPolygon","addArray","addObject","addPointer","targetClass","toPointer","addRelation","deleteField","__op","deleteIndex","DefaultController","send","method","RESTController","getRESTController","request","useMasterKey","setSchemaController","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseCLP = _interopRequireDefault(require(\"./ParseCLP\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst FIELD_TYPES = ['String', 'Number', 'Boolean', 'Date', 'File', 'GeoPoint', 'Polygon', 'Array', 'Object', 'Pointer', 'Relation'];\n/*:: type FieldOptions = {\n  required: boolean,\n  defaultValue: mixed,\n};*/\n\n/**\n * A Parse.Schema object is for handling schema data from Parse.\n * <p>All the schemas methods require MasterKey.\n *\n * When adding fields, you may set required and default values. (Requires Parse Server 3.7.0+)\n *\n * <pre>\n * const options = { required: true, defaultValue: 'hello world' };\n * const schema = new Parse.Schema('MyClass');\n * schema.addString('field', options);\n * schema.addIndex('index_name', { 'field': 1 });\n * schema.save();\n * </pre>\n * </p>\n *\n * @alias Parse.Schema\n */\n\nclass ParseSchema {\n  /**\n   * @param {string} className Parse Class string.\n   */\n  constructor(className\n  /*: string*/\n  ) {\n    _defineProperty(this, \"className\", void 0);\n\n    _defineProperty(this, \"_fields\", void 0);\n\n    _defineProperty(this, \"_indexes\", void 0);\n\n    _defineProperty(this, \"_clp\", void 0);\n\n    if (typeof className === 'string') {\n      if (className === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = className;\n      }\n    }\n\n    this._fields = {};\n    this._indexes = {};\n  }\n  /**\n   * Static method to get all schemas\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  static all() {\n    const controller = _CoreManager.default.getSchemaController();\n\n    return controller.get('').then(response => {\n      if (response.results.length === 0) {\n        throw new Error('Schema not found.');\n      }\n\n      return response.results;\n    });\n  }\n  /**\n   * Get the Schema from Parse\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  get() {\n    this.assertClassName();\n\n    const controller = _CoreManager.default.getSchemaController();\n\n    return controller.get(this.className).then(response => {\n      if (!response) {\n        throw new Error('Schema not found.');\n      }\n\n      return response;\n    });\n  }\n  /**\n   * Create a new Schema on Parse\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  save() {\n    this.assertClassName();\n\n    const controller = _CoreManager.default.getSchemaController();\n\n    const params = {\n      className: this.className,\n      fields: this._fields,\n      indexes: this._indexes,\n      classLevelPermissions: this._clp\n    };\n    return controller.create(this.className, params);\n  }\n  /**\n   * Update a Schema on Parse\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  update() {\n    this.assertClassName();\n\n    const controller = _CoreManager.default.getSchemaController();\n\n    const params = {\n      className: this.className,\n      fields: this._fields,\n      indexes: this._indexes,\n      classLevelPermissions: this._clp\n    };\n    this._fields = {};\n    this._indexes = {};\n    return controller.update(this.className, params);\n  }\n  /**\n   * Removing a Schema from Parse\n   * Can only be used on Schema without objects\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  delete() {\n    this.assertClassName();\n\n    const controller = _CoreManager.default.getSchemaController();\n\n    return controller.delete(this.className);\n  }\n  /**\n   * Removes all objects from a Schema (class) in Parse.\n   * EXERCISE CAUTION, running this will delete all objects for this schema and cannot be reversed\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  purge() {\n    this.assertClassName();\n\n    const controller = _CoreManager.default.getSchemaController();\n\n    return controller.purge(this.className);\n  }\n  /**\n   * Assert if ClassName has been filled\n   *\n   * @private\n   */\n\n\n  assertClassName() {\n    if (!this.className) {\n      throw new Error('You must set a Class Name before making any request.');\n    }\n  }\n  /**\n   * Sets Class Level Permissions when creating / updating a Schema.\n   * EXERCISE CAUTION, running this may override CLP for this schema and cannot be reversed\n   *\n   * @param {object | Parse.CLP} clp Class Level Permissions\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  setCLP(clp\n  /*: PermissionsMap | ParseCLP*/\n  ) {\n    if (clp instanceof _ParseCLP.default) {\n      this._clp = clp.toJSON();\n    } else {\n      this._clp = clp;\n    }\n\n    return this;\n  }\n  /**\n   * Adding a Field to Create / Update a Schema\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {string} type Can be a (String|Number|Boolean|Date|Parse.File|Parse.GeoPoint|Array|Object|Pointer|Parse.Relation)\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>required: If field is not set, save operation fails (Requires Parse Server 3.7.0+)\n   *   <li>defaultValue: If field is not set, a default value is selected (Requires Parse Server 3.7.0+)\n   * </ul>\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addField(name\n  /*: string*/\n  , type\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  = {}) {\n    type = type || 'String';\n\n    if (!name) {\n      throw new Error('field name may not be null.');\n    }\n\n    if (FIELD_TYPES.indexOf(type) === -1) {\n      throw new Error(`${type} is not a valid type.`);\n    }\n\n    const fieldOptions = {\n      type\n    };\n\n    if (typeof options.required === 'boolean') {\n      fieldOptions.required = options.required;\n    }\n\n    if (options.defaultValue !== undefined) {\n      fieldOptions.defaultValue = options.defaultValue;\n    }\n\n    this._fields[name] = fieldOptions;\n    return this;\n  }\n  /**\n   * Adding an Index to Create / Update a Schema\n   *\n   * @param {string} name Name of the index\n   * @param {object} index { field: value }\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   *\n   * <pre>\n   * schema.addIndex('index_name', { 'field': 1 });\n   * </pre>\n   */\n\n\n  addIndex(name\n  /*: string*/\n  , index\n  /*: any*/\n  ) {\n    if (!name) {\n      throw new Error('index name may not be null.');\n    }\n\n    if (!index) {\n      throw new Error('index may not be null.');\n    }\n\n    this._indexes[name] = index;\n    return this;\n  }\n  /**\n   * Adding String Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addString(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    return this.addField(name, 'String', options);\n  }\n  /**\n   * Adding Number Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addNumber(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    return this.addField(name, 'Number', options);\n  }\n  /**\n   * Adding Boolean Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addBoolean(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    return this.addField(name, 'Boolean', options);\n  }\n  /**\n   * Adding Date Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addDate(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    if (options && options.defaultValue) {\n      options.defaultValue = {\n        __type: 'Date',\n        iso: new Date(options.defaultValue)\n      };\n    }\n\n    return this.addField(name, 'Date', options);\n  }\n  /**\n   * Adding File Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addFile(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    return this.addField(name, 'File', options);\n  }\n  /**\n   * Adding GeoPoint Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addGeoPoint(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    return this.addField(name, 'GeoPoint', options);\n  }\n  /**\n   * Adding Polygon Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addPolygon(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    return this.addField(name, 'Polygon', options);\n  }\n  /**\n   * Adding Array Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addArray(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    return this.addField(name, 'Array', options);\n  }\n  /**\n   * Adding Object Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addObject(name\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  ) {\n    return this.addField(name, 'Object', options);\n  }\n  /**\n   * Adding Pointer Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {string} targetClass Name of the target Pointer Class\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addPointer(name\n  /*: string*/\n  , targetClass\n  /*: string*/\n  , options\n  /*: FieldOptions*/\n  = {}) {\n    if (!name) {\n      throw new Error('field name may not be null.');\n    }\n\n    if (!targetClass) {\n      throw new Error('You need to set the targetClass of the Pointer.');\n    }\n\n    const fieldOptions = {\n      type: 'Pointer',\n      targetClass\n    };\n\n    if (typeof options.required === 'boolean') {\n      fieldOptions.required = options.required;\n    }\n\n    if (options.defaultValue !== undefined) {\n      fieldOptions.defaultValue = options.defaultValue;\n\n      if (options.defaultValue instanceof _ParseObject.default) {\n        fieldOptions.defaultValue = options.defaultValue.toPointer();\n      }\n    }\n\n    this._fields[name] = fieldOptions;\n    return this;\n  }\n  /**\n   * Adding Relation Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {string} targetClass Name of the target Pointer Class\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  addRelation(name\n  /*: string*/\n  , targetClass\n  /*: string*/\n  ) {\n    if (!name) {\n      throw new Error('field name may not be null.');\n    }\n\n    if (!targetClass) {\n      throw new Error('You need to set the targetClass of the Relation.');\n    }\n\n    this._fields[name] = {\n      type: 'Relation',\n      targetClass\n    };\n    return this;\n  }\n  /**\n   * Deleting a Field to Update on a Schema\n   *\n   * @param {string} name Name of the field\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  deleteField(name\n  /*: string*/\n  ) {\n    this._fields[name] = {\n      __op: 'Delete'\n    };\n    return this;\n  }\n  /**\n   * Deleting an Index to Update on a Schema\n   *\n   * @param {string} name Name of the field\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n\n\n  deleteIndex(name\n  /*: string*/\n  ) {\n    this._indexes[name] = {\n      __op: 'Delete'\n    };\n    return this;\n  }\n\n}\n\nconst DefaultController = {\n  send(className\n  /*: string*/\n  , method\n  /*: string*/\n  , params\n  /*: any*/\n  = {})\n  /*: Promise*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request(method, `schemas/${className}`, params, {\n      useMasterKey: true\n    });\n  },\n\n  get(className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'GET');\n  },\n\n  create(className\n  /*: string*/\n  , params\n  /*: any*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'POST', params);\n  },\n\n  update(className\n  /*: string*/\n  , params\n  /*: any*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'PUT', params);\n  },\n\n  delete(className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'DELETE');\n  },\n\n  purge(className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('DELETE', `purge/${className}`, {}, {\n      useMasterKey: true\n    });\n  }\n\n};\n\n_CoreManager.default.setSchemaController(DefaultController);\n\nvar _default = ParseSchema;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}