{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _escape = _interopRequireDefault(require(\"./escape\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Parse.Config is a local representation of configuration data that\n * can be set from the Parse dashboard.\n *\n * @alias Parse.Config\n */\n\n\nclass ParseConfig {\n  constructor() {\n    _defineProperty(this, \"attributes\", void 0);\n\n    _defineProperty(this, \"_escapedAttributes\", void 0);\n\n    this.attributes = {};\n    this._escapedAttributes = {};\n  }\n  /**\n   * Gets the value of an attribute.\n   *\n   * @param {string} attr The name of an attribute.\n   * @returns {*}\n   */\n\n\n  get(attr\n  /*: string*/\n  )\n  /*: any*/\n  {\n    return this.attributes[attr];\n  }\n  /**\n   * Gets the HTML-escaped value of an attribute.\n   *\n   * @param {string} attr The name of an attribute.\n   * @returns {string}\n   */\n\n\n  escape(attr\n  /*: string*/\n  )\n  /*: string*/\n  {\n    const html = this._escapedAttributes[attr];\n\n    if (html) {\n      return html;\n    }\n\n    const val = this.attributes[attr];\n    let escaped = '';\n\n    if (val != null) {\n      escaped = (0, _escape.default)(val.toString());\n    }\n\n    this._escapedAttributes[attr] = escaped;\n    return escaped;\n  }\n  /**\n   * Retrieves the most recently-fetched configuration object, either from\n   * memory or from local storage if necessary.\n   *\n   * @static\n   * @returns {Parse.Config} The most recently-fetched Parse.Config if it\n   *     exists, else an empty Parse.Config.\n   */\n\n\n  static current() {\n    const controller = _CoreManager.default.getConfigController();\n\n    return controller.current();\n  }\n  /**\n   * Gets a new configuration object from the server.\n   *\n   * @static\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   * </ul>\n   * @returns {Promise} A promise that is resolved with a newly-created\n   *     configuration object when the get completes.\n   */\n\n\n  static get() {\n    let options\n    /*: RequestOptions*/\n    = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const controller = _CoreManager.default.getConfigController();\n\n    return controller.get(options);\n  }\n  /**\n   * Save value keys to the server.\n   *\n   * @static\n   * @param {object} attrs The config parameters and values.\n   * @param {object} masterKeyOnlyFlags The flags that define whether config parameters listed\n   * in `attrs` should be retrievable only by using the master key.\n   * For example: `param1: true` makes `param1` only retrievable by using the master key.\n   * If a parameter is not provided or set to `false`, it can be retrieved without\n   * using the master key.\n   * @returns {Promise} A promise that is resolved with a newly-created\n   *     configuration object or with the current with the update.\n   */\n\n\n  static save(attrs\n  /*: { [key: string]: any }*/\n  , masterKeyOnlyFlags\n  /*: { [key: string]: any }*/\n  ) {\n    const controller = _CoreManager.default.getConfigController(); // To avoid a mismatch with the local and the cloud config we get a new version\n\n\n    return controller.save(attrs, masterKeyOnlyFlags).then(() => {\n      return controller.get({\n        useMasterKey: true\n      });\n    }, error => {\n      return Promise.reject(error);\n    });\n  }\n  /**\n   * Used for testing\n   *\n   * @private\n   */\n\n\n  static _clearCache() {\n    currentConfig = null;\n  }\n\n}\n\nlet currentConfig = null;\nconst CURRENT_CONFIG_KEY = 'currentConfig';\n\nfunction decodePayload(data) {\n  try {\n    const json = JSON.parse(data);\n\n    if (json && typeof json === 'object') {\n      return (0, _decode.default)(json);\n    }\n  } catch (e) {\n    return null;\n  }\n}\n\nconst DefaultController = {\n  current() {\n    if (currentConfig) {\n      return currentConfig;\n    }\n\n    const config = new ParseConfig();\n\n    const storagePath = _Storage.default.generatePath(CURRENT_CONFIG_KEY);\n\n    if (!_Storage.default.async()) {\n      const configData = _Storage.default.getItem(storagePath);\n\n      if (configData) {\n        const attributes = decodePayload(configData);\n\n        if (attributes) {\n          config.attributes = attributes;\n          currentConfig = config;\n        }\n      }\n\n      return config;\n    } // Return a promise for async storage controllers\n\n\n    return _Storage.default.getItemAsync(storagePath).then(configData => {\n      if (configData) {\n        const attributes = decodePayload(configData);\n\n        if (attributes) {\n          config.attributes = attributes;\n          currentConfig = config;\n        }\n      }\n\n      return config;\n    });\n  },\n\n  get() {\n    let options\n    /*: RequestOptions*/\n    = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'config', {}, options).then(response => {\n      if (!response || !response.params) {\n        const error = new _ParseError.default(_ParseError.default.INVALID_JSON, 'Config JSON response invalid.');\n        return Promise.reject(error);\n      }\n\n      const config = new ParseConfig();\n      config.attributes = {};\n\n      for (const attr in response.params) {\n        config.attributes[attr] = (0, _decode.default)(response.params[attr]);\n      }\n\n      currentConfig = config;\n      return _Storage.default.setItemAsync(_Storage.default.generatePath(CURRENT_CONFIG_KEY), JSON.stringify(response.params)).then(() => {\n        return config;\n      });\n    });\n  },\n\n  save(attrs\n  /*: { [key: string]: any }*/\n  , masterKeyOnlyFlags\n  /*: { [key: string]: any }*/\n  ) {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    const encodedAttrs = {};\n\n    for (const key in attrs) {\n      encodedAttrs[key] = (0, _encode.default)(attrs[key]);\n    }\n\n    return RESTController.request('PUT', 'config', {\n      params: encodedAttrs,\n      masterKeyOnly: masterKeyOnlyFlags\n    }, {\n      useMasterKey: true\n    }).then(response => {\n      if (response && response.result) {\n        return Promise.resolve();\n      }\n\n      const error = new _ParseError.default(_ParseError.default.INTERNAL_SERVER_ERROR, 'Error occured updating Config.');\n      return Promise.reject(error);\n    });\n  }\n\n};\n\n_CoreManager.default.setConfigController(DefaultController);\n\nvar _default = ParseConfig;\nexports.default = _default;","map":{"version":3,"sources":["S:/final hackathon/nfi3/node_modules/moralis/lib/node/ParseConfig.js"],"names":["Object","defineProperty","exports","value","default","_CoreManager","_interopRequireDefault","require","_decode","_encode","_escape","_ParseError","_Storage","obj","__esModule","_defineProperty","key","enumerable","configurable","writable","ParseConfig","constructor","attributes","_escapedAttributes","get","attr","escape","html","val","escaped","toString","current","controller","getConfigController","options","save","attrs","masterKeyOnlyFlags","then","useMasterKey","error","Promise","reject","_clearCache","currentConfig","CURRENT_CONFIG_KEY","decodePayload","data","json","JSON","parse","e","DefaultController","config","storagePath","generatePath","async","configData","getItem","getItemAsync","RESTController","getRESTController","request","response","params","INVALID_JSON","setItemAsync","stringify","encodedAttrs","masterKeyOnly","result","resolve","INTERNAL_SERVER_ERROR","setConfigController","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _escape = _interopRequireDefault(require(\"./escape\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Parse.Config is a local representation of configuration data that\n * can be set from the Parse dashboard.\n *\n * @alias Parse.Config\n */\n\n\nclass ParseConfig {\n  constructor() {\n    _defineProperty(this, \"attributes\", void 0);\n\n    _defineProperty(this, \"_escapedAttributes\", void 0);\n\n    this.attributes = {};\n    this._escapedAttributes = {};\n  }\n  /**\n   * Gets the value of an attribute.\n   *\n   * @param {string} attr The name of an attribute.\n   * @returns {*}\n   */\n\n\n  get(attr\n  /*: string*/\n  )\n  /*: any*/\n  {\n    return this.attributes[attr];\n  }\n  /**\n   * Gets the HTML-escaped value of an attribute.\n   *\n   * @param {string} attr The name of an attribute.\n   * @returns {string}\n   */\n\n\n  escape(attr\n  /*: string*/\n  )\n  /*: string*/\n  {\n    const html = this._escapedAttributes[attr];\n\n    if (html) {\n      return html;\n    }\n\n    const val = this.attributes[attr];\n    let escaped = '';\n\n    if (val != null) {\n      escaped = (0, _escape.default)(val.toString());\n    }\n\n    this._escapedAttributes[attr] = escaped;\n    return escaped;\n  }\n  /**\n   * Retrieves the most recently-fetched configuration object, either from\n   * memory or from local storage if necessary.\n   *\n   * @static\n   * @returns {Parse.Config} The most recently-fetched Parse.Config if it\n   *     exists, else an empty Parse.Config.\n   */\n\n\n  static current() {\n    const controller = _CoreManager.default.getConfigController();\n\n    return controller.current();\n  }\n  /**\n   * Gets a new configuration object from the server.\n   *\n   * @static\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   * </ul>\n   * @returns {Promise} A promise that is resolved with a newly-created\n   *     configuration object when the get completes.\n   */\n\n\n  static get(options\n  /*: RequestOptions*/\n  = {}) {\n    const controller = _CoreManager.default.getConfigController();\n\n    return controller.get(options);\n  }\n  /**\n   * Save value keys to the server.\n   *\n   * @static\n   * @param {object} attrs The config parameters and values.\n   * @param {object} masterKeyOnlyFlags The flags that define whether config parameters listed\n   * in `attrs` should be retrievable only by using the master key.\n   * For example: `param1: true` makes `param1` only retrievable by using the master key.\n   * If a parameter is not provided or set to `false`, it can be retrieved without\n   * using the master key.\n   * @returns {Promise} A promise that is resolved with a newly-created\n   *     configuration object or with the current with the update.\n   */\n\n\n  static save(attrs\n  /*: { [key: string]: any }*/\n  , masterKeyOnlyFlags\n  /*: { [key: string]: any }*/\n  ) {\n    const controller = _CoreManager.default.getConfigController(); // To avoid a mismatch with the local and the cloud config we get a new version\n\n\n    return controller.save(attrs, masterKeyOnlyFlags).then(() => {\n      return controller.get({\n        useMasterKey: true\n      });\n    }, error => {\n      return Promise.reject(error);\n    });\n  }\n  /**\n   * Used for testing\n   *\n   * @private\n   */\n\n\n  static _clearCache() {\n    currentConfig = null;\n  }\n\n}\n\nlet currentConfig = null;\nconst CURRENT_CONFIG_KEY = 'currentConfig';\n\nfunction decodePayload(data) {\n  try {\n    const json = JSON.parse(data);\n\n    if (json && typeof json === 'object') {\n      return (0, _decode.default)(json);\n    }\n  } catch (e) {\n    return null;\n  }\n}\n\nconst DefaultController = {\n  current() {\n    if (currentConfig) {\n      return currentConfig;\n    }\n\n    const config = new ParseConfig();\n\n    const storagePath = _Storage.default.generatePath(CURRENT_CONFIG_KEY);\n\n    if (!_Storage.default.async()) {\n      const configData = _Storage.default.getItem(storagePath);\n\n      if (configData) {\n        const attributes = decodePayload(configData);\n\n        if (attributes) {\n          config.attributes = attributes;\n          currentConfig = config;\n        }\n      }\n\n      return config;\n    } // Return a promise for async storage controllers\n\n\n    return _Storage.default.getItemAsync(storagePath).then(configData => {\n      if (configData) {\n        const attributes = decodePayload(configData);\n\n        if (attributes) {\n          config.attributes = attributes;\n          currentConfig = config;\n        }\n      }\n\n      return config;\n    });\n  },\n\n  get(options\n  /*: RequestOptions*/\n  = {}) {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'config', {}, options).then(response => {\n      if (!response || !response.params) {\n        const error = new _ParseError.default(_ParseError.default.INVALID_JSON, 'Config JSON response invalid.');\n        return Promise.reject(error);\n      }\n\n      const config = new ParseConfig();\n      config.attributes = {};\n\n      for (const attr in response.params) {\n        config.attributes[attr] = (0, _decode.default)(response.params[attr]);\n      }\n\n      currentConfig = config;\n      return _Storage.default.setItemAsync(_Storage.default.generatePath(CURRENT_CONFIG_KEY), JSON.stringify(response.params)).then(() => {\n        return config;\n      });\n    });\n  },\n\n  save(attrs\n  /*: { [key: string]: any }*/\n  , masterKeyOnlyFlags\n  /*: { [key: string]: any }*/\n  ) {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    const encodedAttrs = {};\n\n    for (const key in attrs) {\n      encodedAttrs[key] = (0, _encode.default)(attrs[key]);\n    }\n\n    return RESTController.request('PUT', 'config', {\n      params: encodedAttrs,\n      masterKeyOnly: masterKeyOnlyFlags\n    }, {\n      useMasterKey: true\n    }).then(response => {\n      if (response && response.result) {\n        return Promise.resolve();\n      }\n\n      const error = new _ParseError.default(_ParseError.default.INTERNAL_SERVER_ERROR, 'Error occured updating Config.');\n      return Promise.reject(error);\n    });\n  }\n\n};\n\n_CoreManager.default.setConfigController(DefaultController);\n\nvar _default = ParseConfig;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}