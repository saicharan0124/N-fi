{"ast":null,"code":"async function* _batch(size, iterable) {\n  let dataBatch = [];\n\n  for await (const data of iterable) {\n    dataBatch.push(data);\n\n    if (dataBatch.length === size) {\n      yield dataBatch;\n      dataBatch = [];\n    }\n  }\n\n  if (dataBatch.length > 0) {\n    yield dataBatch;\n  }\n}\n\nfunction* _syncBatch(size, iterable) {\n  let dataBatch = [];\n\n  for (const data of iterable) {\n    dataBatch.push(data);\n\n    if (dataBatch.length === size) {\n      yield dataBatch;\n      dataBatch = [];\n    }\n  }\n\n  if (dataBatch.length > 0) {\n    yield dataBatch;\n  }\n}\n\nfunction batch(size, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => batch(size, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _batch(size, iterable);\n  }\n\n  return _syncBatch(size, iterable);\n}\n\nconst TIMEOUT = Symbol('TIMEOUT');\n\nconst createTimer = duration => {\n  let timeoutId;\n  return [new Promise(resolve => {\n    timeoutId = setTimeout(() => resolve(TIMEOUT), duration);\n  }), () => {\n    clearTimeout(timeoutId);\n  }];\n}; // Like `batch` but flushes early if the `timeout` is reached\n// NOTE: The strategy is to only hold onto a single item for a maximum of `timeout` ms.\n\n\nasync function* _batchWithTimeout(size, timeout, iterable) {\n  const iterator = iterable[Symbol.asyncIterator]();\n  let pendingData;\n  let batchData = [];\n  let timer;\n  let clearTimer;\n\n  const startTimer = () => {\n    deleteTimer();\n    [timer, clearTimer] = createTimer(timeout);\n  };\n\n  const deleteTimer = () => {\n    if (clearTimer) {\n      clearTimer();\n    }\n\n    timer = undefined;\n  };\n\n  pendingData = iterator.next();\n\n  while (true) {\n    const res = await (timer ? Promise.race([pendingData, timer]) : pendingData);\n\n    if (res === TIMEOUT || res.done) {\n      // Flush early (before we reach the batch size)\n      if (batchData.length) {\n        yield batchData;\n        batchData = [];\n      }\n\n      deleteTimer(); // And exit appropriately\n\n      if (res !== TIMEOUT) {\n        // done\n        break;\n      }\n\n      continue;\n    } // Fetch next item early doors (before we potentially yield)\n\n\n    pendingData = iterator.next(); // Then handle the value\n\n    batchData.push(res.value);\n\n    if (batchData.length === 1) {\n      // Start timer once we have at least 1 item ready to go\n      startTimer();\n    }\n\n    if (batchData.length === size) {\n      yield batchData;\n      batchData = [];\n      deleteTimer();\n      continue;\n    }\n  }\n}\n\nfunction batchWithTimeout(size, timeout, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => batchWithTimeout(size, timeout, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator] && timeout !== Infinity) {\n    return _batchWithTimeout(size, timeout, iterable);\n  } // For sync iterables or an infinite timeout, the timeout is irrelevant so just fallback to regular `batch`.\n\n\n  return batch(size, iterable);\n}\n\nfunction getIterator(iterable) {\n  if (typeof iterable.next === 'function') {\n    return iterable;\n  }\n\n  if (typeof iterable[Symbol.iterator] === 'function') {\n    return iterable[Symbol.iterator]();\n  }\n\n  if (typeof iterable[Symbol.asyncIterator] === 'function') {\n    return iterable[Symbol.asyncIterator]();\n  }\n\n  throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\n\nfunction defer() {\n  let reject;\n  let resolve;\n  const promise = new Promise((resolveFunc, rejectFunc) => {\n    resolve = resolveFunc;\n    reject = rejectFunc;\n  });\n  return {\n    promise,\n    reject,\n    resolve\n  };\n}\n\nfunction _buffer(size, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let reading = false;\n  let ended = false;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const readDeferred = readQueue.shift();\n      const {\n        error,\n        value\n      } = resultQueue.shift();\n\n      if (error) {\n        readDeferred.reject(error);\n      } else {\n        readDeferred.resolve({\n          done: false,\n          value\n        });\n      }\n    }\n\n    while (readQueue.length > 0 && ended) {\n      const {\n        resolve\n      } = readQueue.shift();\n      resolve({\n        done: true,\n        value: undefined\n      });\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (resultQueue.length >= size) {\n      return;\n    }\n\n    reading = true;\n\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        ended = true;\n      } else {\n        resultQueue.push({\n          value\n        });\n      }\n    } catch (error) {\n      ended = true;\n      resultQueue.push({\n        error\n      });\n    }\n\n    fulfillReadQueue();\n    reading = false;\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length > 0) {\n      const {\n        error,\n        value\n      } = resultQueue.shift();\n\n      if (error) {\n        throw error;\n      }\n\n      fillQueue();\n      return {\n        done: false,\n        value\n      };\n    }\n\n    if (ended) {\n      return {\n        done: true,\n        value: undefined\n      }; // stupid ts\n    }\n\n    const deferred = defer();\n    readQueue.push(deferred);\n    fillQueue();\n    return deferred.promise;\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction* syncBuffer(size, iterable) {\n  const valueQueue = [];\n  let e;\n\n  try {\n    for (const value of iterable) {\n      valueQueue.push(value);\n\n      if (valueQueue.length <= size) {\n        continue;\n      }\n\n      yield valueQueue.shift();\n    }\n  } catch (error) {\n    e = error;\n  }\n\n  for (const value of valueQueue) {\n    yield value;\n  }\n\n  if (e) {\n    throw e;\n  }\n}\n\nfunction buffer(size, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => buffer(size, curriedIterable);\n  }\n\n  if (size === 0) {\n    return iterable;\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _buffer(size, iterable);\n  }\n\n  return syncBuffer(size, iterable);\n}\n\nasync function _collect(iterable) {\n  const values = [];\n\n  for await (const value of iterable) {\n    values.push(value);\n  }\n\n  return values;\n}\n\nfunction collect(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return _collect(iterable);\n  }\n\n  return Array.from(iterable);\n}\n\nasync function* _concat(iterables) {\n  for await (const iterable of iterables) {\n    yield* iterable;\n  }\n}\n\nfunction* _syncConcat(iterables) {\n  for (const iterable of iterables) {\n    yield* iterable;\n  }\n}\n\nfunction concat() {\n  for (var _len = arguments.length, iterables = new Array(_len), _key = 0; _key < _len; _key++) {\n    iterables[_key] = arguments[_key];\n  }\n\n  const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n\n  if (hasAnyAsync) {\n    return _concat(iterables);\n  } else {\n    return _syncConcat(iterables);\n  }\n}\n\nasync function _consume(iterable) {\n  for await (const val of iterable) {// do nothing\n  }\n}\n\nfunction consume(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return _consume(iterable);\n  }\n\n  for (const val of iterable) {// do nothing\n  }\n}\n\nasync function* _filter(filterFunc, iterable) {\n  for await (const data of iterable) {\n    if (await filterFunc(data)) {\n      yield data;\n    }\n  }\n}\n\nfunction filter(filterFunc, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _filter(filterFunc, curriedIterable);\n  }\n\n  return _filter(filterFunc, iterable);\n}\n\nasync function* flatten(iterable) {\n  for await (const maybeItr of iterable) {\n    if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n      yield* flatten(maybeItr);\n    } else {\n      yield maybeItr;\n    }\n  }\n}\n\nasync function* _map(func, iterable) {\n  for await (const val of iterable) {\n    yield await func(val);\n  }\n}\n\nfunction map(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _map(func, curriedIterable);\n  }\n\n  return _map(func, iterable);\n}\n\nfunction flatMap(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => flatMap(func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n}\n\nfunction _flatTransform(concurrency, func, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let ended = false;\n  let reading = false;\n  let inflightCount = 0;\n  let lastError = null;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const {\n        resolve\n      } = readQueue.shift();\n      const value = resultQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n    }\n\n    while (readQueue.length > 0 && inflightCount === 0 && ended) {\n      const {\n        resolve,\n        reject\n      } = readQueue.shift();\n\n      if (lastError) {\n        reject(lastError);\n        lastError = null;\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      fulfillReadQueue();\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (inflightCount + resultQueue.length >= concurrency) {\n      return;\n    }\n\n    reading = true;\n    inflightCount++;\n\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        ended = true;\n        inflightCount--;\n        fulfillReadQueue();\n      } else {\n        mapAndQueue(value);\n      }\n    } catch (error) {\n      ended = true;\n      inflightCount--;\n      lastError = error;\n      fulfillReadQueue();\n    }\n\n    reading = false;\n    fillQueue();\n  }\n\n  async function mapAndQueue(itrValue) {\n    try {\n      const value = await func(itrValue);\n\n      if (value && value[Symbol.asyncIterator]) {\n        for await (const asyncVal of value) {\n          resultQueue.push(asyncVal);\n        }\n      } else {\n        resultQueue.push(value);\n      }\n    } catch (error) {\n      ended = true;\n      lastError = error;\n    }\n\n    inflightCount--;\n    fulfillReadQueue();\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length === 0) {\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n\n    const value = resultQueue.shift();\n    fillQueue();\n    return {\n      done: false,\n      value\n    };\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction flatTransform(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? flatTransform(concurrency, curriedFunc, curriedIterable) : flatTransform(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => flatTransform(concurrency, func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n}\n\nasync function onceReadable(stream) {\n  return new Promise(resolve => {\n    stream.once('readable', () => {\n      resolve();\n    });\n  });\n}\n\nasync function* _fromStream(stream) {\n  while (true) {\n    const data = stream.read();\n\n    if (data !== null) {\n      yield data;\n      continue;\n    }\n\n    if (stream._readableState.ended) {\n      break;\n    }\n\n    await onceReadable(stream);\n  }\n}\n\nfunction fromStream(stream) {\n  if (typeof stream[Symbol.asyncIterator] === 'function') {\n    return stream;\n  }\n\n  return _fromStream(stream);\n}\n\nasync function* merge() {\n  for (var _len2 = arguments.length, iterables = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    iterables[_key2] = arguments[_key2];\n  }\n\n  const sources = new Set(iterables.map(getIterator));\n\n  while (sources.size > 0) {\n    for (const iterator of sources) {\n      const nextVal = await iterator.next();\n\n      if (nextVal.done) {\n        sources.delete(iterator);\n      } else {\n        yield nextVal.value;\n      }\n    }\n  }\n}\n\nfunction pipeline(firstFn) {\n  let previousFn = firstFn();\n\n  for (var _len3 = arguments.length, fns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    fns[_key3 - 1] = arguments[_key3];\n  }\n\n  for (const func of fns) {\n    previousFn = func(previousFn);\n  }\n\n  return previousFn;\n}\n\nasync function* _parallelMap(concurrency, func, iterable) {\n  let transformError = null;\n\n  const wrapFunc = value => ({\n    value: func(value)\n  });\n\n  const stopOnError = async function* (source) {\n    for await (const value of source) {\n      if (transformError) {\n        return;\n      }\n\n      yield value;\n    }\n  };\n\n  const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n  const itr = getIterator(output);\n\n  while (true) {\n    const {\n      value,\n      done\n    } = await itr.next();\n\n    if (done) {\n      break;\n    }\n\n    try {\n      const val = await value.value;\n\n      if (!transformError) {\n        yield val;\n      }\n    } catch (error) {\n      transformError = error;\n    }\n  }\n\n  if (transformError) {\n    throw transformError;\n  }\n}\n\nfunction parallelMap(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n  }\n\n  if (concurrency === 1) {\n    return map(func, iterable);\n  }\n\n  return _parallelMap(concurrency, func, iterable);\n}\n\nfunction parallelFlatMap(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? parallelFlatMap(concurrency, curriedFunc, curriedIterable) : parallelFlatMap(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => parallelFlatMap(concurrency, func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n}\n\nasync function* parallelMerge() {\n  for (var _len4 = arguments.length, iterables = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    iterables[_key4] = arguments[_key4];\n  }\n\n  const inputs = iterables.map(getIterator);\n  const concurrentWork = new Set();\n  const values = new Map();\n  let lastError = null;\n  let errCb = null;\n  let valueCb = null;\n\n  const notifyError = err => {\n    lastError = err;\n\n    if (errCb) {\n      errCb(err);\n    }\n  };\n\n  const notifyDone = value => {\n    if (valueCb) {\n      valueCb(value);\n    }\n  };\n\n  const waitForQueue = () => new Promise((resolve, reject) => {\n    if (lastError) {\n      reject(lastError);\n    }\n\n    if (values.size > 0) {\n      return resolve();\n    }\n\n    valueCb = resolve;\n    errCb = reject;\n  });\n\n  const queueNext = input => {\n    const nextVal = Promise.resolve(input.next()).then(async _ref => {\n      let {\n        done,\n        value\n      } = _ref;\n\n      if (!done) {\n        values.set(input, value);\n      }\n\n      concurrentWork.delete(nextVal);\n    });\n    concurrentWork.add(nextVal);\n    nextVal.then(notifyDone, notifyError);\n  };\n\n  for (const input of inputs) {\n    queueNext(input);\n  }\n\n  while (true) {\n    // We technically don't have to check `values.size` as the for loop should have emptied it\n    // However I haven't yet found specs verifying that behavior, only tests\n    // the guard in waitForQueue() checking for values is in place for the same reason\n    if (concurrentWork.size === 0 && values.size === 0) {\n      return;\n    }\n\n    await waitForQueue();\n\n    for (const [input, value] of values) {\n      values.delete(input);\n      yield value;\n      queueNext(input);\n    }\n  }\n}\n\nasync function _reduce(func, start, iterable) {\n  let value = start;\n\n  for await (const nextItem of iterable) {\n    value = await func(value, nextItem);\n  }\n\n  return value;\n}\n\nfunction reduce(func, start, iterable) {\n  if (start === undefined) {\n    return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => reduce(func, start, curriedIterable);\n  }\n\n  return _reduce(func, start, iterable);\n}\n\nasync function* _take(count, iterable) {\n  let taken = 0;\n\n  for await (const val of iterable) {\n    yield await val;\n    taken++;\n\n    if (taken >= count) {\n      break;\n    }\n  }\n}\n\nfunction* _syncTake(count, iterable) {\n  let taken = 0;\n\n  for (const val of iterable) {\n    yield val;\n    taken++;\n\n    if (taken >= count) {\n      break;\n    }\n  }\n}\n\nfunction take(count, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => take(count, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _take(count, iterable);\n  }\n\n  return _syncTake(count, iterable);\n}\n\nasync function* _asyncTap(func, iterable) {\n  for await (const val of iterable) {\n    await func(val);\n    yield val;\n  }\n}\n\nfunction tap(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _asyncTap(func, curriedIterable);\n  }\n\n  return _asyncTap(func, iterable);\n}\n\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n\nfunction _throttle(limit, interval, iterable) {\n  if (!Number.isFinite(limit)) {\n    throw new TypeError('Expected `limit` to be a finite number');\n  }\n\n  if (limit <= 0) {\n    throw new TypeError('Expected `limit` to be greater than 0');\n  }\n\n  if (!Number.isFinite(interval)) {\n    throw new TypeError('Expected `interval` to be a finite number');\n  }\n\n  return async function* __throttle() {\n    let sent = 0;\n    let time;\n\n    for await (const val of iterable) {\n      if (sent < limit) {\n        if (typeof time === 'undefined') {\n          time = Date.now();\n        }\n\n        sent++;\n        yield val;\n        continue;\n      } // Only wait if the interval hasn't already passed while we were\n      // yielding the previous values.\n\n\n      const elapsedMs = Date.now() - time;\n      const waitFor = interval - elapsedMs;\n\n      if (waitFor > 0) {\n        await sleep(waitFor);\n      }\n\n      time = Date.now();\n      sent = 1;\n      yield val;\n    }\n  }();\n}\n\nfunction throttle(limit, interval, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _throttle(limit, interval, curriedIterable);\n  }\n\n  return _throttle(limit, interval, iterable);\n}\n\nfunction addTime(a, b) {\n  let seconds = a[0] + b[0];\n  let nanoseconds = a[1] + b[1];\n\n  if (nanoseconds >= 1000000000) {\n    const remainder = nanoseconds % 1000000000;\n    seconds += (nanoseconds - remainder) / 1000000000;\n    nanoseconds = remainder;\n  }\n\n  return [seconds, nanoseconds];\n}\n\nasync function* _asyncTime(config, iterable) {\n  const itr = iterable[Symbol.asyncIterator]();\n  let total = [0, 0];\n\n  while (true) {\n    const start = process.hrtime();\n    const {\n      value,\n      done\n    } = await itr.next();\n    const delta = process.hrtime(start);\n    total = addTime(total, delta);\n\n    if (config.progress) {\n      config.progress(delta, total);\n    }\n\n    if (done) {\n      if (config.total) {\n        config.total(total);\n      }\n\n      return value;\n    }\n\n    yield value;\n  }\n}\n\nfunction* _syncTime(config, iterable) {\n  const itr = iterable[Symbol.iterator]();\n  let total = [0, 0];\n\n  while (true) {\n    const start = process.hrtime();\n    const {\n      value,\n      done\n    } = itr.next();\n    const delta = process.hrtime(start);\n    total = addTime(total, delta);\n\n    if (config.progress) {\n      config.progress(delta, total);\n    }\n\n    if (done) {\n      if (config.total) {\n        config.total(total);\n      }\n\n      return value;\n    }\n\n    yield value;\n  }\n}\n\nfunction time() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let iterable = arguments.length > 1 ? arguments[1] : undefined;\n\n  if (iterable === undefined) {\n    return curriedIterable => time(config, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator] !== undefined) {\n    return _asyncTime(config, iterable);\n  } else {\n    return _syncTime(config, iterable);\n  }\n}\n\nfunction _transform(concurrency, func, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let ended = false;\n  let reading = false;\n  let inflightCount = 0;\n  let lastError = null;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const {\n        resolve\n      } = readQueue.shift();\n      const value = resultQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n    }\n\n    while (readQueue.length > 0 && inflightCount === 0 && ended) {\n      const {\n        resolve,\n        reject\n      } = readQueue.shift();\n\n      if (lastError) {\n        reject(lastError);\n        lastError = null;\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      fulfillReadQueue();\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (inflightCount + resultQueue.length >= concurrency) {\n      return;\n    }\n\n    reading = true;\n    inflightCount++;\n\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        ended = true;\n        inflightCount--;\n        fulfillReadQueue();\n      } else {\n        mapAndQueue(value);\n      }\n    } catch (error) {\n      ended = true;\n      inflightCount--;\n      lastError = error;\n      fulfillReadQueue();\n    }\n\n    reading = false;\n    fillQueue();\n  }\n\n  async function mapAndQueue(itrValue) {\n    try {\n      const value = await func(itrValue);\n      resultQueue.push(value);\n    } catch (error) {\n      ended = true;\n      lastError = error;\n    }\n\n    inflightCount--;\n    fulfillReadQueue();\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length === 0) {\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n\n    const value = resultQueue.shift();\n    fillQueue();\n    return {\n      done: false,\n      value\n    };\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction transform(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => transform(concurrency, func, curriedIterable);\n  }\n\n  return _transform(concurrency, func, iterable);\n}\n\nasync function _writeToStream(stream, iterable) {\n  let lastError = null;\n  let errCb = null;\n  let drainCb = null;\n\n  const notifyError = err => {\n    lastError = err;\n\n    if (errCb) {\n      errCb(err);\n    }\n  };\n\n  const notifyDrain = () => {\n    if (drainCb) {\n      drainCb();\n    }\n  };\n\n  const cleanup = () => {\n    stream.removeListener('error', notifyError);\n    stream.removeListener('drain', notifyDrain);\n  };\n\n  stream.once('error', notifyError);\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    if (lastError) {\n      return reject(lastError);\n    }\n\n    stream.once('drain', notifyDrain);\n    drainCb = resolve;\n    errCb = reject;\n  });\n\n  for await (const value of iterable) {\n    if (stream.write(value) === false) {\n      await waitForDrain();\n    }\n\n    if (lastError) {\n      break;\n    }\n  }\n\n  cleanup();\n\n  if (lastError) {\n    throw lastError;\n  }\n}\n\nfunction writeToStream(stream, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _writeToStream(stream, curriedIterable);\n  }\n\n  return _writeToStream(stream, iterable);\n}\n\nexport { batch, batchWithTimeout, buffer, collect, concat, consume, filter, flatMap, flatTransform, flatten, fromStream, getIterator, map, merge, parallelFlatMap, parallelMap, parallelMerge, pipeline, reduce, take, tap, throttle, time, transform, writeToStream };","map":{"version":3,"sources":["S:/final hack checkpoin/nfi3/node_modules/streaming-iterables/dist/index.mjs"],"names":["_batch","size","iterable","dataBatch","data","push","length","_syncBatch","batch","undefined","curriedIterable","Symbol","asyncIterator","TIMEOUT","createTimer","duration","timeoutId","Promise","resolve","setTimeout","clearTimeout","_batchWithTimeout","timeout","iterator","pendingData","batchData","timer","clearTimer","startTimer","deleteTimer","next","res","race","done","value","batchWithTimeout","Infinity","getIterator","TypeError","defer","reject","promise","resolveFunc","rejectFunc","_buffer","resultQueue","readQueue","reading","ended","fulfillReadQueue","readDeferred","shift","error","fillQueue","deferred","asyncIterableIterator","syncBuffer","valueQueue","e","buffer","_collect","values","collect","Array","from","_concat","iterables","_syncConcat","concat","hasAnyAsync","find","itr","_consume","val","consume","_filter","filterFunc","filter","flatten","maybeItr","_map","func","map","flatMap","i","_flatTransform","concurrency","inflightCount","lastError","mapAndQueue","itrValue","asyncVal","flatTransform","curriedFunc","onceReadable","stream","once","_fromStream","read","_readableState","fromStream","merge","sources","Set","nextVal","delete","pipeline","firstFn","previousFn","fns","_parallelMap","transformError","wrapFunc","stopOnError","source","output","parallelMap","parallelFlatMap","parallelMerge","inputs","concurrentWork","Map","errCb","valueCb","notifyError","err","notifyDone","waitForQueue","queueNext","input","then","set","add","_reduce","start","nextItem","reduce","curriedStart","_take","count","taken","_syncTake","take","_asyncTap","tap","sleep","ms","_throttle","limit","interval","Number","isFinite","__throttle","sent","time","Date","now","elapsedMs","waitFor","throttle","addTime","a","b","seconds","nanoseconds","remainder","_asyncTime","config","total","process","hrtime","delta","progress","_syncTime","_transform","transform","_writeToStream","drainCb","notifyDrain","cleanup","removeListener","waitForDrain","write","writeToStream"],"mappings":"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","sourcesContent":["async function* _batch(size, iterable) {\n    let dataBatch = [];\n    for await (const data of iterable) {\n        dataBatch.push(data);\n        if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n        }\n    }\n    if (dataBatch.length > 0) {\n        yield dataBatch;\n    }\n}\nfunction* _syncBatch(size, iterable) {\n    let dataBatch = [];\n    for (const data of iterable) {\n        dataBatch.push(data);\n        if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n        }\n    }\n    if (dataBatch.length > 0) {\n        yield dataBatch;\n    }\n}\nfunction batch(size, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => batch(size, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _batch(size, iterable);\n    }\n    return _syncBatch(size, iterable);\n}\n\nconst TIMEOUT = Symbol('TIMEOUT');\nconst createTimer = (duration) => {\n    let timeoutId;\n    return [\n        new Promise(resolve => {\n            timeoutId = setTimeout(() => resolve(TIMEOUT), duration);\n        }),\n        () => {\n            clearTimeout(timeoutId);\n        },\n    ];\n};\n// Like `batch` but flushes early if the `timeout` is reached\n// NOTE: The strategy is to only hold onto a single item for a maximum of `timeout` ms.\nasync function* _batchWithTimeout(size, timeout, iterable) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    let pendingData;\n    let batchData = [];\n    let timer;\n    let clearTimer;\n    const startTimer = () => {\n        deleteTimer();\n        [timer, clearTimer] = createTimer(timeout);\n    };\n    const deleteTimer = () => {\n        if (clearTimer) {\n            clearTimer();\n        }\n        timer = undefined;\n    };\n    pendingData = iterator.next();\n    while (true) {\n        const res = await (timer ? Promise.race([pendingData, timer]) : pendingData);\n        if (res === TIMEOUT || res.done) {\n            // Flush early (before we reach the batch size)\n            if (batchData.length) {\n                yield batchData;\n                batchData = [];\n            }\n            deleteTimer();\n            // And exit appropriately\n            if (res !== TIMEOUT) {\n                // done\n                break;\n            }\n            continue;\n        }\n        // Fetch next item early doors (before we potentially yield)\n        pendingData = iterator.next();\n        // Then handle the value\n        batchData.push(res.value);\n        if (batchData.length === 1) {\n            // Start timer once we have at least 1 item ready to go\n            startTimer();\n        }\n        if (batchData.length === size) {\n            yield batchData;\n            batchData = [];\n            deleteTimer();\n            continue;\n        }\n    }\n}\nfunction batchWithTimeout(size, timeout, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => batchWithTimeout(size, timeout, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator] && timeout !== Infinity) {\n        return _batchWithTimeout(size, timeout, iterable);\n    }\n    // For sync iterables or an infinite timeout, the timeout is irrelevant so just fallback to regular `batch`.\n    return batch(size, iterable);\n}\n\nfunction getIterator(iterable) {\n    if (typeof iterable.next === 'function') {\n        return iterable;\n    }\n    if (typeof iterable[Symbol.iterator] === 'function') {\n        return iterable[Symbol.iterator]();\n    }\n    if (typeof iterable[Symbol.asyncIterator] === 'function') {\n        return iterable[Symbol.asyncIterator]();\n    }\n    throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\n\nfunction defer() {\n    let reject;\n    let resolve;\n    const promise = new Promise((resolveFunc, rejectFunc) => {\n        resolve = resolveFunc;\n        reject = rejectFunc;\n    });\n    return {\n        promise,\n        reject,\n        resolve,\n    };\n}\n\nfunction _buffer(size, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let reading = false;\n    let ended = false;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const readDeferred = readQueue.shift();\n            const { error, value } = resultQueue.shift();\n            if (error) {\n                readDeferred.reject(error);\n            }\n            else {\n                readDeferred.resolve({ done: false, value });\n            }\n        }\n        while (readQueue.length > 0 && ended) {\n            const { resolve } = readQueue.shift();\n            resolve({ done: true, value: undefined });\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (resultQueue.length >= size) {\n            return;\n        }\n        reading = true;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n            }\n            else {\n                resultQueue.push({ value });\n            }\n        }\n        catch (error) {\n            ended = true;\n            resultQueue.push({ error });\n        }\n        fulfillReadQueue();\n        reading = false;\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length > 0) {\n            const { error, value } = resultQueue.shift();\n            if (error) {\n                throw error;\n            }\n            fillQueue();\n            return { done: false, value };\n        }\n        if (ended) {\n            return { done: true, value: undefined }; // stupid ts\n        }\n        const deferred = defer();\n        readQueue.push(deferred);\n        fillQueue();\n        return deferred.promise;\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction* syncBuffer(size, iterable) {\n    const valueQueue = [];\n    let e;\n    try {\n        for (const value of iterable) {\n            valueQueue.push(value);\n            if (valueQueue.length <= size) {\n                continue;\n            }\n            yield valueQueue.shift();\n        }\n    }\n    catch (error) {\n        e = error;\n    }\n    for (const value of valueQueue) {\n        yield value;\n    }\n    if (e) {\n        throw e;\n    }\n}\nfunction buffer(size, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => buffer(size, curriedIterable);\n    }\n    if (size === 0) {\n        return iterable;\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _buffer(size, iterable);\n    }\n    return syncBuffer(size, iterable);\n}\n\nasync function _collect(iterable) {\n    const values = [];\n    for await (const value of iterable) {\n        values.push(value);\n    }\n    return values;\n}\nfunction collect(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n        return _collect(iterable);\n    }\n    return Array.from(iterable);\n}\n\nasync function* _concat(iterables) {\n    for await (const iterable of iterables) {\n        yield* iterable;\n    }\n}\nfunction* _syncConcat(iterables) {\n    for (const iterable of iterables) {\n        yield* iterable;\n    }\n}\nfunction concat(...iterables) {\n    const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n    if (hasAnyAsync) {\n        return _concat(iterables);\n    }\n    else {\n        return _syncConcat(iterables);\n    }\n}\n\nasync function _consume(iterable) {\n    for await (const val of iterable) {\n        // do nothing\n    }\n}\nfunction consume(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n        return _consume(iterable);\n    }\n    for (const val of iterable) {\n        // do nothing\n    }\n}\n\nasync function* _filter(filterFunc, iterable) {\n    for await (const data of iterable) {\n        if (await filterFunc(data)) {\n            yield data;\n        }\n    }\n}\nfunction filter(filterFunc, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _filter(filterFunc, curriedIterable);\n    }\n    return _filter(filterFunc, iterable);\n}\n\nasync function* flatten(iterable) {\n    for await (const maybeItr of iterable) {\n        if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n            yield* flatten(maybeItr);\n        }\n        else {\n            yield maybeItr;\n        }\n    }\n}\n\nasync function* _map(func, iterable) {\n    for await (const val of iterable) {\n        yield await func(val);\n    }\n}\nfunction map(func, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => _map(func, curriedIterable);\n    }\n    return _map(func, iterable);\n}\n\nfunction flatMap(func, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => flatMap(func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n}\n\nfunction _flatTransform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const { resolve } = readQueue.shift();\n            const value = resultQueue.shift();\n            resolve({ done: false, value });\n        }\n        while (readQueue.length > 0 && inflightCount === 0 && ended) {\n            const { resolve, reject } = readQueue.shift();\n            if (lastError) {\n                reject(lastError);\n                lastError = null;\n            }\n            else {\n                resolve({ done: true, value: undefined });\n            }\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            fulfillReadQueue();\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (inflightCount + resultQueue.length >= concurrency) {\n            return;\n        }\n        reading = true;\n        inflightCount++;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n                inflightCount--;\n                fulfillReadQueue();\n            }\n            else {\n                mapAndQueue(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            inflightCount--;\n            lastError = error;\n            fulfillReadQueue();\n        }\n        reading = false;\n        fillQueue();\n    }\n    async function mapAndQueue(itrValue) {\n        try {\n            const value = await func(itrValue);\n            if (value && value[Symbol.asyncIterator]) {\n                for await (const asyncVal of value) {\n                    resultQueue.push(asyncVal);\n                }\n            }\n            else {\n                resultQueue.push(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            lastError = error;\n        }\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length === 0) {\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const value = resultQueue.shift();\n        fillQueue();\n        return { done: false, value };\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction flatTransform(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? flatTransform(concurrency, curriedFunc, curriedIterable)\n            : flatTransform(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => flatTransform(concurrency, func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n}\n\nasync function onceReadable(stream) {\n    return new Promise(resolve => {\n        stream.once('readable', () => {\n            resolve();\n        });\n    });\n}\nasync function* _fromStream(stream) {\n    while (true) {\n        const data = stream.read();\n        if (data !== null) {\n            yield data;\n            continue;\n        }\n        if (stream._readableState.ended) {\n            break;\n        }\n        await onceReadable(stream);\n    }\n}\nfunction fromStream(stream) {\n    if (typeof stream[Symbol.asyncIterator] === 'function') {\n        return stream;\n    }\n    return _fromStream(stream);\n}\n\nasync function* merge(...iterables) {\n    const sources = new Set(iterables.map(getIterator));\n    while (sources.size > 0) {\n        for (const iterator of sources) {\n            const nextVal = await iterator.next();\n            if (nextVal.done) {\n                sources.delete(iterator);\n            }\n            else {\n                yield nextVal.value;\n            }\n        }\n    }\n}\n\nfunction pipeline(firstFn, ...fns) {\n    let previousFn = firstFn();\n    for (const func of fns) {\n        previousFn = func(previousFn);\n    }\n    return previousFn;\n}\n\nasync function* _parallelMap(concurrency, func, iterable) {\n    let transformError = null;\n    const wrapFunc = value => ({\n        value: func(value),\n    });\n    const stopOnError = async function* (source) {\n        for await (const value of source) {\n            if (transformError) {\n                return;\n            }\n            yield value;\n        }\n    };\n    const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n    const itr = getIterator(output);\n    while (true) {\n        const { value, done } = await itr.next();\n        if (done) {\n            break;\n        }\n        try {\n            const val = await value.value;\n            if (!transformError) {\n                yield val;\n            }\n        }\n        catch (error) {\n            transformError = error;\n        }\n    }\n    if (transformError) {\n        throw transformError;\n    }\n}\nfunction parallelMap(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n    }\n    if (iterable === undefined) {\n        return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n    }\n    if (concurrency === 1) {\n        return map(func, iterable);\n    }\n    return _parallelMap(concurrency, func, iterable);\n}\n\nfunction parallelFlatMap(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? parallelFlatMap(concurrency, curriedFunc, curriedIterable)\n            : parallelFlatMap(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => parallelFlatMap(concurrency, func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n}\n\nasync function* parallelMerge(...iterables) {\n    const inputs = iterables.map(getIterator);\n    const concurrentWork = new Set();\n    const values = new Map();\n    let lastError = null;\n    let errCb = null;\n    let valueCb = null;\n    const notifyError = err => {\n        lastError = err;\n        if (errCb) {\n            errCb(err);\n        }\n    };\n    const notifyDone = value => {\n        if (valueCb) {\n            valueCb(value);\n        }\n    };\n    const waitForQueue = () => new Promise((resolve, reject) => {\n        if (lastError) {\n            reject(lastError);\n        }\n        if (values.size > 0) {\n            return resolve();\n        }\n        valueCb = resolve;\n        errCb = reject;\n    });\n    const queueNext = input => {\n        const nextVal = Promise.resolve(input.next()).then(async ({ done, value }) => {\n            if (!done) {\n                values.set(input, value);\n            }\n            concurrentWork.delete(nextVal);\n        });\n        concurrentWork.add(nextVal);\n        nextVal.then(notifyDone, notifyError);\n    };\n    for (const input of inputs) {\n        queueNext(input);\n    }\n    while (true) {\n        // We technically don't have to check `values.size` as the for loop should have emptied it\n        // However I haven't yet found specs verifying that behavior, only tests\n        // the guard in waitForQueue() checking for values is in place for the same reason\n        if (concurrentWork.size === 0 && values.size === 0) {\n            return;\n        }\n        await waitForQueue();\n        for (const [input, value] of values) {\n            values.delete(input);\n            yield value;\n            queueNext(input);\n        }\n    }\n}\n\nasync function _reduce(func, start, iterable) {\n    let value = start;\n    for await (const nextItem of iterable) {\n        value = await func(value, nextItem);\n    }\n    return value;\n}\nfunction reduce(func, start, iterable) {\n    if (start === undefined) {\n        return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => reduce(func, start, curriedIterable);\n    }\n    return _reduce(func, start, iterable);\n}\n\nasync function* _take(count, iterable) {\n    let taken = 0;\n    for await (const val of iterable) {\n        yield await val;\n        taken++;\n        if (taken >= count) {\n            break;\n        }\n    }\n}\nfunction* _syncTake(count, iterable) {\n    let taken = 0;\n    for (const val of iterable) {\n        yield val;\n        taken++;\n        if (taken >= count) {\n            break;\n        }\n    }\n}\nfunction take(count, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => take(count, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _take(count, iterable);\n    }\n    return _syncTake(count, iterable);\n}\n\nasync function* _asyncTap(func, iterable) {\n    for await (const val of iterable) {\n        await func(val);\n        yield val;\n    }\n}\nfunction tap(func, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _asyncTap(func, curriedIterable);\n    }\n    return _asyncTap(func, iterable);\n}\n\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\nfunction _throttle(limit, interval, iterable) {\n    if (!Number.isFinite(limit)) {\n        throw new TypeError('Expected `limit` to be a finite number');\n    }\n    if (limit <= 0) {\n        throw new TypeError('Expected `limit` to be greater than 0');\n    }\n    if (!Number.isFinite(interval)) {\n        throw new TypeError('Expected `interval` to be a finite number');\n    }\n    return (async function* __throttle() {\n        let sent = 0;\n        let time;\n        for await (const val of iterable) {\n            if (sent < limit) {\n                if (typeof time === 'undefined') {\n                    time = Date.now();\n                }\n                sent++;\n                yield val;\n                continue;\n            }\n            // Only wait if the interval hasn't already passed while we were\n            // yielding the previous values.\n            const elapsedMs = Date.now() - time;\n            const waitFor = interval - elapsedMs;\n            if (waitFor > 0) {\n                await sleep(waitFor);\n            }\n            time = Date.now();\n            sent = 1;\n            yield val;\n        }\n    })();\n}\nfunction throttle(limit, interval, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _throttle(limit, interval, curriedIterable);\n    }\n    return _throttle(limit, interval, iterable);\n}\n\nfunction addTime(a, b) {\n    let seconds = a[0] + b[0];\n    let nanoseconds = a[1] + b[1];\n    if (nanoseconds >= 1000000000) {\n        const remainder = nanoseconds % 1000000000;\n        seconds += (nanoseconds - remainder) / 1000000000;\n        nanoseconds = remainder;\n    }\n    return [seconds, nanoseconds];\n}\nasync function* _asyncTime(config, iterable) {\n    const itr = iterable[Symbol.asyncIterator]();\n    let total = [0, 0];\n    while (true) {\n        const start = process.hrtime();\n        const { value, done } = await itr.next();\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n        if (config.progress) {\n            config.progress(delta, total);\n        }\n        if (done) {\n            if (config.total) {\n                config.total(total);\n            }\n            return value;\n        }\n        yield value;\n    }\n}\nfunction* _syncTime(config, iterable) {\n    const itr = iterable[Symbol.iterator]();\n    let total = [0, 0];\n    while (true) {\n        const start = process.hrtime();\n        const { value, done } = itr.next();\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n        if (config.progress) {\n            config.progress(delta, total);\n        }\n        if (done) {\n            if (config.total) {\n                config.total(total);\n            }\n            return value;\n        }\n        yield value;\n    }\n}\nfunction time(config = {}, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => time(config, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator] !== undefined) {\n        return _asyncTime(config, iterable);\n    }\n    else {\n        return _syncTime(config, iterable);\n    }\n}\n\nfunction _transform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const { resolve } = readQueue.shift();\n            const value = resultQueue.shift();\n            resolve({ done: false, value });\n        }\n        while (readQueue.length > 0 && inflightCount === 0 && ended) {\n            const { resolve, reject } = readQueue.shift();\n            if (lastError) {\n                reject(lastError);\n                lastError = null;\n            }\n            else {\n                resolve({ done: true, value: undefined });\n            }\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            fulfillReadQueue();\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (inflightCount + resultQueue.length >= concurrency) {\n            return;\n        }\n        reading = true;\n        inflightCount++;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n                inflightCount--;\n                fulfillReadQueue();\n            }\n            else {\n                mapAndQueue(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            inflightCount--;\n            lastError = error;\n            fulfillReadQueue();\n        }\n        reading = false;\n        fillQueue();\n    }\n    async function mapAndQueue(itrValue) {\n        try {\n            const value = await func(itrValue);\n            resultQueue.push(value);\n        }\n        catch (error) {\n            ended = true;\n            lastError = error;\n        }\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length === 0) {\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const value = resultQueue.shift();\n        fillQueue();\n        return { done: false, value };\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction transform(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? transform(concurrency, curriedFunc, curriedIterable)\n            : transform(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => transform(concurrency, func, curriedIterable);\n    }\n    return _transform(concurrency, func, iterable);\n}\n\nasync function _writeToStream(stream, iterable) {\n    let lastError = null;\n    let errCb = null;\n    let drainCb = null;\n    const notifyError = err => {\n        lastError = err;\n        if (errCb) {\n            errCb(err);\n        }\n    };\n    const notifyDrain = () => {\n        if (drainCb) {\n            drainCb();\n        }\n    };\n    const cleanup = () => {\n        stream.removeListener('error', notifyError);\n        stream.removeListener('drain', notifyDrain);\n    };\n    stream.once('error', notifyError);\n    const waitForDrain = () => new Promise((resolve, reject) => {\n        if (lastError) {\n            return reject(lastError);\n        }\n        stream.once('drain', notifyDrain);\n        drainCb = resolve;\n        errCb = reject;\n    });\n    for await (const value of iterable) {\n        if (stream.write(value) === false) {\n            await waitForDrain();\n        }\n        if (lastError) {\n            break;\n        }\n    }\n    cleanup();\n    if (lastError) {\n        throw lastError;\n    }\n}\nfunction writeToStream(stream, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _writeToStream(stream, curriedIterable);\n    }\n    return _writeToStream(stream, iterable);\n}\n\nexport { batch, batchWithTimeout, buffer, collect, concat, consume, filter, flatMap, flatTransform, flatten, fromStream, getIterator, map, merge, parallelFlatMap, parallelMap, parallelMerge, pipeline, reduce, take, tap, throttle, time, transform, writeToStream };\n"]},"metadata":{},"sourceType":"module"}