{"ast":null,"code":"\"use strict\";\n/* eslint-disable no-bitwise */\n\nfunction b64Digit(number\n/*: number*/\n)\n/*: string*/\n{\n  if (number < 26) {\n    return String.fromCharCode(65 + number);\n  }\n\n  if (number < 52) {\n    return String.fromCharCode(97 + (number - 26));\n  }\n\n  if (number < 62) {\n    return String.fromCharCode(48 + (number - 52));\n  }\n\n  if (number === 62) {\n    return '+';\n  }\n\n  if (number === 63) {\n    return '/';\n  }\n\n  throw new TypeError(`Tried to encode large digit ${number} in base64.`);\n}\n\nfunction encodeBase64(bytes\n/*: Array<number>*/\n)\n/*: string*/\n{\n  const chunks = [];\n  chunks.length = Math.ceil(bytes.length / 3);\n\n  for (let i = 0; i < chunks.length; i++) {\n    const b1 = bytes[i * 3];\n    const b2 = bytes[i * 3 + 1] || 0;\n    const b3 = bytes[i * 3 + 2] || 0;\n    const has2 = i * 3 + 1 < bytes.length;\n    const has3 = i * 3 + 2 < bytes.length;\n    chunks[i] = [b64Digit(b1 >> 2 & 0x3f), b64Digit(b1 << 4 & 0x30 | b2 >> 4 & 0x0f), has2 ? b64Digit(b2 << 2 & 0x3c | b3 >> 6 & 0x03) : '=', has3 ? b64Digit(b3 & 0x3f) : '='].join('');\n  }\n\n  return chunks.join('');\n}\n\nmodule.exports = {\n  encodeBase64,\n  b64Digit\n};","map":{"version":3,"sources":["S:/final hackathon/nfi3/node_modules/moralis/lib/node/ParseFileEncode.js"],"names":["b64Digit","number","String","fromCharCode","TypeError","encodeBase64","bytes","chunks","length","Math","ceil","i","b1","b2","b3","has2","has3","join","module","exports"],"mappings":"AAAA;AACA;;AAEA,SAASA,QAAT,CAAkBC;AAClB;AADA;AAGA;AACA;AACE,MAAIA,MAAM,GAAG,EAAb,EAAiB;AACf,WAAOC,MAAM,CAACC,YAAP,CAAoB,KAAKF,MAAzB,CAAP;AACD;;AAED,MAAIA,MAAM,GAAG,EAAb,EAAiB;AACf,WAAOC,MAAM,CAACC,YAAP,CAAoB,MAAMF,MAAM,GAAG,EAAf,CAApB,CAAP;AACD;;AAED,MAAIA,MAAM,GAAG,EAAb,EAAiB;AACf,WAAOC,MAAM,CAACC,YAAP,CAAoB,MAAMF,MAAM,GAAG,EAAf,CAApB,CAAP;AACD;;AAED,MAAIA,MAAM,KAAK,EAAf,EAAmB;AACjB,WAAO,GAAP;AACD;;AAED,MAAIA,MAAM,KAAK,EAAf,EAAmB;AACjB,WAAO,GAAP;AACD;;AAED,QAAM,IAAIG,SAAJ,CAAe,+BAA8BH,MAAO,aAApD,CAAN;AACD;;AAED,SAASI,YAAT,CAAsBC;AACtB;AADA;AAGA;AACA;AACE,QAAMC,MAAM,GAAG,EAAf;AACAA,EAAAA,MAAM,CAACC,MAAP,GAAgBC,IAAI,CAACC,IAAL,CAAUJ,KAAK,CAACE,MAAN,GAAe,CAAzB,CAAhB;;AAEA,OAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAAM,CAACC,MAA3B,EAAmCG,CAAC,EAApC,EAAwC;AACtC,UAAMC,EAAE,GAAGN,KAAK,CAACK,CAAC,GAAG,CAAL,CAAhB;AACA,UAAME,EAAE,GAAGP,KAAK,CAACK,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAL,IAAoB,CAA/B;AACA,UAAMG,EAAE,GAAGR,KAAK,CAACK,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAL,IAAoB,CAA/B;AACA,UAAMI,IAAI,GAAGJ,CAAC,GAAG,CAAJ,GAAQ,CAAR,GAAYL,KAAK,CAACE,MAA/B;AACA,UAAMQ,IAAI,GAAGL,CAAC,GAAG,CAAJ,GAAQ,CAAR,GAAYL,KAAK,CAACE,MAA/B;AACAD,IAAAA,MAAM,CAACI,CAAD,CAAN,GAAY,CAACX,QAAQ,CAACY,EAAE,IAAI,CAAN,GAAU,IAAX,CAAT,EAA2BZ,QAAQ,CAACY,EAAE,IAAI,CAAN,GAAU,IAAV,GAAiBC,EAAE,IAAI,CAAN,GAAU,IAA5B,CAAnC,EAAsEE,IAAI,GAAGf,QAAQ,CAACa,EAAE,IAAI,CAAN,GAAU,IAAV,GAAiBC,EAAE,IAAI,CAAN,GAAU,IAA5B,CAAX,GAA+C,GAAzH,EAA8HE,IAAI,GAAGhB,QAAQ,CAACc,EAAE,GAAG,IAAN,CAAX,GAAyB,GAA3J,EAAgKG,IAAhK,CAAqK,EAArK,CAAZ;AACD;;AAED,SAAOV,MAAM,CAACU,IAAP,CAAY,EAAZ,CAAP;AACD;;AAEDC,MAAM,CAACC,OAAP,GAAiB;AACfd,EAAAA,YADe;AAEfL,EAAAA;AAFe,CAAjB","sourcesContent":["\"use strict\";\n/* eslint-disable no-bitwise */\n\nfunction b64Digit(number\n/*: number*/\n)\n/*: string*/\n{\n  if (number < 26) {\n    return String.fromCharCode(65 + number);\n  }\n\n  if (number < 52) {\n    return String.fromCharCode(97 + (number - 26));\n  }\n\n  if (number < 62) {\n    return String.fromCharCode(48 + (number - 52));\n  }\n\n  if (number === 62) {\n    return '+';\n  }\n\n  if (number === 63) {\n    return '/';\n  }\n\n  throw new TypeError(`Tried to encode large digit ${number} in base64.`);\n}\n\nfunction encodeBase64(bytes\n/*: Array<number>*/\n)\n/*: string*/\n{\n  const chunks = [];\n  chunks.length = Math.ceil(bytes.length / 3);\n\n  for (let i = 0; i < chunks.length; i++) {\n    const b1 = bytes[i * 3];\n    const b2 = bytes[i * 3 + 1] || 0;\n    const b3 = bytes[i * 3 + 2] || 0;\n    const has2 = i * 3 + 1 < bytes.length;\n    const has3 = i * 3 + 2 < bytes.length;\n    chunks[i] = [b64Digit(b1 >> 2 & 0x3f), b64Digit(b1 << 4 & 0x30 | b2 >> 4 & 0x0f), has2 ? b64Digit(b2 << 2 & 0x3c | b3 >> 6 & 0x03) : '=', has3 ? b64Digit(b3 & 0x3f) : '='].join('');\n  }\n\n  return chunks.join('');\n}\n\nmodule.exports = {\n  encodeBase64,\n  b64Digit\n};"]},"metadata":{},"sourceType":"script"}