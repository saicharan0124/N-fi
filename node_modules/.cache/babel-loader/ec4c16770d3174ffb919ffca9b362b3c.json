{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _createSigningData = _interopRequireDefault(require(\"./createSigningData\"));\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseACL = _interopRequireDefault(require(\"./ParseACL\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst base64 = {\n  decode: s => Uint8Array.from(atob(s), c => c.charCodeAt(0)),\n  encode: b => btoa(String.fromCharCode(...new Uint8Array(b)))\n};\n\nclass MoralisSol {\n  static async authenticate(options) {\n    var _user$get;\n\n    const phantom = await MoralisSol.enable();\n    if (!phantom) throw new Error('Phantom wallet not available');\n    const solAddress = phantom.publicKey.toString();\n    if (!solAddress) throw new Error('Address not found');\n    const message = (options === null || options === void 0 ? void 0 : options.signingMessage) || MoralisSol.getSigningData();\n    const data = await (0, _createSigningData.default)(message);\n    const signature = await MoralisSol.sign(data);\n    const user = await _ParseUser.default.logInWith('moralisSol', {\n      authData: {\n        id: solAddress,\n        signature,\n        data\n      }\n    });\n    await user.setACL(new _ParseACL.default(user));\n    if (!user) throw new Error('Could not get user');\n    user.set('solAccounts', uniq([].concat([solAddress], (_user$get = user.get('solAccounts')) !== null && _user$get !== void 0 ? _user$get : [])));\n    user.set('solAddress', solAddress);\n    await user.save();\n    return user;\n  }\n\n  static async link(account, options) {\n    var _user$get2;\n\n    const message = (options === null || options === void 0 ? void 0 : options.signingMessage) || MoralisSol.getSigningData();\n    const user = await _ParseUser.default.current();\n    const solAddress = account;\n\n    const SolAddress = _ParseObject.default.extend('_SolAddress');\n\n    const query = new _ParseQuery.default(SolAddress);\n    const solAddressRecord = await query.get(solAddress).catch(() => null);\n\n    if (!solAddressRecord) {\n      const data = await (0, _createSigningData.default)(message);\n      const signature = await MoralisSol.sign(solAddress, data);\n      await user.linkWith('moralisSol', {\n        authData: {\n          id: solAddress,\n          signature,\n          data\n        }\n      });\n    }\n\n    user.set('SolAccounts', uniq([solAddress].concat((_user$get2 = user.get('SolAccounts')) !== null && _user$get2 !== void 0 ? _user$get2 : [])));\n    user.set('solAddress', solAddress);\n    await user.save();\n    return user;\n  }\n\n  static async unlink(account) {\n    var _user$get3;\n\n    const accountsLower = account;\n\n    const SolAddress = _ParseObject.default.extend('_SolAddress');\n\n    const query = new _ParseQuery.default(SolAddress);\n    const solAddressRecord = await query.get(accountsLower);\n    await solAddressRecord.destroy();\n    const user = await _ParseUser.default.current();\n    const accounts = (_user$get3 = user.get('solAccounts')) !== null && _user$get3 !== void 0 ? _user$get3 : [];\n    const nextAccounts = accounts.filter(v => v !== accountsLower);\n    user.set('solAccounts', nextAccounts);\n    user.set('solAddress', nextAccounts[0]);\n    await user._unlinkFrom('moralisSol');\n    await user.save();\n    return user;\n  }\n\n  static async sign(message) {\n    const phantom = await MoralisSol.enable();\n    const encodedMessage = new TextEncoder().encode(message);\n    const signedMessage = await phantom.signMessage(encodedMessage, 'utf8');\n    return base64.encode(signedMessage.signature);\n  }\n\n  static getSigningData() {\n    return 'Moralis Authentication';\n  }\n\n}\n\n_defineProperty(MoralisSol, \"enable\", async () => {\n  if (window && 'solana' in window) {\n    const provider = window.solana;\n\n    if (provider.isPhantom) {\n      try {\n        await provider.connect({\n          onlyIfTrusted: true\n        });\n      } catch (error) {\n        if (error.message === 'User rejected the request.') await provider.connect();else throw error;\n      }\n\n      return provider;\n    }\n  }\n\n  throw new Error('Phantom wallet not available');\n});\n\nfunction toHexString(buffer\n/*: Buffer*/\n) {\n  return buffer.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n\nfunction uniq(arr) {\n  return arr.filter((v, i) => arr.indexOf(v) === i);\n}\n\nvar _default = MoralisSol;\nexports.default = _default;","map":{"version":3,"sources":["S:/final hack checkpoin/nfi3/node_modules/moralis/lib/node/MoralisSol.js"],"names":["Object","defineProperty","exports","value","default","_createSigningData","_interopRequireDefault","require","_ParseUser","_ParseQuery","_ParseObject","_ParseACL","obj","__esModule","_defineProperty","key","enumerable","configurable","writable","base64","decode","s","Uint8Array","from","atob","c","charCodeAt","encode","b","btoa","String","fromCharCode","MoralisSol","authenticate","options","_user$get","phantom","enable","Error","solAddress","publicKey","toString","message","signingMessage","getSigningData","data","signature","sign","user","logInWith","authData","id","setACL","set","uniq","concat","get","save","link","account","_user$get2","current","SolAddress","extend","query","solAddressRecord","catch","linkWith","unlink","_user$get3","accountsLower","destroy","accounts","nextAccounts","filter","v","_unlinkFrom","encodedMessage","TextEncoder","signedMessage","signMessage","window","provider","solana","isPhantom","connect","onlyIfTrusted","error","toHexString","buffer","reduce","str","byte","padStart","arr","i","indexOf","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _createSigningData = _interopRequireDefault(require(\"./createSigningData\"));\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseACL = _interopRequireDefault(require(\"./ParseACL\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst base64 = {\n  decode: s => Uint8Array.from(atob(s), c => c.charCodeAt(0)),\n  encode: b => btoa(String.fromCharCode(...new Uint8Array(b)))\n};\n\nclass MoralisSol {\n  static async authenticate(options) {\n    var _user$get;\n\n    const phantom = await MoralisSol.enable();\n    if (!phantom) throw new Error('Phantom wallet not available');\n    const solAddress = phantom.publicKey.toString();\n    if (!solAddress) throw new Error('Address not found');\n    const message = (options === null || options === void 0 ? void 0 : options.signingMessage) || MoralisSol.getSigningData();\n    const data = await (0, _createSigningData.default)(message);\n    const signature = await MoralisSol.sign(data);\n    const user = await _ParseUser.default.logInWith('moralisSol', {\n      authData: {\n        id: solAddress,\n        signature,\n        data\n      }\n    });\n    await user.setACL(new _ParseACL.default(user));\n    if (!user) throw new Error('Could not get user');\n    user.set('solAccounts', uniq([].concat([solAddress], (_user$get = user.get('solAccounts')) !== null && _user$get !== void 0 ? _user$get : [])));\n    user.set('solAddress', solAddress);\n    await user.save();\n    return user;\n  }\n\n  static async link(account, options) {\n    var _user$get2;\n\n    const message = (options === null || options === void 0 ? void 0 : options.signingMessage) || MoralisSol.getSigningData();\n    const user = await _ParseUser.default.current();\n    const solAddress = account;\n\n    const SolAddress = _ParseObject.default.extend('_SolAddress');\n\n    const query = new _ParseQuery.default(SolAddress);\n    const solAddressRecord = await query.get(solAddress).catch(() => null);\n\n    if (!solAddressRecord) {\n      const data = await (0, _createSigningData.default)(message);\n      const signature = await MoralisSol.sign(solAddress, data);\n      await user.linkWith('moralisSol', {\n        authData: {\n          id: solAddress,\n          signature,\n          data\n        }\n      });\n    }\n\n    user.set('SolAccounts', uniq([solAddress].concat((_user$get2 = user.get('SolAccounts')) !== null && _user$get2 !== void 0 ? _user$get2 : [])));\n    user.set('solAddress', solAddress);\n    await user.save();\n    return user;\n  }\n\n  static async unlink(account) {\n    var _user$get3;\n\n    const accountsLower = account;\n\n    const SolAddress = _ParseObject.default.extend('_SolAddress');\n\n    const query = new _ParseQuery.default(SolAddress);\n    const solAddressRecord = await query.get(accountsLower);\n    await solAddressRecord.destroy();\n    const user = await _ParseUser.default.current();\n    const accounts = (_user$get3 = user.get('solAccounts')) !== null && _user$get3 !== void 0 ? _user$get3 : [];\n    const nextAccounts = accounts.filter(v => v !== accountsLower);\n    user.set('solAccounts', nextAccounts);\n    user.set('solAddress', nextAccounts[0]);\n    await user._unlinkFrom('moralisSol');\n    await user.save();\n    return user;\n  }\n\n  static async sign(message) {\n    const phantom = await MoralisSol.enable();\n    const encodedMessage = new TextEncoder().encode(message);\n    const signedMessage = await phantom.signMessage(encodedMessage, 'utf8');\n    return base64.encode(signedMessage.signature);\n  }\n\n  static getSigningData() {\n    return 'Moralis Authentication';\n  }\n\n}\n\n_defineProperty(MoralisSol, \"enable\", async () => {\n  if (window && 'solana' in window) {\n    const provider = window.solana;\n\n    if (provider.isPhantom) {\n      try {\n        await provider.connect({\n          onlyIfTrusted: true\n        });\n      } catch (error) {\n        if (error.message === 'User rejected the request.') await provider.connect();else throw error;\n      }\n\n      return provider;\n    }\n  }\n\n  throw new Error('Phantom wallet not available');\n});\n\nfunction toHexString(buffer\n/*: Buffer*/\n) {\n  return buffer.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n\nfunction uniq(arr) {\n  return arr.filter((v, i) => arr.indexOf(v) === i);\n}\n\nvar _default = MoralisSol;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}